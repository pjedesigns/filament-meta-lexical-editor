var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod16) => function __require() {
  return mod16 || (0, cb[__getOwnPropNames(cb)[0]])((mod16 = { exports: {} }).exports, mod16), mod16.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod16, isNodeMode, target) => (target = mod16 != null ? __create(__getProtoOf(mod16)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod16 || !mod16.__esModule ? __defProp(target, "default", { value: mod16, enumerable: true }) : target,
  mod16
));
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// node_modules/prismjs/prism.js
var require_prism = __commonJS({
  "node_modules/prismjs/prism.js"(exports, module) {
    var _self = typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope ? self : {};
    var Prism2 = (function(_self2) {
      var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
      var uniqueId = 0;
      var plainTextGrammar = {};
      var _2 = {
        /**
         * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
         * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
         * additional languages or plugins yourself.
         *
         * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
         *
         * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.manual = true;
         * // add a new <script> to load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        manual: _self2.Prism && _self2.Prism.manual,
        /**
         * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
         * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
         * own worker, you don't want it to do this.
         *
         * By setting this value to `true`, Prism will not add its own listeners to the worker.
         *
         * You obviously have to change this value before Prism executes. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.disableWorkerMessageHandler = true;
         * // Load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        disableWorkerMessageHandler: _self2.Prism && _self2.Prism.disableWorkerMessageHandler,
        /**
         * A namespace for utility methods.
         *
         * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
         * change or disappear at any time.
         *
         * @namespace
         * @memberof Prism
         */
        util: {
          encode: function encode(tokens) {
            if (tokens instanceof Token) {
              return new Token(tokens.type, encode(tokens.content), tokens.alias);
            } else if (Array.isArray(tokens)) {
              return tokens.map(encode);
            } else {
              return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
            }
          },
          /**
           * Returns the name of the type of the given value.
           *
           * @param {any} o
           * @returns {string}
           * @example
           * type(null)      === 'Null'
           * type(undefined) === 'Undefined'
           * type(123)       === 'Number'
           * type('foo')     === 'String'
           * type(true)      === 'Boolean'
           * type([1, 2])    === 'Array'
           * type({})        === 'Object'
           * type(String)    === 'Function'
           * type(/abc+/)    === 'RegExp'
           */
          type: function(o2) {
            return Object.prototype.toString.call(o2).slice(8, -1);
          },
          /**
           * Returns a unique number for the given object. Later calls will still return the same number.
           *
           * @param {Object} obj
           * @returns {number}
           */
          objId: function(obj) {
            if (!obj["__id"]) {
              Object.defineProperty(obj, "__id", { value: ++uniqueId });
            }
            return obj["__id"];
          },
          /**
           * Creates a deep clone of the given object.
           *
           * The main intended use of this function is to clone language definitions.
           *
           * @param {T} o
           * @param {Record<number, any>} [visited]
           * @returns {T}
           * @template T
           */
          clone: function deepClone(o2, visited) {
            visited = visited || {};
            var clone;
            var id;
            switch (_2.util.type(o2)) {
              case "Object":
                id = _2.util.objId(o2);
                if (visited[id]) {
                  return visited[id];
                }
                clone = /** @type {Record<string, any>} */
                {};
                visited[id] = clone;
                for (var key in o2) {
                  if (o2.hasOwnProperty(key)) {
                    clone[key] = deepClone(o2[key], visited);
                  }
                }
                return (
                  /** @type {any} */
                  clone
                );
              case "Array":
                id = _2.util.objId(o2);
                if (visited[id]) {
                  return visited[id];
                }
                clone = [];
                visited[id] = clone;
                /** @type {Array} */
                /** @type {any} */
                o2.forEach(function(v2, i2) {
                  clone[i2] = deepClone(v2, visited);
                });
                return (
                  /** @type {any} */
                  clone
                );
              default:
                return o2;
            }
          },
          /**
           * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
           *
           * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
           *
           * @param {Element} element
           * @returns {string}
           */
          getLanguage: function(element) {
            while (element) {
              var m = lang.exec(element.className);
              if (m) {
                return m[1].toLowerCase();
              }
              element = element.parentElement;
            }
            return "none";
          },
          /**
           * Sets the Prism `language-xxxx` class of the given element.
           *
           * @param {Element} element
           * @param {string} language
           * @returns {void}
           */
          setLanguage: function(element, language) {
            element.className = element.className.replace(RegExp(lang, "gi"), "");
            element.classList.add("language-" + language);
          },
          /**
           * Returns the script element that is currently executing.
           *
           * This does __not__ work for line script element.
           *
           * @returns {HTMLScriptElement | null}
           */
          currentScript: function() {
            if (typeof document === "undefined") {
              return null;
            }
            if (document.currentScript && document.currentScript.tagName === "SCRIPT" && 1 < 2) {
              return (
                /** @type {any} */
                document.currentScript
              );
            }
            try {
              throw new Error();
            } catch (err) {
              var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
              if (src) {
                var scripts = document.getElementsByTagName("script");
                for (var i2 in scripts) {
                  if (scripts[i2].src == src) {
                    return scripts[i2];
                  }
                }
              }
              return null;
            }
          },
          /**
           * Returns whether a given class is active for `element`.
           *
           * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
           * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
           * given class is just the given class with a `no-` prefix.
           *
           * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
           * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
           * ancestors have the given class or the negated version of it, then the default activation will be returned.
           *
           * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
           * version of it, the class is considered active.
           *
           * @param {Element} element
           * @param {string} className
           * @param {boolean} [defaultActivation=false]
           * @returns {boolean}
           */
          isActive: function(element, className, defaultActivation) {
            var no = "no-" + className;
            while (element) {
              var classList = element.classList;
              if (classList.contains(className)) {
                return true;
              }
              if (classList.contains(no)) {
                return false;
              }
              element = element.parentElement;
            }
            return !!defaultActivation;
          }
        },
        /**
         * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
         *
         * @namespace
         * @memberof Prism
         * @public
         */
        languages: {
          /**
           * The grammar for plain, unformatted text.
           */
          plain: plainTextGrammar,
          plaintext: plainTextGrammar,
          text: plainTextGrammar,
          txt: plainTextGrammar,
          /**
           * Creates a deep copy of the language with the given id and appends the given tokens.
           *
           * If a token in `redef` also appears in the copied language, then the existing token in the copied language
           * will be overwritten at its original position.
           *
           * ## Best practices
           *
           * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
           * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
           * understand the language definition because, normally, the order of tokens matters in Prism grammars.
           *
           * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
           * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
           *
           * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
           * @param {Grammar} redef The new tokens to append.
           * @returns {Grammar} The new language created.
           * @public
           * @example
           * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
           *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
           *     // at its original position
           *     'comment': { ... },
           *     // CSS doesn't have a 'color' token, so this token will be appended
           *     'color': /\b(?:red|green|blue)\b/
           * });
           */
          extend: function(id, redef) {
            var lang2 = _2.util.clone(_2.languages[id]);
            for (var key in redef) {
              lang2[key] = redef[key];
            }
            return lang2;
          },
          /**
           * Inserts tokens _before_ another token in a language definition or any other grammar.
           *
           * ## Usage
           *
           * This helper method makes it easy to modify existing languages. For example, the CSS language definition
           * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
           * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
           * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
           * this:
           *
           * ```js
           * Prism.languages.markup.style = {
           *     // token
           * };
           * ```
           *
           * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
           * before existing tokens. For the CSS example above, you would use it like this:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'cdata', {
           *     'style': {
           *         // token
           *     }
           * });
           * ```
           *
           * ## Special cases
           *
           * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
           * will be ignored.
           *
           * This behavior can be used to insert tokens after `before`:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'comment', {
           *     'comment': Prism.languages.markup.comment,
           *     // tokens after 'comment'
           * });
           * ```
           *
           * ## Limitations
           *
           * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
           * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
           * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
           * deleting properties which is necessary to insert at arbitrary positions.
           *
           * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
           * Instead, it will create a new object and replace all references to the target object with the new one. This
           * can be done without temporarily deleting properties, so the iteration order is well-defined.
           *
           * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
           * you hold the target object in a variable, then the value of the variable will not change.
           *
           * ```js
           * var oldMarkup = Prism.languages.markup;
           * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
           *
           * assert(oldMarkup !== Prism.languages.markup);
           * assert(newMarkup === Prism.languages.markup);
           * ```
           *
           * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
           * object to be modified.
           * @param {string} before The key to insert before.
           * @param {Grammar} insert An object containing the key-value pairs to be inserted.
           * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
           * object to be modified.
           *
           * Defaults to `Prism.languages`.
           * @returns {Grammar} The new grammar object.
           * @public
           */
          insertBefore: function(inside, before, insert, root) {
            root = root || /** @type {any} */
            _2.languages;
            var grammar = root[inside];
            var ret = {};
            for (var token in grammar) {
              if (grammar.hasOwnProperty(token)) {
                if (token == before) {
                  for (var newToken in insert) {
                    if (insert.hasOwnProperty(newToken)) {
                      ret[newToken] = insert[newToken];
                    }
                  }
                }
                if (!insert.hasOwnProperty(token)) {
                  ret[token] = grammar[token];
                }
              }
            }
            var old = root[inside];
            root[inside] = ret;
            _2.languages.DFS(_2.languages, function(key, value) {
              if (value === old && key != inside) {
                this[key] = ret;
              }
            });
            return ret;
          },
          // Traverse a language definition with Depth First Search
          DFS: function DFS(o2, callback, type, visited) {
            visited = visited || {};
            var objId = _2.util.objId;
            for (var i2 in o2) {
              if (o2.hasOwnProperty(i2)) {
                callback.call(o2, i2, o2[i2], type || i2);
                var property = o2[i2];
                var propertyType = _2.util.type(property);
                if (propertyType === "Object" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, null, visited);
                } else if (propertyType === "Array" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, i2, visited);
                }
              }
            }
          }
        },
        plugins: {},
        /**
         * This is the most high-level function in Prism’s API.
         * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
         * each one of them.
         *
         * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
         *
         * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
         * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
         * @memberof Prism
         * @public
         */
        highlightAll: function(async, callback) {
          _2.highlightAllUnder(document, async, callback);
        },
        /**
         * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
         * {@link Prism.highlightElement} on each one of them.
         *
         * The following hooks will be run:
         * 1. `before-highlightall`
         * 2. `before-all-elements-highlight`
         * 3. All hooks of {@link Prism.highlightElement} for each element.
         *
         * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
         * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
         * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
         * @memberof Prism
         * @public
         */
        highlightAllUnder: function(container, async, callback) {
          var env = {
            callback,
            container,
            selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
          };
          _2.hooks.run("before-highlightall", env);
          env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));
          _2.hooks.run("before-all-elements-highlight", env);
          for (var i2 = 0, element; element = env.elements[i2++]; ) {
            _2.highlightElement(element, async === true, env.callback);
          }
        },
        /**
         * Highlights the code inside a single element.
         *
         * The following hooks will be run:
         * 1. `before-sanity-check`
         * 2. `before-highlight`
         * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
         * 4. `before-insert`
         * 5. `after-highlight`
         * 6. `complete`
         *
         * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
         * the element's language.
         *
         * @param {Element} element The element containing the code.
         * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
         * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
         * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
         * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
         *
         * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
         * asynchronous highlighting to work. You can build your own bundle on the
         * [Download page](https://prismjs.com/download.html).
         * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
         * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
         * @memberof Prism
         * @public
         */
        highlightElement: function(element, async, callback) {
          var language = _2.util.getLanguage(element);
          var grammar = _2.languages[language];
          _2.util.setLanguage(element, language);
          var parent = element.parentElement;
          if (parent && parent.nodeName.toLowerCase() === "pre") {
            _2.util.setLanguage(parent, language);
          }
          var code = element.textContent;
          var env = {
            element,
            language,
            grammar,
            code
          };
          function insertHighlightedCode(highlightedCode) {
            env.highlightedCode = highlightedCode;
            _2.hooks.run("before-insert", env);
            env.element.innerHTML = env.highlightedCode;
            _2.hooks.run("after-highlight", env);
            _2.hooks.run("complete", env);
            callback && callback.call(env.element);
          }
          _2.hooks.run("before-sanity-check", env);
          parent = env.element.parentElement;
          if (parent && parent.nodeName.toLowerCase() === "pre" && !parent.hasAttribute("tabindex")) {
            parent.setAttribute("tabindex", "0");
          }
          if (!env.code) {
            _2.hooks.run("complete", env);
            callback && callback.call(env.element);
            return;
          }
          _2.hooks.run("before-highlight", env);
          if (!env.grammar) {
            insertHighlightedCode(_2.util.encode(env.code));
            return;
          }
          if (async && _self2.Worker) {
            var worker = new Worker(_2.filename);
            worker.onmessage = function(evt) {
              insertHighlightedCode(evt.data);
            };
            worker.postMessage(JSON.stringify({
              language: env.language,
              code: env.code,
              immediateClose: true
            }));
          } else {
            insertHighlightedCode(_2.highlight(env.code, env.grammar, env.language));
          }
        },
        /**
         * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
         * and the language definitions to use, and returns a string with the HTML produced.
         *
         * The following hooks will be run:
         * 1. `before-tokenize`
         * 2. `after-tokenize`
         * 3. `wrap`: On each {@link Token}.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @param {string} language The name of the language definition passed to `grammar`.
         * @returns {string} The highlighted HTML.
         * @memberof Prism
         * @public
         * @example
         * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
         */
        highlight: function(text, grammar, language) {
          var env = {
            code: text,
            grammar,
            language
          };
          _2.hooks.run("before-tokenize", env);
          if (!env.grammar) {
            throw new Error('The language "' + env.language + '" has no grammar.');
          }
          env.tokens = _2.tokenize(env.code, env.grammar);
          _2.hooks.run("after-tokenize", env);
          return Token.stringify(_2.util.encode(env.tokens), env.language);
        },
        /**
         * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
         * and the language definitions to use, and returns an array with the tokenized code.
         *
         * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
         *
         * This method could be useful in other contexts as well, as a very crude parser.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @returns {TokenStream} An array of strings and tokens, a token stream.
         * @memberof Prism
         * @public
         * @example
         * let code = `var foo = 0;`;
         * let tokens = Prism.tokenize(code, Prism.languages.javascript);
         * tokens.forEach(token => {
         *     if (token instanceof Prism.Token && token.type === 'number') {
         *         console.log(`Found numeric literal: ${token.content}`);
         *     }
         * });
         */
        tokenize: function(text, grammar) {
          var rest = grammar.rest;
          if (rest) {
            for (var token in rest) {
              grammar[token] = rest[token];
            }
            delete grammar.rest;
          }
          var tokenList = new LinkedList();
          addAfter(tokenList, tokenList.head, text);
          matchGrammar(text, tokenList, grammar, tokenList.head, 0);
          return toArray(tokenList);
        },
        /**
         * @namespace
         * @memberof Prism
         * @public
         */
        hooks: {
          all: {},
          /**
           * Adds the given callback to the list of callbacks for the given hook.
           *
           * The callback will be invoked when the hook it is registered for is run.
           * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
           *
           * One callback function can be registered to multiple hooks and the same hook multiple times.
           *
           * @param {string} name The name of the hook.
           * @param {HookCallback} callback The callback function which is given environment variables.
           * @public
           */
          add: function(name, callback) {
            var hooks = _2.hooks.all;
            hooks[name] = hooks[name] || [];
            hooks[name].push(callback);
          },
          /**
           * Runs a hook invoking all registered callbacks with the given environment variables.
           *
           * Callbacks will be invoked synchronously and in the order in which they were registered.
           *
           * @param {string} name The name of the hook.
           * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
           * @public
           */
          run: function(name, env) {
            var callbacks = _2.hooks.all[name];
            if (!callbacks || !callbacks.length) {
              return;
            }
            for (var i2 = 0, callback; callback = callbacks[i2++]; ) {
              callback(env);
            }
          }
        },
        Token
      };
      _self2.Prism = _2;
      function Token(type, content, alias, matchedStr) {
        this.type = type;
        this.content = content;
        this.alias = alias;
        this.length = (matchedStr || "").length | 0;
      }
      Token.stringify = function stringify(o2, language) {
        if (typeof o2 == "string") {
          return o2;
        }
        if (Array.isArray(o2)) {
          var s2 = "";
          o2.forEach(function(e2) {
            s2 += stringify(e2, language);
          });
          return s2;
        }
        var env = {
          type: o2.type,
          content: stringify(o2.content, language),
          tag: "span",
          classes: ["token", o2.type],
          attributes: {},
          language
        };
        var aliases = o2.alias;
        if (aliases) {
          if (Array.isArray(aliases)) {
            Array.prototype.push.apply(env.classes, aliases);
          } else {
            env.classes.push(aliases);
          }
        }
        _2.hooks.run("wrap", env);
        var attributes = "";
        for (var name in env.attributes) {
          attributes += " " + name + '="' + (env.attributes[name] || "").replace(/"/g, "&quot;") + '"';
        }
        return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes + ">" + env.content + "</" + env.tag + ">";
      };
      function matchPattern(pattern, pos, text, lookbehind) {
        pattern.lastIndex = pos;
        var match = pattern.exec(text);
        if (match && lookbehind && match[1]) {
          var lookbehindLength = match[1].length;
          match.index += lookbehindLength;
          match[0] = match[0].slice(lookbehindLength);
        }
        return match;
      }
      function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
        for (var token in grammar) {
          if (!grammar.hasOwnProperty(token) || !grammar[token]) {
            continue;
          }
          var patterns = grammar[token];
          patterns = Array.isArray(patterns) ? patterns : [patterns];
          for (var j = 0; j < patterns.length; ++j) {
            if (rematch && rematch.cause == token + "," + j) {
              return;
            }
            var patternObj = patterns[j];
            var inside = patternObj.inside;
            var lookbehind = !!patternObj.lookbehind;
            var greedy = !!patternObj.greedy;
            var alias = patternObj.alias;
            if (greedy && !patternObj.pattern.global) {
              var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
              patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
            }
            var pattern = patternObj.pattern || patternObj;
            for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
              if (rematch && pos >= rematch.reach) {
                break;
              }
              var str = currentNode.value;
              if (tokenList.length > text.length) {
                return;
              }
              if (str instanceof Token) {
                continue;
              }
              var removeCount = 1;
              var match;
              if (greedy) {
                match = matchPattern(pattern, pos, text, lookbehind);
                if (!match || match.index >= text.length) {
                  break;
                }
                var from = match.index;
                var to = match.index + match[0].length;
                var p2 = pos;
                p2 += currentNode.value.length;
                while (from >= p2) {
                  currentNode = currentNode.next;
                  p2 += currentNode.value.length;
                }
                p2 -= currentNode.value.length;
                pos = p2;
                if (currentNode.value instanceof Token) {
                  continue;
                }
                for (var k = currentNode; k !== tokenList.tail && (p2 < to || typeof k.value === "string"); k = k.next) {
                  removeCount++;
                  p2 += k.value.length;
                }
                removeCount--;
                str = text.slice(pos, p2);
                match.index -= pos;
              } else {
                match = matchPattern(pattern, 0, str, lookbehind);
                if (!match) {
                  continue;
                }
              }
              var from = match.index;
              var matchStr = match[0];
              var before = str.slice(0, from);
              var after = str.slice(from + matchStr.length);
              var reach = pos + str.length;
              if (rematch && reach > rematch.reach) {
                rematch.reach = reach;
              }
              var removeFrom = currentNode.prev;
              if (before) {
                removeFrom = addAfter(tokenList, removeFrom, before);
                pos += before.length;
              }
              removeRange(tokenList, removeFrom, removeCount);
              var wrapped = new Token(token, inside ? _2.tokenize(matchStr, inside) : matchStr, alias, matchStr);
              currentNode = addAfter(tokenList, removeFrom, wrapped);
              if (after) {
                addAfter(tokenList, currentNode, after);
              }
              if (removeCount > 1) {
                var nestedRematch = {
                  cause: token + "," + j,
                  reach
                };
                matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);
                if (rematch && nestedRematch.reach > rematch.reach) {
                  rematch.reach = nestedRematch.reach;
                }
              }
            }
          }
        }
      }
      function LinkedList() {
        var head = { value: null, prev: null, next: null };
        var tail = { value: null, prev: head, next: null };
        head.next = tail;
        this.head = head;
        this.tail = tail;
        this.length = 0;
      }
      function addAfter(list, node, value) {
        var next = node.next;
        var newNode = { value, prev: node, next };
        node.next = newNode;
        next.prev = newNode;
        list.length++;
        return newNode;
      }
      function removeRange(list, node, count) {
        var next = node.next;
        for (var i2 = 0; i2 < count && next !== list.tail; i2++) {
          next = next.next;
        }
        node.next = next;
        next.prev = node;
        list.length -= i2;
      }
      function toArray(list) {
        var array = [];
        var node = list.head.next;
        while (node !== list.tail) {
          array.push(node.value);
          node = node.next;
        }
        return array;
      }
      if (!_self2.document) {
        if (!_self2.addEventListener) {
          return _2;
        }
        if (!_2.disableWorkerMessageHandler) {
          _self2.addEventListener("message", function(evt) {
            var message = JSON.parse(evt.data);
            var lang2 = message.language;
            var code = message.code;
            var immediateClose = message.immediateClose;
            _self2.postMessage(_2.highlight(code, _2.languages[lang2], lang2));
            if (immediateClose) {
              _self2.close();
            }
          }, false);
        }
        return _2;
      }
      var script = _2.util.currentScript();
      if (script) {
        _2.filename = script.src;
        if (script.hasAttribute("data-manual")) {
          _2.manual = true;
        }
      }
      function highlightAutomaticallyCallback() {
        if (!_2.manual) {
          _2.highlightAll();
        }
      }
      if (!_2.manual) {
        var readyState = document.readyState;
        if (readyState === "loading" || readyState === "interactive" && script && script.defer) {
          document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback);
        } else {
          if (window.requestAnimationFrame) {
            window.requestAnimationFrame(highlightAutomaticallyCallback);
          } else {
            window.setTimeout(highlightAutomaticallyCallback, 16);
          }
        }
      }
      return _2;
    })(_self);
    if (typeof module !== "undefined" && module.exports) {
      module.exports = Prism2;
    }
    if (typeof global !== "undefined") {
      global.Prism = Prism2;
    }
    Prism2.languages.markup = {
      "comment": {
        pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
        greedy: true
      },
      "prolog": {
        pattern: /<\?[\s\S]+?\?>/,
        greedy: true
      },
      "doctype": {
        // https://www.w3.org/TR/xml/#NT-doctypedecl
        pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
        greedy: true,
        inside: {
          "internal-subset": {
            pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
            lookbehind: true,
            greedy: true,
            inside: null
            // see below
          },
          "string": {
            pattern: /"[^"]*"|'[^']*'/,
            greedy: true
          },
          "punctuation": /^<!|>$|[[\]]/,
          "doctype-tag": /^DOCTYPE/i,
          "name": /[^\s<>'"]+/
        }
      },
      "cdata": {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        greedy: true
      },
      "tag": {
        pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
        greedy: true,
        inside: {
          "tag": {
            pattern: /^<\/?[^\s>\/]+/,
            inside: {
              "punctuation": /^<\/?/,
              "namespace": /^[^\s>\/:]+:/
            }
          },
          "special-attr": [],
          "attr-value": {
            pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
            inside: {
              "punctuation": [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                {
                  pattern: /^(\s*)["']|["']$/,
                  lookbehind: true
                }
              ]
            }
          },
          "punctuation": /\/?>/,
          "attr-name": {
            pattern: /[^\s>\/]+/,
            inside: {
              "namespace": /^[^\s>\/:]+:/
            }
          }
        }
      },
      "entity": [
        {
          pattern: /&[\da-z]{1,8};/i,
          alias: "named-entity"
        },
        /&#x?[\da-f]{1,8};/i
      ]
    };
    Prism2.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism2.languages.markup["entity"];
    Prism2.languages.markup["doctype"].inside["internal-subset"].inside = Prism2.languages.markup;
    Prism2.hooks.add("wrap", function(env) {
      if (env.type === "entity") {
        env.attributes["title"] = env.content.replace(/&amp;/, "&");
      }
    });
    Object.defineProperty(Prism2.languages.markup.tag, "addInlined", {
      /**
       * Adds an inlined language to markup.
       *
       * An example of an inlined language is CSS with `<style>` tags.
       *
       * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addInlined('style', 'css');
       */
      value: function addInlined2(tagName, lang) {
        var includedCdataInside = {};
        includedCdataInside["language-" + lang] = {
          pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
          lookbehind: true,
          inside: Prism2.languages[lang]
        };
        includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
        var inside = {
          "included-cdata": {
            pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
            inside: includedCdataInside
          }
        };
        inside["language-" + lang] = {
          pattern: /[\s\S]+/,
          inside: Prism2.languages[lang]
        };
        var def = {};
        def[tagName] = {
          pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
            return tagName;
          }), "i"),
          lookbehind: true,
          greedy: true,
          inside
        };
        Prism2.languages.insertBefore("markup", "cdata", def);
      }
    });
    Object.defineProperty(Prism2.languages.markup.tag, "addAttribute", {
      /**
       * Adds an pattern to highlight languages embedded in HTML attributes.
       *
       * An example of an inlined language is CSS with `style` attributes.
       *
       * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addAttribute('style', 'css');
       */
      value: function(attrName, lang) {
        Prism2.languages.markup.tag.inside["special-attr"].push({
          pattern: RegExp(
            /(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
            "i"
          ),
          lookbehind: true,
          inside: {
            "attr-name": /^[^\s=]+/,
            "attr-value": {
              pattern: /=[\s\S]+/,
              inside: {
                "value": {
                  pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                  lookbehind: true,
                  alias: [lang, "language-" + lang],
                  inside: Prism2.languages[lang]
                },
                "punctuation": [
                  {
                    pattern: /^=/,
                    alias: "attr-equals"
                  },
                  /"|'/
                ]
              }
            }
          }
        });
      }
    });
    Prism2.languages.html = Prism2.languages.markup;
    Prism2.languages.mathml = Prism2.languages.markup;
    Prism2.languages.svg = Prism2.languages.markup;
    Prism2.languages.xml = Prism2.languages.extend("markup", {});
    Prism2.languages.ssml = Prism2.languages.xml;
    Prism2.languages.atom = Prism2.languages.xml;
    Prism2.languages.rss = Prism2.languages.xml;
    (function(Prism3) {
      var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
      Prism3.languages.css = {
        "comment": /\/\*[\s\S]*?\*\//,
        "atrule": {
          pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string.source + ")*?" + /(?:;|(?=\s*\{))/.source),
          inside: {
            "rule": /^@[\w-]+/,
            "selector-function-argument": {
              pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
              lookbehind: true,
              alias: "selector"
            },
            "keyword": {
              pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
              lookbehind: true
            }
            // See rest below
          }
        },
        "url": {
          // https://drafts.csswg.org/css-values-3/#urls
          pattern: RegExp("\\burl\\((?:" + string.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
          greedy: true,
          inside: {
            "function": /^url/i,
            "punctuation": /^\(|\)$/,
            "string": {
              pattern: RegExp("^" + string.source + "$"),
              alias: "url"
            }
          }
        },
        "selector": {
          pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string.source + ")*(?=\\s*\\{)"),
          lookbehind: true
        },
        "string": {
          pattern: string,
          greedy: true
        },
        "property": {
          pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
          lookbehind: true
        },
        "important": /!important\b/i,
        "function": {
          pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
          lookbehind: true
        },
        "punctuation": /[(){};:,]/
      };
      Prism3.languages.css["atrule"].inside.rest = Prism3.languages.css;
      var markup = Prism3.languages.markup;
      if (markup) {
        markup.tag.addInlined("style", "css");
        markup.tag.addAttribute("style", "css");
      }
    })(Prism2);
    Prism2.languages.clike = {
      "comment": [
        {
          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
          lookbehind: true,
          greedy: true
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: true,
          greedy: true
        }
      ],
      "string": {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: true
      },
      "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
        lookbehind: true,
        inside: {
          "punctuation": /[.\\]/
        }
      },
      "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
      "boolean": /\b(?:false|true)\b/,
      "function": /\b\w+(?=\()/,
      "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
      "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
      "punctuation": /[{}[\];(),.:]/
    };
    Prism2.languages.javascript = Prism2.languages.extend("clike", {
      "class-name": [
        Prism2.languages.clike["class-name"],
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
          lookbehind: true
        }
      ],
      "keyword": [
        {
          pattern: /((?:^|\})\s*)catch\b/,
          lookbehind: true
        },
        {
          pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
          lookbehind: true
        }
      ],
      // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
      "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
      "number": {
        pattern: RegExp(
          /(^|[^\w$])/.source + "(?:" + // constant
          (/NaN|Infinity/.source + "|" + // binary integer
          /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
          /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
          /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
          /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
          /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
        ),
        lookbehind: true
      },
      "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
    });
    Prism2.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
    Prism2.languages.insertBefore("javascript", "keyword", {
      "regex": {
        pattern: RegExp(
          // lookbehind
          // eslint-disable-next-line regexp/no-dupe-characters-character-class
          /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
          // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
          // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
          // with the only syntax, so we have to define 2 different regex patterns.
          /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
          /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
          /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
        ),
        lookbehind: true,
        greedy: true,
        inside: {
          "regex-source": {
            pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
            lookbehind: true,
            alias: "language-regex",
            inside: Prism2.languages.regex
          },
          "regex-delimiter": /^\/|\/$/,
          "regex-flags": /^[a-z]+$/
        }
      },
      // This must be declared before keyword because we use "function" inside the look-forward
      "function-variable": {
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
        alias: "function"
      },
      "parameter": [
        {
          pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
          lookbehind: true,
          inside: Prism2.languages.javascript
        },
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
          lookbehind: true,
          inside: Prism2.languages.javascript
        },
        {
          pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
          lookbehind: true,
          inside: Prism2.languages.javascript
        },
        {
          pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
          lookbehind: true,
          inside: Prism2.languages.javascript
        }
      ],
      "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
    });
    Prism2.languages.insertBefore("javascript", "string", {
      "hashbang": {
        pattern: /^#!.*/,
        greedy: true,
        alias: "comment"
      },
      "template-string": {
        pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
        greedy: true,
        inside: {
          "template-punctuation": {
            pattern: /^`|`$/,
            alias: "string"
          },
          "interpolation": {
            pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
            lookbehind: true,
            inside: {
              "interpolation-punctuation": {
                pattern: /^\$\{|\}$/,
                alias: "punctuation"
              },
              rest: Prism2.languages.javascript
            }
          },
          "string": /[\s\S]+/
        }
      },
      "string-property": {
        pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
        lookbehind: true,
        greedy: true,
        alias: "property"
      }
    });
    Prism2.languages.insertBefore("javascript", "operator", {
      "literal-property": {
        pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
        lookbehind: true,
        alias: "property"
      }
    });
    if (Prism2.languages.markup) {
      Prism2.languages.markup.tag.addInlined("script", "javascript");
      Prism2.languages.markup.tag.addAttribute(
        /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
        "javascript"
      );
    }
    Prism2.languages.js = Prism2.languages.javascript;
    (function() {
      if (typeof Prism2 === "undefined" || typeof document === "undefined") {
        return;
      }
      if (!Element.prototype.matches) {
        Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
      }
      var LOADING_MESSAGE = "Loading\u2026";
      var FAILURE_MESSAGE = function(status, message) {
        return "\u2716 Error " + status + " while fetching file: " + message;
      };
      var FAILURE_EMPTY_MESSAGE = "\u2716 Error: File does not exist or is empty";
      var EXTENSIONS = {
        "js": "javascript",
        "py": "python",
        "rb": "ruby",
        "ps1": "powershell",
        "psm1": "powershell",
        "sh": "bash",
        "bat": "batch",
        "h": "c",
        "tex": "latex"
      };
      var STATUS_ATTR = "data-src-status";
      var STATUS_LOADING = "loading";
      var STATUS_LOADED = "loaded";
      var STATUS_FAILED = "failed";
      var SELECTOR = "pre[data-src]:not([" + STATUS_ATTR + '="' + STATUS_LOADED + '"]):not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';
      function loadFile(src, success, error) {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", src, true);
        xhr.onreadystatechange = function() {
          if (xhr.readyState == 4) {
            if (xhr.status < 400 && xhr.responseText) {
              success(xhr.responseText);
            } else {
              if (xhr.status >= 400) {
                error(FAILURE_MESSAGE(xhr.status, xhr.statusText));
              } else {
                error(FAILURE_EMPTY_MESSAGE);
              }
            }
          }
        };
        xhr.send(null);
      }
      function parseRange(range) {
        var m = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(range || "");
        if (m) {
          var start = Number(m[1]);
          var comma = m[2];
          var end = m[3];
          if (!comma) {
            return [start, start];
          }
          if (!end) {
            return [start, void 0];
          }
          return [start, Number(end)];
        }
        return void 0;
      }
      Prism2.hooks.add("before-highlightall", function(env) {
        env.selector += ", " + SELECTOR;
      });
      Prism2.hooks.add("before-sanity-check", function(env) {
        var pre = (
          /** @type {HTMLPreElement} */
          env.element
        );
        if (pre.matches(SELECTOR)) {
          env.code = "";
          pre.setAttribute(STATUS_ATTR, STATUS_LOADING);
          var code = pre.appendChild(document.createElement("CODE"));
          code.textContent = LOADING_MESSAGE;
          var src = pre.getAttribute("data-src");
          var language = env.language;
          if (language === "none") {
            var extension = (/\.(\w+)$/.exec(src) || [, "none"])[1];
            language = EXTENSIONS[extension] || extension;
          }
          Prism2.util.setLanguage(code, language);
          Prism2.util.setLanguage(pre, language);
          var autoloader = Prism2.plugins.autoloader;
          if (autoloader) {
            autoloader.loadLanguages(language);
          }
          loadFile(
            src,
            function(text) {
              pre.setAttribute(STATUS_ATTR, STATUS_LOADED);
              var range = parseRange(pre.getAttribute("data-range"));
              if (range) {
                var lines = text.split(/\r\n?|\n/g);
                var start = range[0];
                var end = range[1] == null ? lines.length : range[1];
                if (start < 0) {
                  start += lines.length;
                }
                start = Math.max(0, Math.min(start - 1, lines.length));
                if (end < 0) {
                  end += lines.length;
                }
                end = Math.max(0, Math.min(end, lines.length));
                text = lines.slice(start, end).join("\n");
                if (!pre.hasAttribute("data-start")) {
                  pre.setAttribute("data-start", String(start + 1));
                }
              }
              code.textContent = text;
              Prism2.highlightElement(code);
            },
            function(error) {
              pre.setAttribute(STATUS_ATTR, STATUS_FAILED);
              code.textContent = error;
            }
          );
        }
      });
      Prism2.plugins.fileHighlight = {
        /**
         * Executes the File Highlight plugin for all matching `pre` elements under the given container.
         *
         * Note: Elements which are already loaded or currently loading will not be touched by this method.
         *
         * @param {ParentNode} [container=document]
         */
        highlight: function highlight(container) {
          var elements = (container || document).querySelectorAll(SELECTOR);
          for (var i2 = 0, element; element = elements[i2++]; ) {
            Prism2.highlightElement(element);
          }
        }
      };
      var logged = false;
      Prism2.fileHighlight = function() {
        if (!logged) {
          console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.");
          logged = true;
        }
        Prism2.plugins.fileHighlight.highlight.apply(this, arguments);
      };
    })();
  }
});

// node_modules/@lexical/rich-text/LexicalRichText.dev.mjs
var LexicalRichText_dev_exports = {};
__export(LexicalRichText_dev_exports, {
  $createHeadingNode: () => $createHeadingNode,
  $createQuoteNode: () => $createQuoteNode,
  $isHeadingNode: () => $isHeadingNode,
  $isQuoteNode: () => $isQuoteNode,
  DRAG_DROP_PASTE: () => DRAG_DROP_PASTE,
  HeadingNode: () => HeadingNode,
  QuoteNode: () => QuoteNode,
  RichTextExtension: () => RichTextExtension,
  eventFiles: () => eventFiles,
  registerRichText: () => registerRichText
});

// node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs
var LexicalClipboard_dev_exports = {};
__export(LexicalClipboard_dev_exports, {
  $generateJSONFromSelectedNodes: () => $generateJSONFromSelectedNodes,
  $generateNodesFromSerializedNodes: () => $generateNodesFromSerializedNodes,
  $getClipboardDataFromSelection: () => $getClipboardDataFromSelection,
  $getHtmlContent: () => $getHtmlContent,
  $getLexicalContent: () => $getLexicalContent,
  $insertDataTransferForPlainText: () => $insertDataTransferForPlainText,
  $insertDataTransferForRichText: () => $insertDataTransferForRichText,
  $insertGeneratedNodes: () => $insertGeneratedNodes,
  copyToClipboard: () => copyToClipboard,
  setLexicalClipboardDataTransfer: () => setLexicalClipboardDataTransfer
});

// node_modules/@lexical/html/LexicalHtml.dev.mjs
var LexicalHtml_dev_exports = {};
__export(LexicalHtml_dev_exports, {
  $generateHtmlFromNodes: () => $generateHtmlFromNodes,
  $generateNodesFromDOM: () => $generateNodesFromDOM
});

// node_modules/@lexical/selection/LexicalSelection.dev.mjs
var LexicalSelection_dev_exports = {};
__export(LexicalSelection_dev_exports, {
  $addNodeStyle: () => $addNodeStyle,
  $cloneWithProperties: () => $cloneWithProperties2,
  $copyBlockFormatIndent: () => $copyBlockFormatIndent,
  $ensureForwardRangeSelection: () => $ensureForwardRangeSelection,
  $forEachSelectedTextNode: () => $forEachSelectedTextNode,
  $getComputedStyleForElement: () => $getComputedStyleForElement,
  $getComputedStyleForParent: () => $getComputedStyleForParent,
  $getSelectionStyleValueForProperty: () => $getSelectionStyleValueForProperty,
  $isAtNodeEnd: () => $isAtNodeEnd,
  $isParentElementRTL: () => $isParentElementRTL,
  $isParentRTL: () => $isParentRTL,
  $moveCaretSelection: () => $moveCaretSelection,
  $moveCharacter: () => $moveCharacter,
  $patchStyleText: () => $patchStyleText,
  $selectAll: () => $selectAll2,
  $setBlocksType: () => $setBlocksType,
  $shouldOverrideDefaultCharacterSelection: () => $shouldOverrideDefaultCharacterSelection,
  $sliceSelectedTextNodeContent: () => $sliceSelectedTextNodeContent,
  $trimTextContentFromAnchor: () => $trimTextContentFromAnchor,
  $wrapNodes: () => $wrapNodes,
  createDOMRange: () => createDOMRange,
  createRectsFromDOMRange: () => createRectsFromDOMRange,
  getCSSFromStyleObject: () => getCSSFromStyleObject,
  getStyleObjectFromCSS: () => getStyleObjectFromCSS,
  trimTextContentFromAnchor: () => trimTextContentFromAnchor
});

// node_modules/lexical/Lexical.dev.mjs
var Lexical_dev_exports = {};
__export(Lexical_dev_exports, {
  $addUpdateTag: () => $addUpdateTag,
  $applyNodeReplacement: () => $applyNodeReplacement,
  $caretFromPoint: () => $caretFromPoint,
  $caretRangeFromSelection: () => $caretRangeFromSelection,
  $cloneWithProperties: () => $cloneWithProperties,
  $cloneWithPropertiesEphemeral: () => $cloneWithPropertiesEphemeral,
  $comparePointCaretNext: () => $comparePointCaretNext,
  $copyNode: () => $copyNode,
  $create: () => $create,
  $createLineBreakNode: () => $createLineBreakNode,
  $createNodeSelection: () => $createNodeSelection,
  $createParagraphNode: () => $createParagraphNode,
  $createPoint: () => $createPoint,
  $createRangeSelection: () => $createRangeSelection,
  $createRangeSelectionFromDom: () => $createRangeSelectionFromDom,
  $createTabNode: () => $createTabNode,
  $createTextNode: () => $createTextNode,
  $extendCaretToRange: () => $extendCaretToRange,
  $findMatchingParent: () => $findMatchingParent,
  $getAdjacentChildCaret: () => $getAdjacentChildCaret,
  $getAdjacentNode: () => $getAdjacentNode,
  $getAdjacentSiblingOrParentSiblingCaret: () => $getAdjacentSiblingOrParentSiblingCaret,
  $getCaretInDirection: () => $getCaretInDirection,
  $getCaretRange: () => $getCaretRange,
  $getCaretRangeInDirection: () => $getCaretRangeInDirection,
  $getCharacterOffsets: () => $getCharacterOffsets,
  $getChildCaret: () => $getChildCaret,
  $getChildCaretAtIndex: () => $getChildCaretAtIndex,
  $getChildCaretOrSelf: () => $getChildCaretOrSelf,
  $getCollapsedCaretRange: () => $getCollapsedCaretRange,
  $getCommonAncestor: () => $getCommonAncestor,
  $getCommonAncestorResultBranchOrder: () => $getCommonAncestorResultBranchOrder,
  $getEditor: () => $getEditor,
  $getNearestNodeFromDOMNode: () => $getNearestNodeFromDOMNode,
  $getNearestRootOrShadowRoot: () => $getNearestRootOrShadowRoot,
  $getNodeByKey: () => $getNodeByKey,
  $getNodeByKeyOrThrow: () => $getNodeByKeyOrThrow,
  $getNodeFromDOMNode: () => $getNodeFromDOMNode,
  $getPreviousSelection: () => $getPreviousSelection,
  $getRoot: () => $getRoot,
  $getSelection: () => $getSelection,
  $getSiblingCaret: () => $getSiblingCaret,
  $getState: () => $getState,
  $getStateChange: () => $getStateChange,
  $getTextContent: () => $getTextContent,
  $getTextNodeOffset: () => $getTextNodeOffset,
  $getTextPointCaret: () => $getTextPointCaret,
  $getTextPointCaretSlice: () => $getTextPointCaretSlice,
  $getWritableNodeState: () => $getWritableNodeState,
  $hasAncestor: () => $hasAncestor,
  $hasUpdateTag: () => $hasUpdateTag,
  $insertNodes: () => $insertNodes,
  $isBlockElementNode: () => $isBlockElementNode,
  $isChildCaret: () => $isChildCaret,
  $isDecoratorNode: () => $isDecoratorNode,
  $isEditorState: () => $isEditorState,
  $isElementNode: () => $isElementNode,
  $isExtendableTextPointCaret: () => $isExtendableTextPointCaret,
  $isInlineElementOrDecoratorNode: () => $isInlineElementOrDecoratorNode,
  $isLeafNode: () => $isLeafNode,
  $isLineBreakNode: () => $isLineBreakNode,
  $isNodeCaret: () => $isNodeCaret,
  $isNodeSelection: () => $isNodeSelection,
  $isParagraphNode: () => $isParagraphNode,
  $isRangeSelection: () => $isRangeSelection,
  $isRootNode: () => $isRootNode,
  $isRootOrShadowRoot: () => $isRootOrShadowRoot,
  $isSiblingCaret: () => $isSiblingCaret,
  $isTabNode: () => $isTabNode,
  $isTextNode: () => $isTextNode,
  $isTextPointCaret: () => $isTextPointCaret,
  $isTextPointCaretSlice: () => $isTextPointCaretSlice,
  $isTokenOrSegmented: () => $isTokenOrSegmented,
  $isTokenOrTab: () => $isTokenOrTab,
  $nodesOfType: () => $nodesOfType,
  $normalizeCaret: () => $normalizeCaret,
  $normalizeSelection__EXPERIMENTAL: () => $normalizeSelection,
  $onUpdate: () => $onUpdate,
  $parseSerializedNode: () => $parseSerializedNode,
  $removeTextFromCaretRange: () => $removeTextFromCaretRange,
  $rewindSiblingCaret: () => $rewindSiblingCaret,
  $selectAll: () => $selectAll,
  $setCompositionKey: () => $setCompositionKey,
  $setPointFromCaret: () => $setPointFromCaret,
  $setSelection: () => $setSelection,
  $setSelectionFromCaretRange: () => $setSelectionFromCaretRange,
  $setState: () => $setState,
  $splitAtPointCaretNext: () => $splitAtPointCaretNext,
  $splitNode: () => $splitNode,
  $updateRangeSelectionFromCaretRange: () => $updateRangeSelectionFromCaretRange,
  ArtificialNode__DO_NOT_USE: () => ArtificialNode__DO_NOT_USE,
  BEFORE_INPUT_COMMAND: () => BEFORE_INPUT_COMMAND,
  BLUR_COMMAND: () => BLUR_COMMAND,
  CAN_REDO_COMMAND: () => CAN_REDO_COMMAND,
  CAN_UNDO_COMMAND: () => CAN_UNDO_COMMAND,
  CLEAR_EDITOR_COMMAND: () => CLEAR_EDITOR_COMMAND,
  CLEAR_HISTORY_COMMAND: () => CLEAR_HISTORY_COMMAND,
  CLICK_COMMAND: () => CLICK_COMMAND,
  COLLABORATION_TAG: () => COLLABORATION_TAG,
  COMMAND_PRIORITY_CRITICAL: () => COMMAND_PRIORITY_CRITICAL,
  COMMAND_PRIORITY_EDITOR: () => COMMAND_PRIORITY_EDITOR,
  COMMAND_PRIORITY_HIGH: () => COMMAND_PRIORITY_HIGH,
  COMMAND_PRIORITY_LOW: () => COMMAND_PRIORITY_LOW,
  COMMAND_PRIORITY_NORMAL: () => COMMAND_PRIORITY_NORMAL,
  COMPOSITION_END_COMMAND: () => COMPOSITION_END_COMMAND,
  COMPOSITION_START_COMMAND: () => COMPOSITION_START_COMMAND,
  CONTROLLED_TEXT_INSERTION_COMMAND: () => CONTROLLED_TEXT_INSERTION_COMMAND,
  COPY_COMMAND: () => COPY_COMMAND,
  CUT_COMMAND: () => CUT_COMMAND,
  DELETE_CHARACTER_COMMAND: () => DELETE_CHARACTER_COMMAND,
  DELETE_LINE_COMMAND: () => DELETE_LINE_COMMAND,
  DELETE_WORD_COMMAND: () => DELETE_WORD_COMMAND,
  DRAGEND_COMMAND: () => DRAGEND_COMMAND,
  DRAGOVER_COMMAND: () => DRAGOVER_COMMAND,
  DRAGSTART_COMMAND: () => DRAGSTART_COMMAND,
  DROP_COMMAND: () => DROP_COMMAND,
  DecoratorNode: () => DecoratorNode,
  ElementNode: () => ElementNode,
  FOCUS_COMMAND: () => FOCUS_COMMAND,
  FORMAT_ELEMENT_COMMAND: () => FORMAT_ELEMENT_COMMAND,
  FORMAT_TEXT_COMMAND: () => FORMAT_TEXT_COMMAND,
  HISTORIC_TAG: () => HISTORIC_TAG,
  HISTORY_MERGE_TAG: () => HISTORY_MERGE_TAG,
  HISTORY_PUSH_TAG: () => HISTORY_PUSH_TAG,
  INDENT_CONTENT_COMMAND: () => INDENT_CONTENT_COMMAND,
  INPUT_COMMAND: () => INPUT_COMMAND,
  INSERT_LINE_BREAK_COMMAND: () => INSERT_LINE_BREAK_COMMAND,
  INSERT_PARAGRAPH_COMMAND: () => INSERT_PARAGRAPH_COMMAND,
  INSERT_TAB_COMMAND: () => INSERT_TAB_COMMAND,
  INTERNAL_$isBlock: () => INTERNAL_$isBlock,
  IS_ALL_FORMATTING: () => IS_ALL_FORMATTING,
  IS_BOLD: () => IS_BOLD,
  IS_CODE: () => IS_CODE,
  IS_HIGHLIGHT: () => IS_HIGHLIGHT,
  IS_ITALIC: () => IS_ITALIC,
  IS_STRIKETHROUGH: () => IS_STRIKETHROUGH,
  IS_SUBSCRIPT: () => IS_SUBSCRIPT,
  IS_SUPERSCRIPT: () => IS_SUPERSCRIPT,
  IS_UNDERLINE: () => IS_UNDERLINE,
  KEY_ARROW_DOWN_COMMAND: () => KEY_ARROW_DOWN_COMMAND,
  KEY_ARROW_LEFT_COMMAND: () => KEY_ARROW_LEFT_COMMAND,
  KEY_ARROW_RIGHT_COMMAND: () => KEY_ARROW_RIGHT_COMMAND,
  KEY_ARROW_UP_COMMAND: () => KEY_ARROW_UP_COMMAND,
  KEY_BACKSPACE_COMMAND: () => KEY_BACKSPACE_COMMAND,
  KEY_DELETE_COMMAND: () => KEY_DELETE_COMMAND,
  KEY_DOWN_COMMAND: () => KEY_DOWN_COMMAND,
  KEY_ENTER_COMMAND: () => KEY_ENTER_COMMAND,
  KEY_ESCAPE_COMMAND: () => KEY_ESCAPE_COMMAND,
  KEY_MODIFIER_COMMAND: () => KEY_MODIFIER_COMMAND,
  KEY_SPACE_COMMAND: () => KEY_SPACE_COMMAND,
  KEY_TAB_COMMAND: () => KEY_TAB_COMMAND,
  LineBreakNode: () => LineBreakNode,
  MOVE_TO_END: () => MOVE_TO_END,
  MOVE_TO_START: () => MOVE_TO_START,
  NODE_STATE_KEY: () => NODE_STATE_KEY,
  OUTDENT_CONTENT_COMMAND: () => OUTDENT_CONTENT_COMMAND,
  PASTE_COMMAND: () => PASTE_COMMAND,
  PASTE_TAG: () => PASTE_TAG,
  ParagraphNode: () => ParagraphNode,
  REDO_COMMAND: () => REDO_COMMAND,
  REMOVE_TEXT_COMMAND: () => REMOVE_TEXT_COMMAND,
  RootNode: () => RootNode,
  SELECTION_CHANGE_COMMAND: () => SELECTION_CHANGE_COMMAND,
  SELECTION_INSERT_CLIPBOARD_NODES_COMMAND: () => SELECTION_INSERT_CLIPBOARD_NODES_COMMAND,
  SELECT_ALL_COMMAND: () => SELECT_ALL_COMMAND,
  SKIP_COLLAB_TAG: () => SKIP_COLLAB_TAG,
  SKIP_DOM_SELECTION_TAG: () => SKIP_DOM_SELECTION_TAG,
  SKIP_SCROLL_INTO_VIEW_TAG: () => SKIP_SCROLL_INTO_VIEW_TAG,
  SKIP_SELECTION_FOCUS_TAG: () => SKIP_SELECTION_FOCUS_TAG,
  TEXT_TYPE_TO_FORMAT: () => TEXT_TYPE_TO_FORMAT,
  TabNode: () => TabNode,
  TextNode: () => TextNode,
  UNDO_COMMAND: () => UNDO_COMMAND,
  buildImportMap: () => buildImportMap,
  configExtension: () => configExtension,
  createCommand: () => createCommand,
  createEditor: () => createEditor,
  createSharedNodeState: () => createSharedNodeState,
  createState: () => createState,
  declarePeerDependency: () => declarePeerDependency,
  defineExtension: () => defineExtension,
  flipDirection: () => flipDirection,
  getDOMOwnerDocument: () => getDOMOwnerDocument,
  getDOMSelection: () => getDOMSelection,
  getDOMSelectionFromTarget: () => getDOMSelectionFromTarget,
  getDOMTextNode: () => getDOMTextNode,
  getEditorPropertyFromDOMNode: () => getEditorPropertyFromDOMNode,
  getNearestEditorFromDOMNode: () => getNearestEditorFromDOMNode,
  getRegisteredNode: () => getRegisteredNode,
  getRegisteredNodeOrThrow: () => getRegisteredNodeOrThrow,
  getStaticNodeConfig: () => getStaticNodeConfig,
  getTextDirection: () => getTextDirection,
  getTransformSetFromKlass: () => getTransformSetFromKlass,
  isBlockDomNode: () => isBlockDomNode,
  isCurrentlyReadOnlyMode: () => isCurrentlyReadOnlyMode,
  isDOMDocumentNode: () => isDOMDocumentNode,
  isDOMNode: () => isDOMNode,
  isDOMTextNode: () => isDOMTextNode,
  isDOMUnmanaged: () => isDOMUnmanaged,
  isDocumentFragment: () => isDocumentFragment,
  isExactShortcutMatch: () => isExactShortcutMatch,
  isHTMLAnchorElement: () => isHTMLAnchorElement,
  isHTMLElement: () => isHTMLElement,
  isInlineDomNode: () => isInlineDomNode,
  isLexicalEditor: () => isLexicalEditor,
  isModifierMatch: () => isModifierMatch,
  isSelectionCapturedInDecoratorInput: () => isSelectionCapturedInDecoratorInput,
  isSelectionWithinEditor: () => isSelectionWithinEditor,
  makeStepwiseIterator: () => makeStepwiseIterator,
  removeFromParent: () => removeFromParent,
  resetRandomKey: () => resetRandomKey,
  safeCast: () => safeCast,
  setDOMUnmanaged: () => setDOMUnmanaged,
  setNodeIndentFromDOM: () => setNodeIndentFromDOM,
  shallowMergeConfig: () => shallowMergeConfig
});
function formatDevErrorMessage(message) {
  throw new Error(message);
}
var CAN_USE_DOM = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
var documentMode = CAN_USE_DOM && "documentMode" in document ? document.documentMode : null;
var IS_APPLE = CAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
var IS_FIREFOX = CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
var CAN_USE_BEFORE_INPUT = CAN_USE_DOM && "InputEvent" in window && !documentMode ? "getTargetRanges" in new window.InputEvent("input") : false;
var IS_SAFARI = CAN_USE_DOM && /Version\/[\d.]+.*Safari/.test(navigator.userAgent);
var IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
var IS_ANDROID = CAN_USE_DOM && /Android/.test(navigator.userAgent);
var IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);
var IS_ANDROID_CHROME = CAN_USE_DOM && IS_ANDROID && IS_CHROME;
var IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && IS_APPLE && !IS_CHROME;
function normalizeClassNames(...classNames) {
  const rval = [];
  for (const className of classNames) {
    if (className && typeof className === "string") {
      for (const [s2] of className.matchAll(/\S+/g)) {
        rval.push(s2);
      }
    }
  }
  return rval;
}
var DOM_ELEMENT_TYPE = 1;
var DOM_TEXT_TYPE = 3;
var DOM_DOCUMENT_TYPE = 9;
var DOM_DOCUMENT_FRAGMENT_TYPE = 11;
var NO_DIRTY_NODES = 0;
var HAS_DIRTY_NODES = 1;
var FULL_RECONCILE = 2;
var IS_NORMAL = 0;
var IS_TOKEN = 1;
var IS_SEGMENTED = 2;
var IS_BOLD = 1;
var IS_ITALIC = 1 << 1;
var IS_STRIKETHROUGH = 1 << 2;
var IS_UNDERLINE = 1 << 3;
var IS_CODE = 1 << 4;
var IS_SUBSCRIPT = 1 << 5;
var IS_SUPERSCRIPT = 1 << 6;
var IS_HIGHLIGHT = 1 << 7;
var IS_LOWERCASE = 1 << 8;
var IS_UPPERCASE = 1 << 9;
var IS_CAPITALIZE = 1 << 10;
var IS_ALL_FORMATTING = IS_BOLD | IS_ITALIC | IS_STRIKETHROUGH | IS_UNDERLINE | IS_CODE | IS_SUBSCRIPT | IS_SUPERSCRIPT | IS_HIGHLIGHT | IS_LOWERCASE | IS_UPPERCASE | IS_CAPITALIZE;
var IS_DIRECTIONLESS = 1;
var IS_UNMERGEABLE = 1 << 1;
var IS_ALIGN_LEFT = 1;
var IS_ALIGN_CENTER = 2;
var IS_ALIGN_RIGHT = 3;
var IS_ALIGN_JUSTIFY = 4;
var IS_ALIGN_START = 5;
var IS_ALIGN_END = 6;
var NON_BREAKING_SPACE = "\xA0";
var ZERO_WIDTH_SPACE = "\u200B";
var COMPOSITION_SUFFIX = IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT ? NON_BREAKING_SPACE : ZERO_WIDTH_SPACE;
var DOUBLE_LINE_BREAK = "\n\n";
var COMPOSITION_START_CHAR = IS_FIREFOX ? NON_BREAKING_SPACE : COMPOSITION_SUFFIX;
var RTL = "\u0591-\u07FF\uFB1D-\uFDFD\uFE70-\uFEFC";
var LTR = "A-Za-z\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u0300-\u0590\u0800-\u1FFF\u200E\u2C00-\uFB1C\uFE00-\uFE6F\uFEFD-\uFFFF";
var RTL_REGEX = new RegExp("^[^" + LTR + "]*[" + RTL + "]");
var LTR_REGEX = new RegExp("^[^" + RTL + "]*[" + LTR + "]");
var TEXT_TYPE_TO_FORMAT = {
  bold: IS_BOLD,
  capitalize: IS_CAPITALIZE,
  code: IS_CODE,
  highlight: IS_HIGHLIGHT,
  italic: IS_ITALIC,
  lowercase: IS_LOWERCASE,
  strikethrough: IS_STRIKETHROUGH,
  subscript: IS_SUBSCRIPT,
  superscript: IS_SUPERSCRIPT,
  underline: IS_UNDERLINE,
  uppercase: IS_UPPERCASE
};
var DETAIL_TYPE_TO_DETAIL = {
  directionless: IS_DIRECTIONLESS,
  unmergeable: IS_UNMERGEABLE
};
var ELEMENT_TYPE_TO_FORMAT = {
  center: IS_ALIGN_CENTER,
  end: IS_ALIGN_END,
  justify: IS_ALIGN_JUSTIFY,
  left: IS_ALIGN_LEFT,
  right: IS_ALIGN_RIGHT,
  start: IS_ALIGN_START
};
var ELEMENT_FORMAT_TO_TYPE = {
  [IS_ALIGN_CENTER]: "center",
  [IS_ALIGN_END]: "end",
  [IS_ALIGN_JUSTIFY]: "justify",
  [IS_ALIGN_LEFT]: "left",
  [IS_ALIGN_RIGHT]: "right",
  [IS_ALIGN_START]: "start"
};
var TEXT_MODE_TO_TYPE = {
  normal: IS_NORMAL,
  segmented: IS_SEGMENTED,
  token: IS_TOKEN
};
var TEXT_TYPE_TO_MODE = {
  [IS_NORMAL]: "normal",
  [IS_SEGMENTED]: "segmented",
  [IS_TOKEN]: "token"
};
var NODE_STATE_KEY = "$";
var PROTOTYPE_CONFIG_METHOD = "$config";
function $garbageCollectDetachedDecorators(editor, pendingEditorState) {
  const currentDecorators = editor._decorators;
  const pendingDecorators = editor._pendingDecorators;
  let decorators = pendingDecorators || currentDecorators;
  const nodeMap = pendingEditorState._nodeMap;
  let key;
  for (key in decorators) {
    if (!nodeMap.has(key)) {
      if (decorators === currentDecorators) {
        decorators = cloneDecorators(editor);
      }
      delete decorators[key];
    }
  }
}
function $garbageCollectDetachedDeepChildNodes(node, parentKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes) {
  let child = node.getFirstChild();
  while (child !== null) {
    const childKey = child.__key;
    if (child.__parent === parentKey) {
      if ($isElementNode(child)) {
        $garbageCollectDetachedDeepChildNodes(child, childKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes);
      }
      if (!prevNodeMap.has(childKey)) {
        dirtyNodes.delete(childKey);
      }
      nodeMapDelete.push(childKey);
    }
    child = child.getNextSibling();
  }
}
function $garbageCollectDetachedNodes(prevEditorState, editorState, dirtyLeaves, dirtyElements) {
  const prevNodeMap = prevEditorState._nodeMap;
  const nodeMap = editorState._nodeMap;
  const nodeMapDelete = [];
  for (const [nodeKey] of dirtyElements) {
    const node = nodeMap.get(nodeKey);
    if (node !== void 0) {
      if (!node.isAttached()) {
        if ($isElementNode(node)) {
          $garbageCollectDetachedDeepChildNodes(node, nodeKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyElements);
        }
        if (!prevNodeMap.has(nodeKey)) {
          dirtyElements.delete(nodeKey);
        }
        nodeMapDelete.push(nodeKey);
      }
    }
  }
  for (const nodeKey of nodeMapDelete) {
    nodeMap.delete(nodeKey);
  }
  for (const nodeKey of dirtyLeaves) {
    const node = nodeMap.get(nodeKey);
    if (node !== void 0 && !node.isAttached()) {
      if (!prevNodeMap.has(nodeKey)) {
        dirtyLeaves.delete(nodeKey);
      }
      nodeMap.delete(nodeKey);
    }
  }
}
var TEXT_MUTATION_VARIANCE = 100;
var isProcessingMutations = false;
var lastTextEntryTimeStamp = 0;
function getIsProcessingMutations() {
  return isProcessingMutations;
}
function updateTimeStamp(event) {
  lastTextEntryTimeStamp = event.timeStamp;
}
function initTextEntryListener(editor) {
  if (lastTextEntryTimeStamp === 0) {
    getWindow(editor).addEventListener("textInput", updateTimeStamp, true);
  }
}
function isManagedLineBreak(dom, target, editor) {
  const isBR = dom.nodeName === "BR";
  const lexicalLineBreak = target.__lexicalLineBreak;
  return lexicalLineBreak && (dom === lexicalLineBreak || isBR && dom.previousSibling === lexicalLineBreak) || isBR && getNodeKeyFromDOMNode(dom, editor) !== void 0;
}
function getLastSelection(editor) {
  return editor.getEditorState().read(() => {
    const selection = $getSelection();
    return selection !== null ? selection.clone() : null;
  });
}
function $handleTextMutation(target, node, editor) {
  const domSelection = getDOMSelection(getWindow(editor));
  let anchorOffset = null;
  let focusOffset = null;
  if (domSelection !== null && domSelection.anchorNode === target) {
    anchorOffset = domSelection.anchorOffset;
    focusOffset = domSelection.focusOffset;
  }
  const text = target.nodeValue;
  if (text !== null) {
    $updateTextNodeFromDOMContent(node, text, anchorOffset, focusOffset, false);
  }
}
function shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode) {
  if ($isRangeSelection(selection)) {
    const anchorNode = selection.anchor.getNode();
    if (anchorNode.is(targetNode) && selection.format !== anchorNode.getFormat()) {
      return false;
    }
  }
  return isDOMTextNode(targetDOM) && targetNode.isAttached();
}
function $getNearestManagedNodePairFromDOMNode(startingDOM, editor, editorState, rootElement) {
  for (let dom = startingDOM; dom && !isDOMUnmanaged(dom); dom = getParentElement(dom)) {
    const key = getNodeKeyFromDOMNode(dom, editor);
    if (key !== void 0) {
      const node = $getNodeByKey(key, editorState);
      if (node) {
        return $isDecoratorNode(node) || !isHTMLElement(dom) ? void 0 : [dom, node];
      }
    } else if (dom === rootElement) {
      return [rootElement, internalGetRoot(editorState)];
    }
  }
}
function flushMutations(editor, mutations, observer) {
  isProcessingMutations = true;
  const shouldFlushTextMutations = performance.now() - lastTextEntryTimeStamp > TEXT_MUTATION_VARIANCE;
  try {
    updateEditorSync(editor, () => {
      const selection = $getSelection() || getLastSelection(editor);
      const badDOMTargets = /* @__PURE__ */ new Map();
      const rootElement = editor.getRootElement();
      const currentEditorState = editor._editorState;
      const blockCursorElement = editor._blockCursorElement;
      let shouldRevertSelection = false;
      let possibleTextForFirefoxPaste = "";
      for (let i2 = 0; i2 < mutations.length; i2++) {
        const mutation = mutations[i2];
        const type = mutation.type;
        const targetDOM = mutation.target;
        const pair = $getNearestManagedNodePairFromDOMNode(targetDOM, editor, currentEditorState, rootElement);
        if (!pair) {
          continue;
        }
        const [nodeDOM, targetNode] = pair;
        if (type === "characterData") {
          if (
            // TODO there is an edge case here if a mutation happens too quickly
            //      after text input, it may never be handled since we do not
            //      track the ignored mutations in any way
            shouldFlushTextMutations && $isTextNode(targetNode) && isDOMTextNode(targetDOM) && shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode)
          ) {
            $handleTextMutation(targetDOM, targetNode, editor);
          }
        } else if (type === "childList") {
          shouldRevertSelection = true;
          const addedDOMs = mutation.addedNodes;
          for (let s2 = 0; s2 < addedDOMs.length; s2++) {
            const addedDOM = addedDOMs[s2];
            const node = $getNodeFromDOMNode(addedDOM);
            const parentDOM = addedDOM.parentNode;
            if (parentDOM != null && addedDOM !== blockCursorElement && node === null && !isManagedLineBreak(addedDOM, parentDOM, editor)) {
              if (IS_FIREFOX) {
                const possibleText = (isHTMLElement(addedDOM) ? addedDOM.innerText : null) || addedDOM.nodeValue;
                if (possibleText) {
                  possibleTextForFirefoxPaste += possibleText;
                }
              }
              parentDOM.removeChild(addedDOM);
            }
          }
          const removedDOMs = mutation.removedNodes;
          const removedDOMsLength = removedDOMs.length;
          if (removedDOMsLength > 0) {
            let unremovedBRs = 0;
            for (let s2 = 0; s2 < removedDOMsLength; s2++) {
              const removedDOM = removedDOMs[s2];
              if (isManagedLineBreak(removedDOM, targetDOM, editor) || blockCursorElement === removedDOM) {
                targetDOM.appendChild(removedDOM);
                unremovedBRs++;
              }
            }
            if (removedDOMsLength !== unremovedBRs) {
              badDOMTargets.set(nodeDOM, targetNode);
            }
          }
        }
      }
      if (badDOMTargets.size > 0) {
        for (const [nodeDOM, targetNode] of badDOMTargets) {
          targetNode.reconcileObservedMutation(nodeDOM, editor);
        }
      }
      const records = observer.takeRecords();
      if (records.length > 0) {
        for (let i2 = 0; i2 < records.length; i2++) {
          const record = records[i2];
          const addedNodes = record.addedNodes;
          const target = record.target;
          for (let s2 = 0; s2 < addedNodes.length; s2++) {
            const addedDOM = addedNodes[s2];
            const parentDOM = addedDOM.parentNode;
            if (parentDOM != null && addedDOM.nodeName === "BR" && !isManagedLineBreak(addedDOM, target, editor)) {
              parentDOM.removeChild(addedDOM);
            }
          }
        }
        observer.takeRecords();
      }
      if (selection !== null) {
        if (shouldRevertSelection) {
          $setSelection(selection);
        }
        if (IS_FIREFOX && isFirefoxClipboardEvents(editor)) {
          selection.insertRawText(possibleTextForFirefoxPaste);
        }
      }
    });
  } finally {
    isProcessingMutations = false;
  }
}
function flushRootMutations(editor) {
  const observer = editor._observer;
  if (observer !== null) {
    const mutations = observer.takeRecords();
    flushMutations(editor, mutations, observer);
  }
}
function initMutationObserver(editor) {
  initTextEntryListener(editor);
  editor._observer = new MutationObserver((mutations, observer) => {
    flushMutations(editor, mutations, observer);
  });
}
var StateConfig = class {
  constructor(key, stateValueConfig) {
    /** The string key used when serializing this state to JSON */
    __publicField(this, "key");
    /** The parse function from the StateValueConfig passed to createState */
    __publicField(this, "parse");
    /**
     * The unparse function from the StateValueConfig passed to createState,
     * with a default that is simply a pass-through that assumes the value is
     * JSON serializable.
     */
    __publicField(this, "unparse");
    /**
     * An equality function from the StateValueConfig, with a default of
     * Object.is.
     */
    __publicField(this, "isEqual");
    /**
     * The result of `stateValueConfig.parse(undefined)`, which is computed only
     * once and used as the default value. When the current value `isEqual` to
     * the `defaultValue`, it will not be serialized to JSON.
     */
    __publicField(this, "defaultValue");
    this.key = key;
    this.parse = stateValueConfig.parse.bind(stateValueConfig);
    this.unparse = (stateValueConfig.unparse || coerceToJSON).bind(stateValueConfig);
    this.isEqual = (stateValueConfig.isEqual || Object.is).bind(stateValueConfig);
    this.defaultValue = this.parse(void 0);
  }
};
// @__NO_SIDE_EFFECTS__
function createState(key, valueConfig) {
  return new StateConfig(key, valueConfig);
}
function $getState(node, stateConfig, version = "latest") {
  const latestOrDirectNode = version === "latest" ? node.getLatest() : node;
  const state = latestOrDirectNode.__state;
  if (state) {
    $checkCollision(node, stateConfig, state);
    return state.getValue(stateConfig);
  }
  return stateConfig.defaultValue;
}
function $getStateChange(node, prevNode, stateConfig) {
  const value = $getState(node, stateConfig, "direct");
  const prevValue = $getState(prevNode, stateConfig, "direct");
  return stateConfig.isEqual(value, prevValue) ? null : [value, prevValue];
}
function $setState(node, stateConfig, valueOrUpdater) {
  errorOnReadOnly();
  let value;
  if (typeof valueOrUpdater === "function") {
    const latest = node.getLatest();
    const prevValue = $getState(latest, stateConfig);
    value = valueOrUpdater(prevValue);
    if (stateConfig.isEqual(prevValue, value)) {
      return latest;
    }
  } else {
    value = valueOrUpdater;
  }
  const writable = node.getWritable();
  const state = $getWritableNodeState(writable);
  $checkCollision(node, stateConfig, state);
  state.updateFromKnown(stateConfig, value);
  return writable;
}
function $checkCollision(node, stateConfig, state) {
  {
    const collision = state.sharedNodeState.sharedConfigMap.get(stateConfig.key);
    if (collision !== void 0 && collision !== stateConfig) {
      {
        formatDevErrorMessage(`$setState: State key collision ${JSON.stringify(stateConfig.key)} detected in ${node.constructor.name} node with type ${node.getType()} and key ${node.getKey()}. Only one StateConfig with a given key should be used on a node.`);
      }
    }
  }
}
function createSharedNodeState(nodeConfig) {
  const sharedConfigMap = /* @__PURE__ */ new Map();
  const flatKeys = /* @__PURE__ */ new Set();
  for (let klass = typeof nodeConfig === "function" ? nodeConfig : nodeConfig.replace; klass.prototype && klass.prototype.getType !== void 0; klass = Object.getPrototypeOf(klass)) {
    const {
      ownNodeConfig
    } = getStaticNodeConfig(klass);
    if (ownNodeConfig && ownNodeConfig.stateConfigs) {
      for (const requiredStateConfig of ownNodeConfig.stateConfigs) {
        let stateConfig;
        if ("stateConfig" in requiredStateConfig) {
          stateConfig = requiredStateConfig.stateConfig;
          if (requiredStateConfig.flat) {
            flatKeys.add(stateConfig.key);
          }
        } else {
          stateConfig = requiredStateConfig;
        }
        sharedConfigMap.set(stateConfig.key, stateConfig);
      }
    }
  }
  return {
    flatKeys,
    sharedConfigMap
  };
}
var NodeState = class _NodeState {
  /**
   * @internal
   */
  constructor(node, sharedNodeState, unknownState = void 0, knownState = /* @__PURE__ */ new Map(), size = void 0) {
    /**
     * @internal
     *
     * Track the (versioned) node that this NodeState was created for, to
     * facilitate copy-on-write for NodeState. When a LexicalNode is cloned,
     * it will *reference* the NodeState from its prevNode. From the nextNode
     * you can continue to read state without copying, but the first $setState
     * will trigger a copy of the prevNode's NodeState with the node property
     * updated.
     */
    __publicField(this, "node");
    /**
     * @internal
     *
     * State that has already been parsed in a get state, so it is safe. (can be returned with
     * just a cast since the proof was given before).
     *
     * Note that it uses StateConfig, so in addition to (1) the CURRENT VALUE, it has access to
     * (2) the State key (3) the DEFAULT VALUE and (4) the PARSE FUNCTION
     */
    __publicField(this, "knownState");
    /**
     * @internal
     *
     * A copy of serializedNode[NODE_STATE_KEY] that is made when JSON is
     * imported but has not been parsed yet.
     *
     * It stays here until a get state requires us to parse it, and since we
     * then know the value is safe we move it to knownState.
     *
     * Note that since only string keys are used here, we can only allow this
     * state to pass-through on export or on the next version since there is
     * no known value configuration. This pass-through is to support scenarios
     * where multiple versions of the editor code are working in parallel so
     * an old version of your code doesnt erase metadata that was
     * set by a newer version of your code.
     */
    __publicField(this, "unknownState");
    /**
     * @internal
     *
     * This sharedNodeState is preserved across all instances of a given
     * node type in an editor and remains writable. It is how keys are resolved
     * to configuration.
     */
    __publicField(this, "sharedNodeState");
    /**
     * @internal
     *
     * The count of known or unknown keys in this state, ignoring the
     * intersection between the two sets.
     */
    __publicField(this, "size");
    this.node = node;
    this.sharedNodeState = sharedNodeState;
    this.unknownState = unknownState;
    this.knownState = knownState;
    const {
      sharedConfigMap
    } = this.sharedNodeState;
    const computedSize = size !== void 0 ? size : computeSize(sharedConfigMap, unknownState, knownState);
    {
      if (!(size === void 0 || computedSize === size)) {
        formatDevErrorMessage(`NodeState: size != computedSize (${String(size)} != ${String(computedSize)})`);
      }
      for (const stateConfig of knownState.keys()) {
        if (!sharedConfigMap.has(stateConfig.key)) {
          formatDevErrorMessage(`NodeState: sharedConfigMap missing knownState key ${stateConfig.key}`);
        }
      }
    }
    this.size = computedSize;
  }
  /**
   * @internal
   *
   * Get the value from knownState, or parse it from unknownState
   * if it contains the given key.
   *
   * Updates the sharedConfigMap when no known state is found.
   * Updates unknownState and knownState when an unknownState is parsed.
   */
  getValue(stateConfig) {
    const known = this.knownState.get(stateConfig);
    if (known !== void 0) {
      return known;
    }
    this.sharedNodeState.sharedConfigMap.set(stateConfig.key, stateConfig);
    let parsed = stateConfig.defaultValue;
    if (this.unknownState && stateConfig.key in this.unknownState) {
      const jsonValue = this.unknownState[stateConfig.key];
      if (jsonValue !== void 0) {
        parsed = stateConfig.parse(jsonValue);
      }
      this.updateFromKnown(stateConfig, parsed);
    }
    return parsed;
  }
  /**
   * @internal
   *
   * Used only for advanced use cases, such as collab. The intent here is to
   * allow you to diff states with a more stable interface than the properties
   * of this class.
   */
  getInternalState() {
    return [this.unknownState, this.knownState];
  }
  /**
   * Encode this NodeState to JSON in the format that its node expects.
   * This returns `{[NODE_STATE_KEY]?: UnknownStateRecord}` rather than
   * `UnknownStateRecord | undefined` so that we can support flattening
   * specific entries in the future when nodes can declare what
   * their required StateConfigs are.
   */
  toJSON() {
    const state = {
      ...this.unknownState
    };
    const flatState = {};
    for (const [stateConfig, v2] of this.knownState) {
      if (stateConfig.isEqual(v2, stateConfig.defaultValue)) {
        delete state[stateConfig.key];
      } else {
        state[stateConfig.key] = stateConfig.unparse(v2);
      }
    }
    for (const key of this.sharedNodeState.flatKeys) {
      if (key in state) {
        flatState[key] = state[key];
        delete state[key];
      }
    }
    if (undefinedIfEmpty(state)) {
      flatState[NODE_STATE_KEY] = state;
    }
    return flatState;
  }
  /**
   * @internal
   *
   * A NodeState is writable when the node to update matches
   * the node associated with the NodeState. This basically
   * mirrors how the EditorState NodeMap works, but in a
   * bottom-up organization rather than a top-down organization.
   *
   * This allows us to implement the same "copy on write"
   * pattern for state, without having the state version
   * update every time the node version changes (e.g. when
   * its parent or siblings change).
   *
   * @param node The node to associate with the state
   * @returns The next writable state
   */
  getWritable(node) {
    if (this.node === node) {
      return this;
    }
    const {
      sharedNodeState,
      unknownState
    } = this;
    const nextKnownState = new Map(this.knownState);
    return new _NodeState(node, sharedNodeState, parseAndPruneNextUnknownState(sharedNodeState.sharedConfigMap, nextKnownState, unknownState), nextKnownState, this.size);
  }
  /** @internal */
  updateFromKnown(stateConfig, value) {
    const key = stateConfig.key;
    this.sharedNodeState.sharedConfigMap.set(key, stateConfig);
    const {
      knownState,
      unknownState
    } = this;
    if (!(knownState.has(stateConfig) || unknownState && key in unknownState)) {
      if (unknownState) {
        delete unknownState[key];
        this.unknownState = undefinedIfEmpty(unknownState);
      }
      this.size++;
    }
    knownState.set(stateConfig, value);
  }
  /**
   * @internal
   *
   * This is intended for advanced use cases only, such
   * as collab or dev tools.
   *
   * Update a single key value pair from unknown state,
   * parsing it if the key is known to this node. This is
   * basically like updateFromJSON, but the effect is
   * isolated to a single entry.
   *
   * @param k The string key from an UnknownStateRecord
   * @param v The unknown value from an UnknownStateRecord
   */
  updateFromUnknown(k, v2) {
    const stateConfig = this.sharedNodeState.sharedConfigMap.get(k);
    if (stateConfig) {
      this.updateFromKnown(stateConfig, stateConfig.parse(v2));
    } else {
      this.unknownState = this.unknownState || {};
      if (!(k in this.unknownState)) {
        this.size++;
      }
      this.unknownState[k] = v2;
    }
  }
  /**
   * @internal
   *
   * Reset all existing state to default or empty values,
   * and perform any updates from the given unknownState.
   *
   * This is used when initializing a node's state from JSON,
   * or when resetting a node's state from JSON.
   *
   * @param unknownState The new state in serialized form
   */
  updateFromJSON(unknownState) {
    const {
      knownState
    } = this;
    for (const stateConfig of knownState.keys()) {
      knownState.set(stateConfig, stateConfig.defaultValue);
    }
    this.size = knownState.size;
    this.unknownState = void 0;
    if (unknownState) {
      for (const [k, v2] of Object.entries(unknownState)) {
        this.updateFromUnknown(k, v2);
      }
    }
  }
};
function $getWritableNodeState(node) {
  const writable = node.getWritable();
  const state = writable.__state ? writable.__state.getWritable(writable) : new NodeState(writable, $getSharedNodeState(writable));
  writable.__state = state;
  return state;
}
function $getSharedNodeState(node) {
  return node.__state ? node.__state.sharedNodeState : getRegisteredNodeOrThrow($getEditor(), node.getType()).sharedNodeState;
}
function $updateStateFromJSON(node, serialized) {
  const writable = node.getWritable();
  const unknownState = serialized[NODE_STATE_KEY];
  let parseState = unknownState;
  for (const k of $getSharedNodeState(writable).flatKeys) {
    if (k in serialized) {
      if (parseState === void 0 || parseState === unknownState) {
        parseState = {
          ...unknownState
        };
      }
      parseState[k] = serialized[k];
    }
  }
  if (writable.__state || parseState) {
    $getWritableNodeState(node).updateFromJSON(parseState);
  }
  return writable;
}
function nodeStatesAreEquivalent(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (a2 && b2 && a2.size !== b2.size) {
    return false;
  }
  const keys = /* @__PURE__ */ new Set();
  return !(a2 && hasUnequalMapEntry(keys, a2, b2) || b2 && hasUnequalMapEntry(keys, b2, a2) || a2 && hasUnequalRecordEntry(keys, a2, b2) || b2 && hasUnequalRecordEntry(keys, b2, a2));
}
function computeSize(sharedConfigMap, unknownState, knownState) {
  let size = knownState.size;
  if (unknownState) {
    for (const k in unknownState) {
      const sharedConfig = sharedConfigMap.get(k);
      if (!sharedConfig || !knownState.has(sharedConfig)) {
        size++;
      }
    }
  }
  return size;
}
function undefinedIfEmpty(obj) {
  if (obj) {
    for (const key in obj) {
      return obj;
    }
  }
  return void 0;
}
function coerceToJSON(v2) {
  return v2;
}
function parseAndPruneNextUnknownState(sharedConfigMap, nextKnownState, unknownState) {
  let nextUnknownState = void 0;
  if (unknownState) {
    for (const [k, v2] of Object.entries(unknownState)) {
      const stateConfig = sharedConfigMap.get(k);
      if (stateConfig) {
        if (!nextKnownState.has(stateConfig)) {
          nextKnownState.set(stateConfig, stateConfig.parse(v2));
        }
      } else {
        nextUnknownState = nextUnknownState || {};
        nextUnknownState[k] = v2;
      }
    }
  }
  return nextUnknownState;
}
function hasUnequalMapEntry(keys, sourceState, otherState) {
  for (const [stateConfig, value] of sourceState.knownState) {
    if (keys.has(stateConfig.key)) {
      continue;
    }
    keys.add(stateConfig.key);
    const otherValue = otherState ? otherState.getValue(stateConfig) : stateConfig.defaultValue;
    if (otherValue !== value && !stateConfig.isEqual(otherValue, value)) {
      return true;
    }
  }
  return false;
}
function hasUnequalRecordEntry(keys, sourceState, otherState) {
  const {
    unknownState
  } = sourceState;
  const otherUnknownState = otherState ? otherState.unknownState : void 0;
  if (unknownState) {
    for (const [key, value] of Object.entries(unknownState)) {
      if (keys.has(key)) {
        continue;
      }
      keys.add(key);
      const otherValue = otherUnknownState ? otherUnknownState[key] : void 0;
      if (value !== otherValue) {
        return true;
      }
    }
  }
  return false;
}
function $cloneNodeState(from, to) {
  const state = from.__state;
  return state && state.node === from ? state.getWritable(to) : state;
}
function $canSimpleTextNodesBeMerged(node1, node2) {
  const node1Mode = node1.__mode;
  const node1Format = node1.__format;
  const node1Style = node1.__style;
  const node2Mode = node2.__mode;
  const node2Format = node2.__format;
  const node2Style = node2.__style;
  const node1State = node1.__state;
  const node2State = node2.__state;
  return (node1Mode === null || node1Mode === node2Mode) && (node1Format === null || node1Format === node2Format) && (node1Style === null || node1Style === node2Style) && (node1.__state === null || node1State === node2State || nodeStatesAreEquivalent(node1State, node2State));
}
function $mergeTextNodes(node1, node2) {
  const writableNode1 = node1.mergeWithSibling(node2);
  const normalizedNodes = getActiveEditor()._normalizedNodes;
  normalizedNodes.add(node1.__key);
  normalizedNodes.add(node2.__key);
  return writableNode1;
}
function $normalizeTextNode(textNode) {
  let node = textNode;
  if (node.__text === "" && node.isSimpleText() && !node.isUnmergeable()) {
    node.remove();
    return;
  }
  let previousNode;
  while ((previousNode = node.getPreviousSibling()) !== null && $isTextNode(previousNode) && previousNode.isSimpleText() && !previousNode.isUnmergeable()) {
    if (previousNode.__text === "") {
      previousNode.remove();
    } else if ($canSimpleTextNodesBeMerged(previousNode, node)) {
      node = $mergeTextNodes(previousNode, node);
      break;
    } else {
      break;
    }
  }
  let nextNode;
  while ((nextNode = node.getNextSibling()) !== null && $isTextNode(nextNode) && nextNode.isSimpleText() && !nextNode.isUnmergeable()) {
    if (nextNode.__text === "") {
      nextNode.remove();
    } else if ($canSimpleTextNodesBeMerged(node, nextNode)) {
      node = $mergeTextNodes(node, nextNode);
      break;
    } else {
      break;
    }
  }
}
function $normalizeSelection(selection) {
  $normalizePoint(selection.anchor);
  $normalizePoint(selection.focus);
  return selection;
}
function $normalizePoint(point) {
  while (point.type === "element") {
    const node = point.getNode();
    const offset = point.offset;
    let nextNode;
    let nextOffsetAtEnd;
    if (offset === node.getChildrenSize()) {
      nextNode = node.getChildAtIndex(offset - 1);
      nextOffsetAtEnd = true;
    } else {
      nextNode = node.getChildAtIndex(offset);
      nextOffsetAtEnd = false;
    }
    if ($isTextNode(nextNode)) {
      point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getTextContentSize() : 0, "text", true);
      break;
    } else if (!$isElementNode(nextNode)) {
      break;
    }
    point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getChildrenSize() : 0, "element", true);
  }
}
var subTreeTextContent = "";
var subTreeTextFormat = null;
var subTreeTextStyle = null;
var editorTextContent = "";
var activeEditorConfig;
var activeEditor$1;
var activeEditorNodes;
var treatAllNodesAsDirty = false;
var activeEditorStateReadOnly = false;
var activeMutationListeners;
var activeDirtyElements;
var activeDirtyLeaves;
var activePrevNodeMap;
var activeNextNodeMap;
var activePrevKeyToDOMMap;
var mutatedNodes;
function destroyNode(key, parentDOM) {
  const node = activePrevNodeMap.get(key);
  if (parentDOM !== null) {
    const dom = getPrevElementByKeyOrThrow(key);
    if (dom.parentNode === parentDOM) {
      parentDOM.removeChild(dom);
    }
  }
  if (!activeNextNodeMap.has(key)) {
    activeEditor$1._keyToDOMMap.delete(key);
  }
  if ($isElementNode(node)) {
    const children = createChildrenArray(node, activePrevNodeMap);
    destroyChildren(children, 0, children.length - 1, null);
  }
  if (node !== void 0) {
    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, "destroyed");
  }
}
function destroyChildren(children, _startIndex, endIndex, dom) {
  let startIndex = _startIndex;
  for (; startIndex <= endIndex; ++startIndex) {
    const child = children[startIndex];
    if (child !== void 0) {
      destroyNode(child, dom);
    }
  }
}
function setTextAlign(domStyle, value) {
  domStyle.setProperty("text-align", value);
}
var DEFAULT_INDENT_VALUE = "40px";
function setElementIndent(dom, indent) {
  const indentClassName = activeEditorConfig.theme.indent;
  if (typeof indentClassName === "string") {
    const elementHasClassName = dom.classList.contains(indentClassName);
    if (indent > 0 && !elementHasClassName) {
      dom.classList.add(indentClassName);
    } else if (indent < 1 && elementHasClassName) {
      dom.classList.remove(indentClassName);
    }
  }
  const indentationBaseValue = getComputedStyle(dom).getPropertyValue("--lexical-indent-base-value") || DEFAULT_INDENT_VALUE;
  dom.style.setProperty("padding-inline-start", indent === 0 ? "" : `calc(${indent} * ${indentationBaseValue})`);
}
function setElementFormat(dom, format) {
  const domStyle = dom.style;
  if (format === 0) {
    setTextAlign(domStyle, "");
  } else if (format === IS_ALIGN_LEFT) {
    setTextAlign(domStyle, "left");
  } else if (format === IS_ALIGN_CENTER) {
    setTextAlign(domStyle, "center");
  } else if (format === IS_ALIGN_RIGHT) {
    setTextAlign(domStyle, "right");
  } else if (format === IS_ALIGN_JUSTIFY) {
    setTextAlign(domStyle, "justify");
  } else if (format === IS_ALIGN_START) {
    setTextAlign(domStyle, "start");
  } else if (format === IS_ALIGN_END) {
    setTextAlign(domStyle, "end");
  }
}
function $getReconciledDirection(node) {
  const direction = node.__dir;
  if (direction !== null) {
    return direction;
  }
  if ($isRootNode(node)) {
    return null;
  }
  const parent = node.getParentOrThrow();
  if (!$isRootNode(parent) || parent.__dir !== null) {
    return null;
  }
  return "auto";
}
function $setElementDirection(dom, node) {
  const direction = $getReconciledDirection(node);
  if (direction !== null) {
    dom.dir = direction;
  } else {
    dom.removeAttribute("dir");
  }
}
function $createNode(key, slot) {
  const node = activeNextNodeMap.get(key);
  if (node === void 0) {
    {
      formatDevErrorMessage(`createNode: node does not exist in nodeMap`);
    }
  }
  const dom = node.createDOM(activeEditorConfig, activeEditor$1);
  storeDOMWithKey(key, dom, activeEditor$1);
  if ($isTextNode(node)) {
    dom.setAttribute("data-lexical-text", "true");
  } else if ($isDecoratorNode(node)) {
    dom.setAttribute("data-lexical-decorator", "true");
  }
  if ($isElementNode(node)) {
    const indent = node.__indent;
    const childrenSize = node.__size;
    $setElementDirection(dom, node);
    if (indent !== 0) {
      setElementIndent(dom, indent);
    }
    if (childrenSize !== 0) {
      const endIndex = childrenSize - 1;
      const children = createChildrenArray(node, activeNextNodeMap);
      $createChildren(children, node, 0, endIndex, node.getDOMSlot(dom));
    }
    const format = node.__format;
    if (format !== 0) {
      setElementFormat(dom, format);
    }
    if (!node.isInline()) {
      reconcileElementTerminatingLineBreak(null, node, dom);
    }
    if ($textContentRequiresDoubleLinebreakAtEnd(node)) {
      subTreeTextContent += DOUBLE_LINE_BREAK;
      editorTextContent += DOUBLE_LINE_BREAK;
    }
  } else {
    const text = node.getTextContent();
    if ($isDecoratorNode(node)) {
      const decorator = node.decorate(activeEditor$1, activeEditorConfig);
      if (decorator !== null) {
        reconcileDecorator(key, decorator);
      }
      dom.contentEditable = "false";
    }
    subTreeTextContent += text;
    editorTextContent += text;
  }
  if (slot !== null) {
    slot.insertChild(dom);
  }
  {
    Object.freeze(node);
  }
  setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, "created");
  return dom;
}
function $createChildren(children, element, _startIndex, endIndex, slot) {
  const previousSubTreeTextContent = subTreeTextContent;
  subTreeTextContent = "";
  let startIndex = _startIndex;
  for (; startIndex <= endIndex; ++startIndex) {
    $createNode(children[startIndex], slot);
    const node = activeNextNodeMap.get(children[startIndex]);
    if (node !== null && $isTextNode(node)) {
      if (subTreeTextFormat === null) {
        subTreeTextFormat = node.getFormat();
        subTreeTextStyle = node.getStyle();
      }
    }
  }
  if ($textContentRequiresDoubleLinebreakAtEnd(element)) {
    subTreeTextContent += DOUBLE_LINE_BREAK;
  }
  const dom = slot.element;
  dom.__lexicalTextContent = subTreeTextContent;
  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;
}
function isLastChildLineBreakOrDecorator(element, nodeMap) {
  if (element) {
    const lastKey = element.__last;
    if (lastKey) {
      const node = nodeMap.get(lastKey);
      if (node) {
        return $isLineBreakNode(node) ? "line-break" : $isDecoratorNode(node) && node.isInline() ? "decorator" : null;
      }
    }
    return "empty";
  }
  return null;
}
function reconcileElementTerminatingLineBreak(prevElement, nextElement, dom) {
  const prevLineBreak = isLastChildLineBreakOrDecorator(prevElement, activePrevNodeMap);
  const nextLineBreak = isLastChildLineBreakOrDecorator(nextElement, activeNextNodeMap);
  if (prevLineBreak !== nextLineBreak) {
    nextElement.getDOMSlot(dom).setManagedLineBreak(nextLineBreak);
  }
}
function reconcileTextFormat(element) {
  if (subTreeTextFormat != null && subTreeTextFormat !== element.__textFormat && !activeEditorStateReadOnly) {
    element.setTextFormat(subTreeTextFormat);
  }
}
function reconcileTextStyle(element) {
  if (subTreeTextStyle != null && subTreeTextStyle !== element.__textStyle && !activeEditorStateReadOnly) {
    element.setTextStyle(subTreeTextStyle);
  }
}
function $reconcileChildrenWithDirection(prevElement, nextElement, dom) {
  subTreeTextFormat = null;
  subTreeTextStyle = null;
  $reconcileChildren(prevElement, nextElement, nextElement.getDOMSlot(dom));
  reconcileTextFormat(nextElement);
  reconcileTextStyle(nextElement);
}
function createChildrenArray(element, nodeMap) {
  const children = [];
  let nodeKey = element.__first;
  while (nodeKey !== null) {
    const node = nodeMap.get(nodeKey);
    if (node === void 0) {
      {
        formatDevErrorMessage(`createChildrenArray: node does not exist in nodeMap`);
      }
    }
    children.push(nodeKey);
    nodeKey = node.__next;
  }
  return children;
}
function $reconcileChildren(prevElement, nextElement, slot) {
  const previousSubTreeTextContent = subTreeTextContent;
  const prevChildrenSize = prevElement.__size;
  const nextChildrenSize = nextElement.__size;
  subTreeTextContent = "";
  const dom = slot.element;
  if (prevChildrenSize === 1 && nextChildrenSize === 1) {
    const prevFirstChildKey = prevElement.__first;
    const nextFirstChildKey = nextElement.__first;
    if (prevFirstChildKey === nextFirstChildKey) {
      $reconcileNode(prevFirstChildKey, dom);
    } else {
      const lastDOM = getPrevElementByKeyOrThrow(prevFirstChildKey);
      const replacementDOM = $createNode(nextFirstChildKey, null);
      try {
        dom.replaceChild(replacementDOM, lastDOM);
      } catch (error) {
        if (typeof error === "object" && error != null) {
          const msg = `${error.toString()} Parent: ${dom.tagName}, new child: {tag: ${replacementDOM.tagName} key: ${nextFirstChildKey}}, old child: {tag: ${lastDOM.tagName}, key: ${prevFirstChildKey}}.`;
          throw new Error(msg);
        } else {
          throw error;
        }
      }
      destroyNode(prevFirstChildKey, null);
    }
    const nextChildNode = activeNextNodeMap.get(nextFirstChildKey);
    if ($isTextNode(nextChildNode)) {
      if (subTreeTextFormat === null) {
        subTreeTextFormat = nextChildNode.getFormat();
        subTreeTextStyle = nextChildNode.getStyle();
      }
    }
  } else {
    const prevChildren = createChildrenArray(prevElement, activePrevNodeMap);
    const nextChildren = createChildrenArray(nextElement, activeNextNodeMap);
    if (!(prevChildren.length === prevChildrenSize)) {
      formatDevErrorMessage(`$reconcileChildren: prevChildren.length !== prevChildrenSize`);
    }
    if (!(nextChildren.length === nextChildrenSize)) {
      formatDevErrorMessage(`$reconcileChildren: nextChildren.length !== nextChildrenSize`);
    }
    if (prevChildrenSize === 0) {
      if (nextChildrenSize !== 0) {
        $createChildren(nextChildren, nextElement, 0, nextChildrenSize - 1, slot);
      }
    } else if (nextChildrenSize === 0) {
      if (prevChildrenSize !== 0) {
        const canUseFastPath = slot.after == null && slot.before == null && slot.element.__lexicalLineBreak == null;
        destroyChildren(prevChildren, 0, prevChildrenSize - 1, canUseFastPath ? null : dom);
        if (canUseFastPath) {
          dom.textContent = "";
        }
      }
    } else {
      $reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenSize, nextChildrenSize, slot);
    }
  }
  if ($textContentRequiresDoubleLinebreakAtEnd(nextElement)) {
    subTreeTextContent += DOUBLE_LINE_BREAK;
  }
  dom.__lexicalTextContent = subTreeTextContent;
  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;
}
function $reconcileNode(key, parentDOM) {
  const prevNode = activePrevNodeMap.get(key);
  let nextNode = activeNextNodeMap.get(key);
  if (prevNode === void 0 || nextNode === void 0) {
    {
      formatDevErrorMessage(`reconcileNode: prevNode or nextNode does not exist in nodeMap`);
    }
  }
  const isDirty = treatAllNodesAsDirty || activeDirtyLeaves.has(key) || activeDirtyElements.has(key);
  const dom = getElementByKeyOrThrow(activeEditor$1, key);
  if (prevNode === nextNode && !isDirty) {
    if ($isElementNode(prevNode)) {
      const previousSubTreeTextContent = dom.__lexicalTextContent;
      if (previousSubTreeTextContent !== void 0) {
        subTreeTextContent += previousSubTreeTextContent;
        editorTextContent += previousSubTreeTextContent;
      }
    } else {
      const text = prevNode.getTextContent();
      editorTextContent += text;
      subTreeTextContent += text;
    }
    return dom;
  }
  if (prevNode !== nextNode && isDirty) {
    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, nextNode, "updated");
  }
  if (nextNode.updateDOM(prevNode, dom, activeEditorConfig)) {
    const replacementDOM = $createNode(key, null);
    if (parentDOM === null) {
      {
        formatDevErrorMessage(`reconcileNode: parentDOM is null`);
      }
    }
    parentDOM.replaceChild(replacementDOM, dom);
    destroyNode(key, null);
    return replacementDOM;
  }
  if ($isElementNode(prevNode) && $isElementNode(nextNode)) {
    const nextIndent = nextNode.__indent;
    if (treatAllNodesAsDirty || nextIndent !== prevNode.__indent) {
      setElementIndent(dom, nextIndent);
    }
    const nextFormat = nextNode.__format;
    if (treatAllNodesAsDirty || nextFormat !== prevNode.__format) {
      setElementFormat(dom, nextFormat);
    }
    if (isDirty) {
      $reconcileChildrenWithDirection(prevNode, nextNode, dom);
      if (!$isRootNode(nextNode) && !nextNode.isInline()) {
        reconcileElementTerminatingLineBreak(prevNode, nextNode, dom);
      }
    }
    if ($textContentRequiresDoubleLinebreakAtEnd(nextNode)) {
      subTreeTextContent += DOUBLE_LINE_BREAK;
      editorTextContent += DOUBLE_LINE_BREAK;
    }
    if (treatAllNodesAsDirty || nextNode.__dir !== prevNode.__dir) {
      $setElementDirection(dom, nextNode);
      if (
        // Root node direction changing from set to unset (or vice versa)
        // changes how children's direction is calculated.
        $isRootNode(nextNode) && // Can skip if all children already reconciled.
        !treatAllNodesAsDirty
      ) {
        for (const child of nextNode.getChildren()) {
          if ($isElementNode(child)) {
            const childDom = getElementByKeyOrThrow(activeEditor$1, child.getKey());
            $setElementDirection(childDom, child);
          }
        }
      }
    }
  } else {
    const text = nextNode.getTextContent();
    if ($isDecoratorNode(nextNode)) {
      const decorator = nextNode.decorate(activeEditor$1, activeEditorConfig);
      if (decorator !== null) {
        reconcileDecorator(key, decorator);
      }
    }
    subTreeTextContent += text;
    editorTextContent += text;
  }
  if (!activeEditorStateReadOnly && $isRootNode(nextNode) && nextNode.__cachedText !== editorTextContent) {
    const nextRootNode = nextNode.getWritable();
    nextRootNode.__cachedText = editorTextContent;
    nextNode = nextRootNode;
  }
  {
    Object.freeze(nextNode);
  }
  return dom;
}
function reconcileDecorator(key, decorator) {
  let pendingDecorators = activeEditor$1._pendingDecorators;
  const currentDecorators = activeEditor$1._decorators;
  if (pendingDecorators === null) {
    if (currentDecorators[key] === decorator) {
      return;
    }
    pendingDecorators = cloneDecorators(activeEditor$1);
  }
  pendingDecorators[key] = decorator;
}
function getNextSibling(element) {
  let nextSibling = element.nextSibling;
  if (nextSibling !== null && nextSibling === activeEditor$1._blockCursorElement) {
    nextSibling = nextSibling.nextSibling;
  }
  return nextSibling;
}
function $reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenLength, nextChildrenLength, slot) {
  const prevEndIndex = prevChildrenLength - 1;
  const nextEndIndex = nextChildrenLength - 1;
  let prevChildrenSet;
  let nextChildrenSet;
  let siblingDOM = slot.getFirstChild();
  let prevIndex2 = 0;
  let nextIndex = 0;
  while (prevIndex2 <= prevEndIndex && nextIndex <= nextEndIndex) {
    const prevKey = prevChildren[prevIndex2];
    const nextKey = nextChildren[nextIndex];
    if (prevKey === nextKey) {
      siblingDOM = getNextSibling($reconcileNode(nextKey, slot.element));
      prevIndex2++;
      nextIndex++;
    } else {
      if (prevChildrenSet === void 0) {
        prevChildrenSet = new Set(prevChildren);
      }
      if (nextChildrenSet === void 0) {
        nextChildrenSet = new Set(nextChildren);
      }
      const nextHasPrevKey = nextChildrenSet.has(prevKey);
      const prevHasNextKey = prevChildrenSet.has(nextKey);
      if (!nextHasPrevKey) {
        siblingDOM = getNextSibling(getPrevElementByKeyOrThrow(prevKey));
        destroyNode(prevKey, slot.element);
        prevIndex2++;
      } else if (!prevHasNextKey) {
        $createNode(nextKey, slot.withBefore(siblingDOM));
        nextIndex++;
      } else {
        const childDOM = getElementByKeyOrThrow(activeEditor$1, nextKey);
        if (childDOM === siblingDOM) {
          siblingDOM = getNextSibling($reconcileNode(nextKey, slot.element));
        } else {
          slot.withBefore(siblingDOM).insertChild(childDOM);
          $reconcileNode(nextKey, slot.element);
        }
        prevIndex2++;
        nextIndex++;
      }
    }
    const node = activeNextNodeMap.get(nextKey);
    if (node !== null && $isTextNode(node)) {
      if (subTreeTextFormat === null) {
        subTreeTextFormat = node.getFormat();
        subTreeTextStyle = node.getStyle();
      }
    }
  }
  const appendNewChildren = prevIndex2 > prevEndIndex;
  const removeOldChildren = nextIndex > nextEndIndex;
  if (appendNewChildren && !removeOldChildren) {
    const previousNode = nextChildren[nextEndIndex + 1];
    const insertDOM = previousNode === void 0 ? null : activeEditor$1.getElementByKey(previousNode);
    $createChildren(nextChildren, nextElement, nextIndex, nextEndIndex, slot.withBefore(insertDOM));
  } else if (removeOldChildren && !appendNewChildren) {
    destroyChildren(prevChildren, prevIndex2, prevEndIndex, slot.element);
  }
}
function $reconcileRoot(prevEditorState, nextEditorState, editor, dirtyType, dirtyElements, dirtyLeaves) {
  subTreeTextContent = "";
  editorTextContent = "";
  treatAllNodesAsDirty = dirtyType === FULL_RECONCILE;
  activeEditor$1 = editor;
  activeEditorConfig = editor._config;
  activeEditorNodes = editor._nodes;
  activeMutationListeners = activeEditor$1._listeners.mutation;
  activeDirtyElements = dirtyElements;
  activeDirtyLeaves = dirtyLeaves;
  activePrevNodeMap = prevEditorState._nodeMap;
  activeNextNodeMap = nextEditorState._nodeMap;
  activeEditorStateReadOnly = nextEditorState._readOnly;
  activePrevKeyToDOMMap = new Map(editor._keyToDOMMap);
  const currentMutatedNodes = /* @__PURE__ */ new Map();
  mutatedNodes = currentMutatedNodes;
  $reconcileNode("root", null);
  activeEditor$1 = void 0;
  activeEditorNodes = void 0;
  activeDirtyElements = void 0;
  activeDirtyLeaves = void 0;
  activePrevNodeMap = void 0;
  activeNextNodeMap = void 0;
  activeEditorConfig = void 0;
  activePrevKeyToDOMMap = void 0;
  mutatedNodes = void 0;
  return currentMutatedNodes;
}
function storeDOMWithKey(key, dom, editor) {
  const keyToDOMMap = editor._keyToDOMMap;
  setNodeKeyOnDOMNode(dom, editor, key);
  keyToDOMMap.set(key, dom);
}
function getPrevElementByKeyOrThrow(key) {
  const element = activePrevKeyToDOMMap.get(key);
  if (element === void 0) {
    {
      formatDevErrorMessage(`Reconciliation: could not find DOM element for node key ${key}`);
    }
  }
  return element;
}
function warnOnlyOnce(message) {
  {
    let run = false;
    return () => {
      if (!run) {
        console.warn(message);
      }
      run = true;
    };
  }
}
// @__NO_SIDE_EFFECTS__
function createCommand(type) {
  return {
    type
  };
}
var SELECTION_CHANGE_COMMAND = /* @__PURE__ */ createCommand("SELECTION_CHANGE_COMMAND");
var SELECTION_INSERT_CLIPBOARD_NODES_COMMAND = /* @__PURE__ */ createCommand("SELECTION_INSERT_CLIPBOARD_NODES_COMMAND");
var CLICK_COMMAND = /* @__PURE__ */ createCommand("CLICK_COMMAND");
var BEFORE_INPUT_COMMAND = /* @__PURE__ */ createCommand("BEFORE_INPUT_COMMAND");
var INPUT_COMMAND = /* @__PURE__ */ createCommand("INPUT_COMMAND");
var COMPOSITION_START_COMMAND = /* @__PURE__ */ createCommand("COMPOSITION_START_COMMAND");
var COMPOSITION_END_COMMAND = /* @__PURE__ */ createCommand("COMPOSITION_END_COMMAND");
var DELETE_CHARACTER_COMMAND = /* @__PURE__ */ createCommand("DELETE_CHARACTER_COMMAND");
var INSERT_LINE_BREAK_COMMAND = /* @__PURE__ */ createCommand("INSERT_LINE_BREAK_COMMAND");
var INSERT_PARAGRAPH_COMMAND = /* @__PURE__ */ createCommand("INSERT_PARAGRAPH_COMMAND");
var CONTROLLED_TEXT_INSERTION_COMMAND = /* @__PURE__ */ createCommand("CONTROLLED_TEXT_INSERTION_COMMAND");
var PASTE_COMMAND = /* @__PURE__ */ createCommand("PASTE_COMMAND");
var REMOVE_TEXT_COMMAND = /* @__PURE__ */ createCommand("REMOVE_TEXT_COMMAND");
var DELETE_WORD_COMMAND = /* @__PURE__ */ createCommand("DELETE_WORD_COMMAND");
var DELETE_LINE_COMMAND = /* @__PURE__ */ createCommand("DELETE_LINE_COMMAND");
var FORMAT_TEXT_COMMAND = /* @__PURE__ */ createCommand("FORMAT_TEXT_COMMAND");
var UNDO_COMMAND = /* @__PURE__ */ createCommand("UNDO_COMMAND");
var REDO_COMMAND = /* @__PURE__ */ createCommand("REDO_COMMAND");
var KEY_DOWN_COMMAND = /* @__PURE__ */ createCommand("KEYDOWN_COMMAND");
var KEY_ARROW_RIGHT_COMMAND = /* @__PURE__ */ createCommand("KEY_ARROW_RIGHT_COMMAND");
var MOVE_TO_END = /* @__PURE__ */ createCommand("MOVE_TO_END");
var KEY_ARROW_LEFT_COMMAND = /* @__PURE__ */ createCommand("KEY_ARROW_LEFT_COMMAND");
var MOVE_TO_START = /* @__PURE__ */ createCommand("MOVE_TO_START");
var KEY_ARROW_UP_COMMAND = /* @__PURE__ */ createCommand("KEY_ARROW_UP_COMMAND");
var KEY_ARROW_DOWN_COMMAND = /* @__PURE__ */ createCommand("KEY_ARROW_DOWN_COMMAND");
var KEY_ENTER_COMMAND = /* @__PURE__ */ createCommand("KEY_ENTER_COMMAND");
var KEY_SPACE_COMMAND = /* @__PURE__ */ createCommand("KEY_SPACE_COMMAND");
var KEY_BACKSPACE_COMMAND = /* @__PURE__ */ createCommand("KEY_BACKSPACE_COMMAND");
var KEY_ESCAPE_COMMAND = /* @__PURE__ */ createCommand("KEY_ESCAPE_COMMAND");
var KEY_DELETE_COMMAND = /* @__PURE__ */ createCommand("KEY_DELETE_COMMAND");
var KEY_TAB_COMMAND = /* @__PURE__ */ createCommand("KEY_TAB_COMMAND");
var INSERT_TAB_COMMAND = /* @__PURE__ */ createCommand("INSERT_TAB_COMMAND");
var INDENT_CONTENT_COMMAND = /* @__PURE__ */ createCommand("INDENT_CONTENT_COMMAND");
var OUTDENT_CONTENT_COMMAND = /* @__PURE__ */ createCommand("OUTDENT_CONTENT_COMMAND");
var DROP_COMMAND = /* @__PURE__ */ createCommand("DROP_COMMAND");
var FORMAT_ELEMENT_COMMAND = /* @__PURE__ */ createCommand("FORMAT_ELEMENT_COMMAND");
var DRAGSTART_COMMAND = /* @__PURE__ */ createCommand("DRAGSTART_COMMAND");
var DRAGOVER_COMMAND = /* @__PURE__ */ createCommand("DRAGOVER_COMMAND");
var DRAGEND_COMMAND = /* @__PURE__ */ createCommand("DRAGEND_COMMAND");
var COPY_COMMAND = /* @__PURE__ */ createCommand("COPY_COMMAND");
var CUT_COMMAND = /* @__PURE__ */ createCommand("CUT_COMMAND");
var SELECT_ALL_COMMAND = /* @__PURE__ */ createCommand("SELECT_ALL_COMMAND");
var CLEAR_EDITOR_COMMAND = /* @__PURE__ */ createCommand("CLEAR_EDITOR_COMMAND");
var CLEAR_HISTORY_COMMAND = /* @__PURE__ */ createCommand("CLEAR_HISTORY_COMMAND");
var CAN_REDO_COMMAND = /* @__PURE__ */ createCommand("CAN_REDO_COMMAND");
var CAN_UNDO_COMMAND = /* @__PURE__ */ createCommand("CAN_UNDO_COMMAND");
var FOCUS_COMMAND = /* @__PURE__ */ createCommand("FOCUS_COMMAND");
var BLUR_COMMAND = /* @__PURE__ */ createCommand("BLUR_COMMAND");
var KEY_MODIFIER_COMMAND = /* @__PURE__ */ createCommand("KEY_MODIFIER_COMMAND");
var PASS_THROUGH_COMMAND = Object.freeze({});
var ANDROID_COMPOSITION_LATENCY = 30;
var rootElementEvents = [["keydown", onKeyDown], ["pointerdown", onPointerDown], ["compositionstart", onCompositionStart], ["compositionend", onCompositionEnd], ["input", onInput], ["click", onClick], ["cut", PASS_THROUGH_COMMAND], ["copy", PASS_THROUGH_COMMAND], ["dragstart", PASS_THROUGH_COMMAND], ["dragover", PASS_THROUGH_COMMAND], ["dragend", PASS_THROUGH_COMMAND], ["paste", PASS_THROUGH_COMMAND], ["focus", PASS_THROUGH_COMMAND], ["blur", PASS_THROUGH_COMMAND], ["drop", PASS_THROUGH_COMMAND]];
if (CAN_USE_BEFORE_INPUT) {
  rootElementEvents.push(["beforeinput", (event, editor) => onBeforeInput(event, editor)]);
}
var lastKeyDownTimeStamp = 0;
var lastKeyCode = null;
var lastBeforeInputInsertTextTimeStamp = 0;
var unprocessedBeforeInputData = null;
var rootElementToDocument = /* @__PURE__ */ new WeakMap();
var rootElementsRegistered = /* @__PURE__ */ new WeakMap();
var isSelectionChangeFromDOMUpdate = false;
var isSelectionChangeFromMouseDown = false;
var isInsertLineBreak = false;
var isFirefoxEndingComposition = false;
var isSafariEndingComposition = false;
var safariEndCompositionEventData = "";
var postDeleteSelectionToRestore = null;
var collapsedSelectionFormat = [0, "", 0, "root", 0];
function $shouldPreventDefaultAndInsertText(selection, domTargetRange, text, timeStamp, isBeforeInput) {
  const anchor = selection.anchor;
  const focus = selection.focus;
  const anchorNode = anchor.getNode();
  const editor = getActiveEditor();
  const domSelection = getDOMSelection(getWindow(editor));
  const domAnchorNode = domSelection !== null ? domSelection.anchorNode : null;
  const anchorKey = anchor.key;
  const backingAnchorElement = editor.getElementByKey(anchorKey);
  const textLength = text.length;
  return anchorKey !== focus.key || // If we're working with a non-text node.
  !$isTextNode(anchorNode) || // If we are replacing a range with a single character or grapheme, and not composing.
  (!isBeforeInput && (!CAN_USE_BEFORE_INPUT || // We check to see if there has been
  // a recent beforeinput event for "textInput". If there has been one in the last
  // 50ms then we proceed as normal. However, if there is not, then this is likely
  // a dangling `input` event caused by execCommand('insertText').
  lastBeforeInputInsertTextTimeStamp < timeStamp + 50) || anchorNode.isDirty() && textLength < 2 || // TODO consider if there are other scenarios when multiple code units
  //      should be addressed here
  doesContainSurrogatePair(text)) && anchor.offset !== focus.offset && !anchorNode.isComposing() || // Any non standard text node.
  $isTokenOrSegmented(anchorNode) || // If the text length is more than a single character and we're either
  // dealing with this in "beforeinput" or where the node has already recently
  // been changed (thus is dirty).
  anchorNode.isDirty() && textLength > 1 || // If the DOM selection element is not the same as the backing node during beforeinput.
  (isBeforeInput || !CAN_USE_BEFORE_INPUT) && backingAnchorElement !== null && !anchorNode.isComposing() && domAnchorNode !== getDOMTextNode(backingAnchorElement) || // If TargetRange is not the same as the DOM selection; browser trying to edit random parts
  // of the editor.
  domSelection !== null && domTargetRange !== null && (!domTargetRange.collapsed || domTargetRange.startContainer !== domSelection.anchorNode || domTargetRange.startOffset !== domSelection.anchorOffset) || // Check if we're changing from bold to italics, or some other format.
  anchorNode.getFormat() !== selection.format || anchorNode.getStyle() !== selection.style || // One last set of heuristics to check against.
  $shouldInsertTextAfterOrBeforeTextNode(selection, anchorNode);
}
function shouldSkipSelectionChange(domNode, offset) {
  return isDOMTextNode(domNode) && domNode.nodeValue !== null && offset !== 0 && offset !== domNode.nodeValue.length;
}
function onSelectionChange(domSelection, editor, isActive) {
  const {
    anchorNode: anchorDOM,
    anchorOffset,
    focusNode: focusDOM,
    focusOffset
  } = domSelection;
  if (isSelectionChangeFromDOMUpdate) {
    isSelectionChangeFromDOMUpdate = false;
    if (shouldSkipSelectionChange(anchorDOM, anchorOffset) && shouldSkipSelectionChange(focusDOM, focusOffset) && !postDeleteSelectionToRestore) {
      return;
    }
  }
  updateEditorSync(editor, () => {
    if (!isActive) {
      $setSelection(null);
      return;
    }
    if (!isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {
      return;
    }
    let selection = $getSelection();
    if (postDeleteSelectionToRestore && $isRangeSelection(selection) && selection.isCollapsed()) {
      const curAnchor = selection.anchor;
      const prevAnchor = postDeleteSelectionToRestore.anchor;
      if (
        // Rightward shift in same node
        curAnchor.key === prevAnchor.key && curAnchor.offset === prevAnchor.offset + 1 || // Or rightward shift into sibling node
        curAnchor.offset === 1 && prevAnchor.getNode().is(curAnchor.getNode().getPreviousSibling())
      ) {
        selection = postDeleteSelectionToRestore.clone();
        $setSelection(selection);
      }
    }
    postDeleteSelectionToRestore = null;
    if ($isRangeSelection(selection)) {
      const anchor = selection.anchor;
      const anchorNode = anchor.getNode();
      if (selection.isCollapsed()) {
        if (domSelection.type === "Range" && domSelection.anchorNode === domSelection.focusNode) {
          selection.dirty = true;
        }
        const windowEvent = getWindow(editor).event;
        const currentTimeStamp = windowEvent ? windowEvent.timeStamp : performance.now();
        const [lastFormat, lastStyle, lastOffset, lastKey, timeStamp] = collapsedSelectionFormat;
        const root = $getRoot();
        const isRootTextContentEmpty = editor.isComposing() === false && root.getTextContent() === "";
        if (currentTimeStamp < timeStamp + 200 && anchor.offset === lastOffset && anchor.key === lastKey) {
          $updateSelectionFormatStyle(selection, lastFormat, lastStyle);
        } else {
          if (anchor.type === "text") {
            if (!$isTextNode(anchorNode)) {
              formatDevErrorMessage(`Point.getNode() must return TextNode when type is text`);
            }
            $updateSelectionFormatStyleFromTextNode(selection, anchorNode);
          } else if (anchor.type === "element" && !isRootTextContentEmpty) {
            if (!$isElementNode(anchorNode)) {
              formatDevErrorMessage(`Point.getNode() must return ElementNode when type is element`);
            }
            const lastNode = anchor.getNode();
            if (
              // This previously applied to all ParagraphNode
              lastNode.isEmpty()
            ) {
              $updateSelectionFormatStyleFromElementNode(selection, lastNode);
            } else {
              $updateSelectionFormatStyle(selection, 0, "");
            }
          }
        }
      } else {
        const anchorKey = anchor.key;
        const focus = selection.focus;
        const focusKey = focus.key;
        const nodes = selection.getNodes();
        const nodesLength = nodes.length;
        const isBackward = selection.isBackward();
        const startOffset = isBackward ? focusOffset : anchorOffset;
        const endOffset = isBackward ? anchorOffset : focusOffset;
        const startKey = isBackward ? focusKey : anchorKey;
        const endKey = isBackward ? anchorKey : focusKey;
        let combinedFormat = IS_ALL_FORMATTING;
        let hasTextNodes = false;
        for (let i2 = 0; i2 < nodesLength; i2++) {
          const node = nodes[i2];
          const textContentSize = node.getTextContentSize();
          if ($isTextNode(node) && textContentSize !== 0 && // Exclude empty text nodes at boundaries resulting from user's selection
          !(i2 === 0 && node.__key === startKey && startOffset === textContentSize || i2 === nodesLength - 1 && node.__key === endKey && endOffset === 0)) {
            hasTextNodes = true;
            combinedFormat &= node.getFormat();
            if (combinedFormat === 0) {
              break;
            }
          }
        }
        selection.format = hasTextNodes ? combinedFormat : 0;
      }
    }
    dispatchCommand(editor, SELECTION_CHANGE_COMMAND, void 0);
  });
}
function $updateSelectionFormatStyle(selection, format, style) {
  if (selection.format !== format || selection.style !== style) {
    selection.format = format;
    selection.style = style;
    selection.dirty = true;
  }
}
function $updateSelectionFormatStyleFromTextNode(selection, node) {
  const format = node.getFormat();
  const style = node.getStyle();
  $updateSelectionFormatStyle(selection, format, style);
}
function $updateSelectionFormatStyleFromElementNode(selection, node) {
  const format = node.getTextFormat();
  const style = node.getTextStyle();
  $updateSelectionFormatStyle(selection, format, style);
}
function onClick(event, editor) {
  updateEditorSync(editor, () => {
    const selection = $getSelection();
    const domSelection = getDOMSelection(getWindow(editor));
    const lastSelection = $getPreviousSelection();
    if (domSelection) {
      if ($isRangeSelection(selection)) {
        const anchor = selection.anchor;
        const anchorNode = anchor.getNode();
        if (anchor.type === "element" && anchor.offset === 0 && selection.isCollapsed() && !$isRootNode(anchorNode) && $getRoot().getChildrenSize() === 1 && anchorNode.getTopLevelElementOrThrow().isEmpty() && lastSelection !== null && selection.is(lastSelection)) {
          domSelection.removeAllRanges();
          selection.dirty = true;
        } else if (event.detail === 3 && !selection.isCollapsed()) {
          const focus = selection.focus;
          const focusNode = focus.getNode();
          if (anchorNode !== focusNode) {
            const parentNode = $findMatchingParent(anchorNode, (node) => $isElementNode(node) && !node.isInline());
            if ($isElementNode(parentNode)) {
              parentNode.select(0);
            }
          }
        }
      } else if (event.pointerType === "touch" || event.pointerType === "pen") {
        const domAnchorNode = domSelection.anchorNode;
        if (isHTMLElement(domAnchorNode) || isDOMTextNode(domAnchorNode)) {
          const newSelection = $internalCreateRangeSelection(lastSelection, domSelection, editor, event);
          $setSelection(newSelection);
        }
      }
    }
    dispatchCommand(editor, CLICK_COMMAND, event);
  });
}
function onPointerDown(event, editor) {
  const target = event.target;
  const pointerType = event.pointerType;
  if (isDOMNode(target) && pointerType !== "touch" && pointerType !== "pen" && event.button === 0) {
    updateEditorSync(editor, () => {
      if (!$isSelectionCapturedInDecorator(target)) {
        isSelectionChangeFromMouseDown = true;
      }
    });
  }
}
function getTargetRange(event) {
  if (!event.getTargetRanges) {
    return null;
  }
  const targetRanges = event.getTargetRanges();
  if (targetRanges.length === 0) {
    return null;
  }
  return targetRanges[0];
}
function $canRemoveText(anchorNode, focusNode) {
  return anchorNode !== focusNode || $isElementNode(anchorNode) || $isElementNode(focusNode) || !$isTokenOrTab(anchorNode) || !$isTokenOrTab(focusNode);
}
function isPossiblyAndroidKeyPress(timeStamp) {
  return lastKeyCode === "MediaLast" && timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY;
}
function registerDefaultCommandHandlers(editor) {
  editor.registerCommand(BEFORE_INPUT_COMMAND, $handleBeforeInput, COMMAND_PRIORITY_EDITOR);
  editor.registerCommand(INPUT_COMMAND, $handleInput, COMMAND_PRIORITY_EDITOR);
  editor.registerCommand(COMPOSITION_START_COMMAND, $handleCompositionStart, COMMAND_PRIORITY_EDITOR);
  editor.registerCommand(COMPOSITION_END_COMMAND, $handleCompositionEnd, COMMAND_PRIORITY_EDITOR);
  editor.registerCommand(KEY_DOWN_COMMAND, $handleKeyDown, COMMAND_PRIORITY_EDITOR);
}
function onBeforeInput(event, editor) {
  const inputType = event.inputType;
  if (inputType === "deleteCompositionText" || // If we're pasting in FF, we shouldn't get this event
  // as the `paste` event should have triggered, unless the
  // user has dom.event.clipboardevents.enabled disabled in
  // about:config. In that case, we need to process the
  // pasted content in the DOM mutation phase.
  IS_FIREFOX && isFirefoxClipboardEvents(editor)) {
    return;
  } else if (inputType === "insertCompositionText") {
    return;
  }
  dispatchCommand(editor, BEFORE_INPUT_COMMAND, event);
}
function $handleBeforeInput(event) {
  const inputType = event.inputType;
  const targetRange = getTargetRange(event);
  const editor = getActiveEditor();
  const selection = $getSelection();
  if (inputType === "deleteContentBackward") {
    if (selection === null) {
      const prevSelection = $getPreviousSelection();
      if (!$isRangeSelection(prevSelection)) {
        return true;
      }
      $setSelection(prevSelection.clone());
    }
    if ($isRangeSelection(selection)) {
      const isSelectionAnchorSameAsFocus = selection.anchor.key === selection.focus.key;
      if (isPossiblyAndroidKeyPress(event.timeStamp) && editor.isComposing() && isSelectionAnchorSameAsFocus) {
        $setCompositionKey(null);
        lastKeyDownTimeStamp = 0;
        setTimeout(() => {
          updateEditorSync(editor, () => {
            $setCompositionKey(null);
          });
        }, ANDROID_COMPOSITION_LATENCY);
        if ($isRangeSelection(selection)) {
          const anchorNode2 = selection.anchor.getNode();
          anchorNode2.markDirty();
          if (!$isTextNode(anchorNode2)) {
            formatDevErrorMessage(`Anchor node must be a TextNode`);
          }
          $updateSelectionFormatStyleFromTextNode(selection, anchorNode2);
        }
      } else {
        $setCompositionKey(null);
        event.preventDefault();
        const selectedNode = selection.anchor.getNode();
        const selectedNodeText = selectedNode.getTextContent();
        const selectedNodeCanInsertTextAfter = selectedNode.canInsertTextAfter();
        const hasSelectedAllTextInNode = selection.anchor.offset === 0 && selection.focus.offset === selectedNodeText.length;
        let shouldLetBrowserHandleDelete = IS_ANDROID_CHROME && isSelectionAnchorSameAsFocus && !hasSelectedAllTextInNode && selectedNodeCanInsertTextAfter;
        if (shouldLetBrowserHandleDelete && selection.isCollapsed()) {
          shouldLetBrowserHandleDelete = !$isDecoratorNode($getAdjacentNode(selection.anchor, true));
        }
        if (!shouldLetBrowserHandleDelete) {
          dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);
          const selectionAfterDelete = $getSelection();
          if (IS_ANDROID_CHROME && $isRangeSelection(selectionAfterDelete) && selectionAfterDelete.isCollapsed()) {
            postDeleteSelectionToRestore = selectionAfterDelete;
            setTimeout(() => postDeleteSelectionToRestore = null);
          }
        }
      }
      return true;
    }
  }
  if (!$isRangeSelection(selection)) {
    return true;
  }
  const data = event.data;
  if (unprocessedBeforeInputData !== null) {
    $updateSelectedTextFromDOM(false, editor, unprocessedBeforeInputData);
  }
  if ((!selection.dirty || unprocessedBeforeInputData !== null) && selection.isCollapsed() && !$isRootNode(selection.anchor.getNode()) && targetRange !== null) {
    selection.applyDOMRange(targetRange);
  }
  unprocessedBeforeInputData = null;
  const anchor = selection.anchor;
  const focus = selection.focus;
  const anchorNode = anchor.getNode();
  const focusNode = focus.getNode();
  if (inputType === "insertText" || inputType === "insertTranspose") {
    if (data === "\n") {
      event.preventDefault();
      dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);
    } else if (data === DOUBLE_LINE_BREAK) {
      event.preventDefault();
      dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, void 0);
    } else if (data == null && event.dataTransfer) {
      const text = event.dataTransfer.getData("text/plain");
      event.preventDefault();
      selection.insertRawText(text);
    } else if (data != null && $shouldPreventDefaultAndInsertText(selection, targetRange, data, event.timeStamp, true)) {
      event.preventDefault();
      dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);
    } else {
      unprocessedBeforeInputData = data;
    }
    lastBeforeInputInsertTextTimeStamp = event.timeStamp;
    return true;
  }
  event.preventDefault();
  switch (inputType) {
    case "insertFromYank":
    case "insertFromDrop":
    case "insertReplacementText": {
      dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);
      break;
    }
    case "insertFromComposition": {
      $setCompositionKey(null);
      dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);
      break;
    }
    case "insertLineBreak": {
      $setCompositionKey(null);
      dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);
      break;
    }
    case "insertParagraph": {
      $setCompositionKey(null);
      if (isInsertLineBreak && !IS_IOS) {
        isInsertLineBreak = false;
        dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);
      } else {
        dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, void 0);
      }
      break;
    }
    case "insertFromPaste":
    case "insertFromPasteAsQuotation": {
      dispatchCommand(editor, PASTE_COMMAND, event);
      break;
    }
    case "deleteByComposition": {
      if ($canRemoveText(anchorNode, focusNode)) {
        dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);
      }
      break;
    }
    case "deleteByDrag":
    case "deleteByCut": {
      dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);
      break;
    }
    case "deleteContent": {
      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);
      break;
    }
    case "deleteWordBackward": {
      dispatchCommand(editor, DELETE_WORD_COMMAND, true);
      break;
    }
    case "deleteWordForward": {
      dispatchCommand(editor, DELETE_WORD_COMMAND, false);
      break;
    }
    case "deleteHardLineBackward":
    case "deleteSoftLineBackward": {
      dispatchCommand(editor, DELETE_LINE_COMMAND, true);
      break;
    }
    case "deleteContentForward":
    case "deleteHardLineForward":
    case "deleteSoftLineForward": {
      dispatchCommand(editor, DELETE_LINE_COMMAND, false);
      break;
    }
    case "formatStrikeThrough": {
      dispatchCommand(editor, FORMAT_TEXT_COMMAND, "strikethrough");
      break;
    }
    case "formatBold": {
      dispatchCommand(editor, FORMAT_TEXT_COMMAND, "bold");
      break;
    }
    case "formatItalic": {
      dispatchCommand(editor, FORMAT_TEXT_COMMAND, "italic");
      break;
    }
    case "formatUnderline": {
      dispatchCommand(editor, FORMAT_TEXT_COMMAND, "underline");
      break;
    }
    case "historyUndo": {
      dispatchCommand(editor, UNDO_COMMAND, void 0);
      break;
    }
    case "historyRedo": {
      dispatchCommand(editor, REDO_COMMAND, void 0);
      break;
    }
  }
  return true;
}
function onInput(event, editor) {
  event.stopPropagation();
  updateEditorSync(editor, () => {
    editor.dispatchCommand(INPUT_COMMAND, event);
  }, {
    event
  });
  unprocessedBeforeInputData = null;
}
function $handleInput(event) {
  if (isHTMLElement(event.target) && $isSelectionCapturedInDecorator(event.target)) {
    return true;
  }
  const editor = getActiveEditor();
  const selection = $getSelection();
  const data = event.data;
  const targetRange = getTargetRange(event);
  if (data != null && $isRangeSelection(selection) && $shouldPreventDefaultAndInsertText(selection, targetRange, data, event.timeStamp, false)) {
    if (isFirefoxEndingComposition) {
      $onCompositionEndImpl(editor, data);
      isFirefoxEndingComposition = false;
    }
    const anchor = selection.anchor;
    const anchorNode = anchor.getNode();
    const domSelection = getDOMSelection(getWindow(editor));
    if (domSelection === null) {
      return true;
    }
    const isBackward = selection.isBackward();
    const startOffset = isBackward ? selection.anchor.offset : selection.focus.offset;
    const endOffset = isBackward ? selection.focus.offset : selection.anchor.offset;
    if (!CAN_USE_BEFORE_INPUT || selection.isCollapsed() || !$isTextNode(anchorNode) || domSelection.anchorNode === null || anchorNode.getTextContent().slice(0, startOffset) + data + anchorNode.getTextContent().slice(startOffset + endOffset) !== getAnchorTextFromDOM(domSelection.anchorNode)) {
      dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);
    }
    const textLength = data.length;
    if (IS_FIREFOX && textLength > 1 && event.inputType === "insertCompositionText" && !editor.isComposing()) {
      selection.anchor.offset -= textLength;
    }
    if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT && editor.isComposing()) {
      lastKeyDownTimeStamp = 0;
      $setCompositionKey(null);
    }
  } else {
    const characterData = data !== null ? data : void 0;
    $updateSelectedTextFromDOM(false, editor, characterData);
    if (isFirefoxEndingComposition) {
      $onCompositionEndImpl(editor, data || void 0);
      isFirefoxEndingComposition = false;
    }
  }
  $flushMutations();
  return true;
}
function onCompositionStart(event, editor) {
  dispatchCommand(editor, COMPOSITION_START_COMMAND, event);
}
function $handleCompositionStart(event) {
  const editor = getActiveEditor();
  const selection = $getSelection();
  if ($isRangeSelection(selection) && !editor.isComposing()) {
    const anchor = selection.anchor;
    const node = selection.anchor.getNode();
    $setCompositionKey(anchor.key);
    if (
      // If it has been 30ms since the last keydown, then we should
      // apply the empty space heuristic. We can't do this for Safari,
      // as the keydown fires after composition start.
      event.timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY || // FF has issues around composing multibyte characters, so we also
      // need to invoke the empty space heuristic below.
      anchor.type === "element" || !selection.isCollapsed() || node.getFormat() !== selection.format || $isTextNode(node) && node.getStyle() !== selection.style
    ) {
      dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, COMPOSITION_START_CHAR);
    }
  }
  return true;
}
function $handleCompositionEnd(event) {
  const editor = getActiveEditor();
  $onCompositionEndImpl(editor, event.data);
  return true;
}
function $onCompositionEndImpl(editor, data) {
  const compositionKey = editor._compositionKey;
  $setCompositionKey(null);
  if (compositionKey !== null && data != null) {
    if (data === "") {
      const node = $getNodeByKey(compositionKey);
      const textNode = getDOMTextNode(editor.getElementByKey(compositionKey));
      if (textNode !== null && textNode.nodeValue !== null && $isTextNode(node)) {
        $updateTextNodeFromDOMContent(node, textNode.nodeValue, null, null, true);
      }
      return;
    }
    if (data[data.length - 1] === "\n") {
      const selection = $getSelection();
      if ($isRangeSelection(selection)) {
        const focus = selection.focus;
        selection.anchor.set(focus.key, focus.offset, focus.type);
        dispatchCommand(editor, KEY_ENTER_COMMAND, null);
        return;
      }
    }
  }
  $updateSelectedTextFromDOM(true, editor, data);
}
function onCompositionEnd(event, editor) {
  if (IS_FIREFOX) {
    isFirefoxEndingComposition = true;
  } else if (!IS_IOS && (IS_SAFARI || IS_APPLE_WEBKIT)) {
    isSafariEndingComposition = true;
    safariEndCompositionEventData = event.data;
  } else {
    dispatchCommand(editor, COMPOSITION_END_COMMAND, event);
  }
}
function onKeyDown(event, editor) {
  lastKeyDownTimeStamp = event.timeStamp;
  lastKeyCode = event.key;
  if (editor.isComposing()) {
    return;
  }
  dispatchCommand(editor, KEY_DOWN_COMMAND, event);
}
function $handleKeyDown(event) {
  const editor = getActiveEditor();
  if (event.key == null) {
    return true;
  }
  if (isSafariEndingComposition && isBackspace(event)) {
    updateEditorSync(editor, () => {
      $onCompositionEndImpl(editor, safariEndCompositionEventData);
    });
    isSafariEndingComposition = false;
    safariEndCompositionEventData = "";
    return true;
  }
  if (isMoveForward(event)) {
    dispatchCommand(editor, KEY_ARROW_RIGHT_COMMAND, event);
  } else if (isMoveToEnd(event)) {
    dispatchCommand(editor, MOVE_TO_END, event);
  } else if (isMoveBackward(event)) {
    dispatchCommand(editor, KEY_ARROW_LEFT_COMMAND, event);
  } else if (isMoveToStart(event)) {
    dispatchCommand(editor, MOVE_TO_START, event);
  } else if (isMoveUp(event)) {
    dispatchCommand(editor, KEY_ARROW_UP_COMMAND, event);
  } else if (isMoveDown(event)) {
    dispatchCommand(editor, KEY_ARROW_DOWN_COMMAND, event);
  } else if (isLineBreak(event)) {
    isInsertLineBreak = true;
    dispatchCommand(editor, KEY_ENTER_COMMAND, event);
  } else if (isSpace(event)) {
    dispatchCommand(editor, KEY_SPACE_COMMAND, event);
  } else if (isOpenLineBreak(event)) {
    event.preventDefault();
    isInsertLineBreak = true;
    dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, true);
  } else if (isParagraph(event)) {
    isInsertLineBreak = false;
    dispatchCommand(editor, KEY_ENTER_COMMAND, event);
  } else if (isDeleteBackward(event)) {
    if (isBackspace(event)) {
      dispatchCommand(editor, KEY_BACKSPACE_COMMAND, event);
    } else {
      event.preventDefault();
      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);
    }
  } else if (isEscape(event)) {
    dispatchCommand(editor, KEY_ESCAPE_COMMAND, event);
  } else if (isDeleteForward(event)) {
    if (isDelete(event)) {
      dispatchCommand(editor, KEY_DELETE_COMMAND, event);
    } else {
      event.preventDefault();
      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);
    }
  } else if (isDeleteWordBackward(event)) {
    event.preventDefault();
    dispatchCommand(editor, DELETE_WORD_COMMAND, true);
  } else if (isDeleteWordForward(event)) {
    event.preventDefault();
    dispatchCommand(editor, DELETE_WORD_COMMAND, false);
  } else if (isDeleteLineBackward(event)) {
    event.preventDefault();
    dispatchCommand(editor, DELETE_LINE_COMMAND, true);
  } else if (isDeleteLineForward(event)) {
    event.preventDefault();
    dispatchCommand(editor, DELETE_LINE_COMMAND, false);
  } else if (isBold(event)) {
    event.preventDefault();
    dispatchCommand(editor, FORMAT_TEXT_COMMAND, "bold");
  } else if (isUnderline(event)) {
    event.preventDefault();
    dispatchCommand(editor, FORMAT_TEXT_COMMAND, "underline");
  } else if (isItalic(event)) {
    event.preventDefault();
    dispatchCommand(editor, FORMAT_TEXT_COMMAND, "italic");
  } else if (isTab(event)) {
    dispatchCommand(editor, KEY_TAB_COMMAND, event);
  } else if (isUndo(event)) {
    event.preventDefault();
    dispatchCommand(editor, UNDO_COMMAND, void 0);
  } else if (isRedo(event)) {
    event.preventDefault();
    dispatchCommand(editor, REDO_COMMAND, void 0);
  } else {
    const prevSelection = editor._editorState._selection;
    if (prevSelection !== null && !$isRangeSelection(prevSelection)) {
      if (isCopy(event)) {
        event.preventDefault();
        dispatchCommand(editor, COPY_COMMAND, event);
      } else if (isCut(event)) {
        event.preventDefault();
        dispatchCommand(editor, CUT_COMMAND, event);
      } else if (isSelectAll(event)) {
        event.preventDefault();
        dispatchCommand(editor, SELECT_ALL_COMMAND, event);
      }
    } else if (isSelectAll(event)) {
      event.preventDefault();
      dispatchCommand(editor, SELECT_ALL_COMMAND, event);
    }
  }
  if (isModifier(event)) {
    editor.dispatchCommand(KEY_MODIFIER_COMMAND, event);
  }
  return true;
}
function getRootElementRemoveHandles(rootElement) {
  let eventHandles = rootElement.__lexicalEventHandles;
  if (eventHandles === void 0) {
    eventHandles = [];
    rootElement.__lexicalEventHandles = eventHandles;
  }
  return eventHandles;
}
var activeNestedEditorsMap = /* @__PURE__ */ new Map();
function onDocumentSelectionChange(event) {
  const domSelection = getDOMSelectionFromTarget(event.target);
  if (domSelection === null) {
    return;
  }
  const nextActiveEditor = getNearestEditorFromDOMNode(domSelection.anchorNode);
  if (nextActiveEditor === null) {
    return;
  }
  if (isSelectionChangeFromMouseDown) {
    isSelectionChangeFromMouseDown = false;
    updateEditorSync(nextActiveEditor, () => {
      const lastSelection = $getPreviousSelection();
      const domAnchorNode = domSelection.anchorNode;
      if (isHTMLElement(domAnchorNode) || isDOMTextNode(domAnchorNode)) {
        const newSelection = $internalCreateRangeSelection(lastSelection, domSelection, nextActiveEditor, event);
        $setSelection(newSelection);
      }
    });
  }
  const editors = getEditorsToPropagate(nextActiveEditor);
  const rootEditor = editors[editors.length - 1];
  const rootEditorKey = rootEditor._key;
  const activeNestedEditor = activeNestedEditorsMap.get(rootEditorKey);
  const prevActiveEditor = activeNestedEditor || rootEditor;
  if (prevActiveEditor !== nextActiveEditor) {
    onSelectionChange(domSelection, prevActiveEditor, false);
  }
  onSelectionChange(domSelection, nextActiveEditor, true);
  if (nextActiveEditor !== rootEditor) {
    activeNestedEditorsMap.set(rootEditorKey, nextActiveEditor);
  } else if (activeNestedEditor) {
    activeNestedEditorsMap.delete(rootEditorKey);
  }
}
function stopLexicalPropagation(event) {
  event._lexicalHandled = true;
}
function hasStoppedLexicalPropagation(event) {
  const stopped = event._lexicalHandled === true;
  return stopped;
}
function addRootElementEvents(rootElement, editor) {
  const doc = rootElement.ownerDocument;
  rootElementToDocument.set(rootElement, doc);
  const documentRootElementsCount = rootElementsRegistered.get(doc) ?? 0;
  if (documentRootElementsCount < 1) {
    doc.addEventListener("selectionchange", onDocumentSelectionChange);
  }
  rootElementsRegistered.set(doc, documentRootElementsCount + 1);
  rootElement.__lexicalEditor = editor;
  const removeHandles = getRootElementRemoveHandles(rootElement);
  for (let i2 = 0; i2 < rootElementEvents.length; i2++) {
    const [eventName, onEvent] = rootElementEvents[i2];
    const eventHandler = typeof onEvent === "function" ? (event) => {
      if (hasStoppedLexicalPropagation(event)) {
        return;
      }
      stopLexicalPropagation(event);
      if (editor.isEditable() || eventName === "click") {
        onEvent(event, editor);
      }
    } : (event) => {
      if (hasStoppedLexicalPropagation(event)) {
        return;
      }
      stopLexicalPropagation(event);
      const isEditable = editor.isEditable();
      switch (eventName) {
        case "cut":
          return isEditable && dispatchCommand(editor, CUT_COMMAND, event);
        case "copy":
          return dispatchCommand(editor, COPY_COMMAND, event);
        case "paste":
          return isEditable && dispatchCommand(editor, PASTE_COMMAND, event);
        case "dragstart":
          return isEditable && dispatchCommand(editor, DRAGSTART_COMMAND, event);
        case "dragover":
          return isEditable && dispatchCommand(editor, DRAGOVER_COMMAND, event);
        case "dragend":
          return isEditable && dispatchCommand(editor, DRAGEND_COMMAND, event);
        case "focus":
          return isEditable && dispatchCommand(editor, FOCUS_COMMAND, event);
        case "blur": {
          return isEditable && dispatchCommand(editor, BLUR_COMMAND, event);
        }
        case "drop":
          return isEditable && dispatchCommand(editor, DROP_COMMAND, event);
      }
    };
    rootElement.addEventListener(eventName, eventHandler);
    removeHandles.push(() => {
      rootElement.removeEventListener(eventName, eventHandler);
    });
  }
}
var rootElementNotRegisteredWarning = warnOnlyOnce("Root element not registered");
function removeRootElementEvents(rootElement) {
  const doc = rootElementToDocument.get(rootElement);
  if (doc === void 0) {
    rootElementNotRegisteredWarning();
    return;
  }
  const documentRootElementsCount = rootElementsRegistered.get(doc);
  if (documentRootElementsCount === void 0) {
    rootElementNotRegisteredWarning();
    return;
  }
  const newCount = documentRootElementsCount - 1;
  if (!(newCount >= 0)) {
    formatDevErrorMessage(`Root element count less than 0`);
  }
  rootElementToDocument.delete(rootElement);
  rootElementsRegistered.set(doc, newCount);
  if (newCount === 0) {
    doc.removeEventListener("selectionchange", onDocumentSelectionChange);
  }
  const editor = getEditorPropertyFromDOMNode(rootElement);
  if (isLexicalEditor(editor)) {
    cleanActiveNestedEditorsMap(editor);
    rootElement.__lexicalEditor = null;
  } else if (editor) {
    {
      formatDevErrorMessage(`Attempted to remove event handlers from a node that does not belong to this build of Lexical`);
    }
  }
  const removeHandles = getRootElementRemoveHandles(rootElement);
  for (let i2 = 0; i2 < removeHandles.length; i2++) {
    removeHandles[i2]();
  }
  rootElement.__lexicalEventHandles = [];
}
function cleanActiveNestedEditorsMap(editor) {
  if (editor._parentEditor !== null) {
    const editors = getEditorsToPropagate(editor);
    const rootEditor = editors[editors.length - 1];
    const rootEditorKey = rootEditor._key;
    if (activeNestedEditorsMap.get(rootEditorKey) === editor) {
      activeNestedEditorsMap.delete(rootEditorKey);
    }
  } else {
    activeNestedEditorsMap.delete(editor._key);
  }
}
function markSelectionChangeFromDOMUpdate() {
  isSelectionChangeFromDOMUpdate = true;
}
function markCollapsedSelectionFormat(format, style, offset, key, timeStamp) {
  collapsedSelectionFormat = [format, style, offset, key, timeStamp];
}
function $removeNode(nodeToRemove, restoreSelection, preserveEmptyParent) {
  errorOnReadOnly();
  const key = nodeToRemove.__key;
  const parent = nodeToRemove.getParent();
  if (parent === null) {
    return;
  }
  const selection = $maybeMoveChildrenSelectionToParent(nodeToRemove);
  let selectionMoved = false;
  if ($isRangeSelection(selection) && restoreSelection) {
    const anchor = selection.anchor;
    const focus = selection.focus;
    if (anchor.key === key) {
      moveSelectionPointToSibling(anchor, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());
      selectionMoved = true;
    }
    if (focus.key === key) {
      moveSelectionPointToSibling(focus, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());
      selectionMoved = true;
    }
  } else if ($isNodeSelection(selection) && restoreSelection && nodeToRemove.isSelected()) {
    nodeToRemove.selectPrevious();
  }
  if ($isRangeSelection(selection) && restoreSelection && !selectionMoved) {
    const index = nodeToRemove.getIndexWithinParent();
    removeFromParent(nodeToRemove);
    $updateElementSelectionOnCreateDeleteNode(selection, parent, index, -1);
  } else {
    removeFromParent(nodeToRemove);
  }
  if (!preserveEmptyParent && !$isRootOrShadowRoot(parent) && !parent.canBeEmpty() && parent.isEmpty()) {
    $removeNode(parent, restoreSelection);
  }
  if (restoreSelection && selection && $isRootNode(parent) && parent.isEmpty()) {
    parent.selectEnd();
  }
}
function buildImportMap(importMap) {
  return importMap;
}
var EPHEMERAL = Symbol.for("ephemeral");
function $isEphemeral(node) {
  return node[EPHEMERAL] || false;
}
function $markEphemeral(node) {
  node[EPHEMERAL] = true;
  return node;
}
var LexicalNode = class {
  constructor(key) {
    /** @internal Allow us to look up the type including static props */
    /** @internal */
    __publicField(this, "__type");
    /** @internal */
    //@ts-ignore We set the key in the constructor.
    __publicField(this, "__key");
    /** @internal */
    __publicField(this, "__parent");
    /** @internal */
    __publicField(this, "__prev");
    /** @internal */
    __publicField(this, "__next");
    /** @internal */
    __publicField(this, "__state");
    this.__type = this.constructor.getType();
    this.__parent = null;
    this.__prev = null;
    this.__next = null;
    Object.defineProperty(this, "__state", {
      configurable: true,
      enumerable: false,
      value: void 0,
      writable: true
    });
    $setNodeKey(this, key);
    {
      if (this.__type !== "root") {
        errorOnTypeKlassMismatch(this.__type, this.constructor);
      }
    }
  }
  // Flow doesn't support abstract classes unfortunately, so we can't _force_
  // subclasses of Node to implement statics. All subclasses of Node should have
  // a static getType and clone method though. We define getType and clone here so we can call it
  // on any  Node, and we throw this error by default since the subclass should provide
  // their own implementation.
  /**
   * Returns the string type of this node. Every node must
   * implement this and it MUST BE UNIQUE amongst nodes registered
   * on the editor.
   *
   */
  static getType() {
    const {
      ownNodeType
    } = getStaticNodeConfig(this);
    if (!(ownNodeType !== void 0)) {
      formatDevErrorMessage(`LexicalNode: Node ${this.name} does not implement .getType().`);
    }
    return ownNodeType;
  }
  /**
   * Clones this node, creating a new node with a different key
   * and adding it to the EditorState (but not attaching it anywhere!). All nodes must
   * implement this method.
   *
   */
  static clone(_data) {
    {
      formatDevErrorMessage(`LexicalNode: Node ${this.name} does not implement .clone().`);
    }
  }
  /**
   * Override this to implement the new static node configuration protocol,
   * this method is called directly on the prototype and must not depend
   * on anything initialized in the constructor. Generally it should be
   * a trivial implementation.
   *
   * @example
   * ```ts
   * class MyNode extends TextNode {
   *   $config() {
   *     return this.config('my-node', {extends: TextNode});
   *   }
   * }
   * ```
   */
  $config() {
    return {};
  }
  /**
   * This is a convenience method for $config that
   * aids in type inference. See {@link LexicalNode.$config}
   * for example usage.
   */
  config(type, config) {
    const parentKlass = config.extends || Object.getPrototypeOf(this.constructor);
    Object.assign(config, {
      extends: parentKlass,
      type
    });
    return {
      [type]: config
    };
  }
  /**
   * Perform any state updates on the clone of prevNode that are not already
   * handled by the constructor call in the static clone method. If you have
   * state to update in your clone that is not handled directly by the
   * constructor, it is advisable to override this method but it is required
   * to include a call to `super.afterCloneFrom(prevNode)` in your
   * implementation. This is only intended to be called by
   * {@link $cloneWithProperties} function or via a super call.
   *
   * @example
   * ```ts
   * class ClassesTextNode extends TextNode {
   *   // Not shown: static getType, static importJSON, exportJSON, createDOM, updateDOM
   *   __classes = new Set<string>();
   *   static clone(node: ClassesTextNode): ClassesTextNode {
   *     // The inherited TextNode constructor is used here, so
   *     // classes is not set by this method.
   *     return new ClassesTextNode(node.__text, node.__key);
   *   }
   *   afterCloneFrom(node: this): void {
   *     // This calls TextNode.afterCloneFrom and LexicalNode.afterCloneFrom
   *     // for necessary state updates
   *     super.afterCloneFrom(node);
   *     this.__addClasses(node.__classes);
   *   }
   *   // This method is a private implementation detail, it is not
   *   // suitable for the public API because it does not call getWritable
   *   __addClasses(classNames: Iterable<string>): this {
   *     for (const className of classNames) {
   *       this.__classes.add(className);
   *     }
   *     return this;
   *   }
   *   addClass(...classNames: string[]): this {
   *     return this.getWritable().__addClasses(classNames);
   *   }
   *   removeClass(...classNames: string[]): this {
   *     const node = this.getWritable();
   *     for (const className of classNames) {
   *       this.__classes.delete(className);
   *     }
   *     return this;
   *   }
   *   getClasses(): Set<string> {
   *     return this.getLatest().__classes;
   *   }
   * }
   * ```
   *
   */
  afterCloneFrom(prevNode) {
    if (this.__key === prevNode.__key) {
      this.__parent = prevNode.__parent;
      this.__next = prevNode.__next;
      this.__prev = prevNode.__prev;
      this.__state = prevNode.__state;
    } else if (prevNode.__state) {
      this.__state = prevNode.__state.getWritable(this);
    }
  }
  // Getters and Traversers
  /**
   * Returns the string type of this node.
   */
  getType() {
    return this.__type;
  }
  isInline() {
    {
      formatDevErrorMessage(`LexicalNode: Node ${this.constructor.name} does not implement .isInline().`);
    }
  }
  /**
   * Returns true if there is a path between this node and the RootNode, false otherwise.
   * This is a way of determining if the node is "attached" EditorState. Unattached nodes
   * won't be reconciled and will ultimately be cleaned up by the Lexical GC.
   */
  isAttached() {
    let nodeKey = this.__key;
    while (nodeKey !== null) {
      if (nodeKey === "root") {
        return true;
      }
      const node = $getNodeByKey(nodeKey);
      if (node === null) {
        break;
      }
      nodeKey = node.__parent;
    }
    return false;
  }
  /**
   * Returns true if this node is contained within the provided Selection., false otherwise.
   * Relies on the algorithms implemented in {@link BaseSelection.getNodes} to determine
   * what's included.
   *
   * @param selection - The selection that we want to determine if the node is in.
   */
  isSelected(selection) {
    const targetSelection = selection || $getSelection();
    if (targetSelection == null) {
      return false;
    }
    const isSelected = targetSelection.getNodes().some((n2) => n2.__key === this.__key);
    if ($isTextNode(this)) {
      return isSelected;
    }
    const isElementRangeSelection = $isRangeSelection(targetSelection) && targetSelection.anchor.type === "element" && targetSelection.focus.type === "element";
    if (isElementRangeSelection) {
      if (targetSelection.isCollapsed()) {
        return false;
      }
      const parentNode = this.getParent();
      if ($isDecoratorNode(this) && this.isInline() && parentNode) {
        const firstPoint = targetSelection.isBackward() ? targetSelection.focus : targetSelection.anchor;
        if (parentNode.is(firstPoint.getNode()) && firstPoint.offset === parentNode.getChildrenSize() && this.is(parentNode.getLastChild())) {
          return false;
        }
      }
    }
    return isSelected;
  }
  /**
   * Returns this nodes key.
   */
  getKey() {
    return this.__key;
  }
  /**
   * Returns the zero-based index of this node within the parent.
   */
  getIndexWithinParent() {
    const parent = this.getParent();
    if (parent === null) {
      return -1;
    }
    let node = parent.getFirstChild();
    let index = 0;
    while (node !== null) {
      if (this.is(node)) {
        return index;
      }
      index++;
      node = node.getNextSibling();
    }
    return -1;
  }
  /**
   * Returns the parent of this node, or null if none is found.
   */
  getParent() {
    const parent = this.getLatest().__parent;
    if (parent === null) {
      return null;
    }
    return $getNodeByKey(parent);
  }
  /**
   * Returns the parent of this node, or throws if none is found.
   */
  getParentOrThrow() {
    const parent = this.getParent();
    if (parent === null) {
      {
        formatDevErrorMessage(`Expected node ${this.__key} to have a parent.`);
      }
    }
    return parent;
  }
  /**
   * Returns the highest (in the EditorState tree)
   * non-root ancestor of this node, or null if none is found. See {@link lexical!$isRootOrShadowRoot}
   * for more information on which Elements comprise "roots".
   */
  getTopLevelElement() {
    let node = this;
    while (node !== null) {
      const parent = node.getParent();
      if ($isRootOrShadowRoot(parent)) {
        if (!($isElementNode(node) || node === this && $isDecoratorNode(node))) {
          formatDevErrorMessage(`Children of root nodes must be elements or decorators`);
        }
        return node;
      }
      node = parent;
    }
    return null;
  }
  /**
   * Returns the highest (in the EditorState tree)
   * non-root ancestor of this node, or throws if none is found. See {@link lexical!$isRootOrShadowRoot}
   * for more information on which Elements comprise "roots".
   */
  getTopLevelElementOrThrow() {
    const parent = this.getTopLevelElement();
    if (parent === null) {
      {
        formatDevErrorMessage(`Expected node ${this.__key} to have a top parent element.`);
      }
    }
    return parent;
  }
  /**
   * Returns a list of the every ancestor of this node,
   * all the way up to the RootNode.
   *
   */
  getParents() {
    const parents = [];
    let node = this.getParent();
    while (node !== null) {
      parents.push(node);
      node = node.getParent();
    }
    return parents;
  }
  /**
   * Returns a list of the keys of every ancestor of this node,
   * all the way up to the RootNode.
   *
   */
  getParentKeys() {
    const parents = [];
    let node = this.getParent();
    while (node !== null) {
      parents.push(node.__key);
      node = node.getParent();
    }
    return parents;
  }
  /**
   * Returns the "previous" siblings - that is, the node that comes
   * before this one in the same parent.
   *
   */
  getPreviousSibling() {
    const self2 = this.getLatest();
    const prevKey = self2.__prev;
    return prevKey === null ? null : $getNodeByKey(prevKey);
  }
  /**
   * Returns the "previous" siblings - that is, the nodes that come between
   * this one and the first child of it's parent, inclusive.
   *
   */
  getPreviousSiblings() {
    const siblings = [];
    const parent = this.getParent();
    if (parent === null) {
      return siblings;
    }
    let node = parent.getFirstChild();
    while (node !== null) {
      if (node.is(this)) {
        break;
      }
      siblings.push(node);
      node = node.getNextSibling();
    }
    return siblings;
  }
  /**
   * Returns the "next" siblings - that is, the node that comes
   * after this one in the same parent
   *
   */
  getNextSibling() {
    const self2 = this.getLatest();
    const nextKey = self2.__next;
    return nextKey === null ? null : $getNodeByKey(nextKey);
  }
  /**
   * Returns all "next" siblings - that is, the nodes that come between this
   * one and the last child of it's parent, inclusive.
   *
   */
  getNextSiblings() {
    const siblings = [];
    let node = this.getNextSibling();
    while (node !== null) {
      siblings.push(node);
      node = node.getNextSibling();
    }
    return siblings;
  }
  /**
   * @deprecated use {@link $getCommonAncestor}
   *
   * Returns the closest common ancestor of this node and the provided one or null
   * if one cannot be found.
   *
   * @param node - the other node to find the common ancestor of.
   */
  getCommonAncestor(node) {
    const a2 = $isElementNode(this) ? this : this.getParent();
    const b2 = $isElementNode(node) ? node : node.getParent();
    const result = a2 && b2 ? $getCommonAncestor(a2, b2) : null;
    return result ? result.commonAncestor : null;
  }
  /**
   * Returns true if the provided node is the exact same one as this node, from Lexical's perspective.
   * Always use this instead of referential equality.
   *
   * @param object - the node to perform the equality comparison on.
   */
  is(object) {
    if (object == null) {
      return false;
    }
    return this.__key === object.__key;
  }
  /**
   * Returns true if this node logically precedes the target node in the
   * editor state, false otherwise (including if there is no common ancestor).
   *
   * Note that this notion of isBefore is based on post-order; a descendant
   * node is always before its ancestors. See also
   * {@link $getCommonAncestor} and {@link $comparePointCaretNext} for
   * more flexible ways to determine the relative positions of nodes.
   *
   * @param targetNode - the node we're testing to see if it's after this one.
   */
  isBefore(targetNode) {
    const compare = $getCommonAncestor(this, targetNode);
    if (compare === null) {
      return false;
    }
    if (compare.type === "descendant") {
      return true;
    }
    if (compare.type === "branch") {
      return $getCommonAncestorResultBranchOrder(compare) === -1;
    }
    if (!(compare.type === "same" || compare.type === "ancestor")) {
      formatDevErrorMessage(`LexicalNode.isBefore: exhaustiveness check`);
    }
    return false;
  }
  /**
   * Returns true if this node is an ancestor of and distinct from the target node, false otherwise.
   *
   * @param targetNode - the would-be child node.
   */
  isParentOf(targetNode) {
    const result = $getCommonAncestor(this, targetNode);
    return result !== null && result.type === "ancestor";
  }
  // TO-DO: this function can be simplified a lot
  /**
   * Returns a list of nodes that are between this node and
   * the target node in the EditorState.
   *
   * @param targetNode - the node that marks the other end of the range of nodes to be returned.
   */
  getNodesBetween(targetNode) {
    const isBefore = this.isBefore(targetNode);
    const nodes = [];
    const visited = /* @__PURE__ */ new Set();
    let node = this;
    while (true) {
      if (node === null) {
        break;
      }
      const key = node.__key;
      if (!visited.has(key)) {
        visited.add(key);
        nodes.push(node);
      }
      if (node === targetNode) {
        break;
      }
      const child = $isElementNode(node) ? isBefore ? node.getFirstChild() : node.getLastChild() : null;
      if (child !== null) {
        node = child;
        continue;
      }
      const nextSibling = isBefore ? node.getNextSibling() : node.getPreviousSibling();
      if (nextSibling !== null) {
        node = nextSibling;
        continue;
      }
      const parent = node.getParentOrThrow();
      if (!visited.has(parent.__key)) {
        nodes.push(parent);
      }
      if (parent === targetNode) {
        break;
      }
      let parentSibling = null;
      let ancestor = parent;
      do {
        if (ancestor === null) {
          {
            formatDevErrorMessage(`getNodesBetween: ancestor is null`);
          }
        }
        parentSibling = isBefore ? ancestor.getNextSibling() : ancestor.getPreviousSibling();
        ancestor = ancestor.getParent();
        if (ancestor !== null) {
          if (parentSibling === null && !visited.has(ancestor.__key)) {
            nodes.push(ancestor);
          }
        } else {
          break;
        }
      } while (parentSibling === null);
      node = parentSibling;
    }
    if (!isBefore) {
      nodes.reverse();
    }
    return nodes;
  }
  /**
   * Returns true if this node has been marked dirty during this update cycle.
   *
   */
  isDirty() {
    const editor = getActiveEditor();
    const dirtyLeaves = editor._dirtyLeaves;
    return dirtyLeaves !== null && dirtyLeaves.has(this.__key);
  }
  /**
   * Returns the latest version of the node from the active EditorState.
   * This is used to avoid getting values from stale node references.
   *
   */
  getLatest() {
    if ($isEphemeral(this)) {
      return this;
    }
    const latest = $getNodeByKey(this.__key);
    if (latest === null) {
      {
        formatDevErrorMessage(`Lexical node does not exist in active editor state. Avoid using the same node references between nested closures from editorState.read/editor.update.`);
      }
    }
    return latest;
  }
  /**
   * Returns a mutable version of the node using {@link $cloneWithProperties}
   * if necessary. Will throw an error if called outside of a Lexical Editor
   * {@link LexicalEditor.update} callback.
   *
   */
  getWritable() {
    if ($isEphemeral(this)) {
      return this;
    }
    errorOnReadOnly();
    const editorState = getActiveEditorState();
    const editor = getActiveEditor();
    const nodeMap = editorState._nodeMap;
    const key = this.__key;
    const latestNode = this.getLatest();
    const cloneNotNeeded = editor._cloneNotNeeded;
    const selection = $getSelection();
    if (selection !== null) {
      selection.setCachedNodes(null);
    }
    if (cloneNotNeeded.has(key)) {
      internalMarkNodeAsDirty(latestNode);
      return latestNode;
    }
    const mutableNode = $cloneWithProperties(latestNode);
    cloneNotNeeded.add(key);
    internalMarkNodeAsDirty(mutableNode);
    nodeMap.set(key, mutableNode);
    return mutableNode;
  }
  /**
   * Returns the text content of the node. Override this for
   * custom nodes that should have a representation in plain text
   * format (for copy + paste, for example)
   *
   */
  getTextContent() {
    return "";
  }
  /**
   * Returns the length of the string produced by calling getTextContent on this node.
   *
   */
  getTextContentSize() {
    return this.getTextContent().length;
  }
  // View
  /**
   * Called during the reconciliation process to determine which nodes
   * to insert into the DOM for this Lexical Node.
   *
   * This method must return exactly one HTMLElement. Nested elements are not supported.
   *
   * Do not attempt to update the Lexical EditorState during this phase of the update lifecycle.
   *
   * @param _config - allows access to things like the EditorTheme (to apply classes) during reconciliation.
   * @param _editor - allows access to the editor for context during reconciliation.
   *
   * */
  createDOM(_config, _editor) {
    {
      formatDevErrorMessage(`createDOM: base method not extended`);
    }
  }
  /**
   * Called when a node changes and should update the DOM
   * in whatever way is necessary to make it align with any changes that might
   * have happened during the update.
   *
   * Returning "true" here will cause lexical to unmount and recreate the DOM node
   * (by calling createDOM). You would need to do this if the element tag changes,
   * for instance.
   *
   * */
  updateDOM(_prevNode, _dom, _config) {
    {
      formatDevErrorMessage(`updateDOM: base method not extended`);
    }
  }
  /**
   * Controls how the this node is serialized to HTML. This is important for
   * copy and paste between Lexical and non-Lexical editors, or Lexical editors with different namespaces,
   * in which case the primary transfer format is HTML. It's also important if you're serializing
   * to HTML for any other reason via {@link @lexical/html!$generateHtmlFromNodes}. You could
   * also use this method to build your own HTML renderer.
   *
   * */
  exportDOM(editor) {
    const element = this.createDOM(editor._config, editor);
    return {
      element
    };
  }
  /**
   * Controls how the this node is serialized to JSON. This is important for
   * copy and paste between Lexical editors sharing the same namespace. It's also important
   * if you're serializing to JSON for persistent storage somewhere.
   * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).
   *
   * */
  exportJSON() {
    const state = this.__state ? this.__state.toJSON() : void 0;
    return {
      type: this.__type,
      version: 1,
      ...state
    };
  }
  /**
   * Controls how the this node is deserialized from JSON. This is usually boilerplate,
   * but provides an abstraction between the node implementation and serialized interface that can
   * be important if you ever make breaking changes to a node schema (by adding or removing properties).
   * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).
   *
   * */
  static importJSON(_serializedNode) {
    {
      formatDevErrorMessage(`LexicalNode: Node ${this.name} does not implement .importJSON().`);
    }
  }
  /**
   * Update this LexicalNode instance from serialized JSON. It's recommended
   * to implement as much logic as possible in this method instead of the
   * static importJSON method, so that the functionality can be inherited in subclasses.
   *
   * The LexicalUpdateJSON utility type should be used to ignore any type, version,
   * or children properties in the JSON so that the extended JSON from subclasses
   * are acceptable parameters for the super call.
   *
   * If overridden, this method must call super.
   *
   * @example
   * ```ts
   * class MyTextNode extends TextNode {
   *   // ...
   *   static importJSON(serializedNode: SerializedMyTextNode): MyTextNode {
   *     return $createMyTextNode()
   *       .updateFromJSON(serializedNode);
   *   }
   *   updateFromJSON(
   *     serializedNode: LexicalUpdateJSON<SerializedMyTextNode>,
   *   ): this {
   *     return super.updateFromJSON(serializedNode)
   *       .setMyProperty(serializedNode.myProperty);
   *   }
   * }
   * ```
   **/
  updateFromJSON(serializedNode) {
    return $updateStateFromJSON(this, serializedNode);
  }
  /**
   * @experimental
   *
   * Registers the returned function as a transform on the node during
   * Editor initialization. Most such use cases should be addressed via
   * the {@link LexicalEditor.registerNodeTransform} API.
   *
   * Experimental - use at your own risk.
   */
  static transform() {
    return null;
  }
  // Setters and mutators
  /**
   * Removes this LexicalNode from the EditorState. If the node isn't re-inserted
   * somewhere, the Lexical garbage collector will eventually clean it up.
   *
   * @param preserveEmptyParent - If falsy, the node's parent will be removed if
   * it's empty after the removal operation. This is the default behavior, subject to
   * other node heuristics such as {@link ElementNode#canBeEmpty}
   * */
  remove(preserveEmptyParent) {
    $removeNode(this, true, preserveEmptyParent);
  }
  /**
   * Replaces this LexicalNode with the provided node, optionally transferring the children
   * of the replaced node to the replacing node.
   *
   * @param replaceWith - The node to replace this one with.
   * @param includeChildren - Whether or not to transfer the children of this node to the replacing node.
   * */
  replace(replaceWith, includeChildren) {
    errorOnReadOnly();
    let selection = $getSelection();
    if (selection !== null) {
      selection = selection.clone();
    }
    errorOnInsertTextNodeOnRoot(this, replaceWith);
    const self2 = this.getLatest();
    const toReplaceKey = this.__key;
    const key = replaceWith.__key;
    const writableReplaceWith = replaceWith.getWritable();
    const writableParent = this.getParentOrThrow().getWritable();
    const size = writableParent.__size;
    removeFromParent(writableReplaceWith);
    const prevSibling = self2.getPreviousSibling();
    const nextSibling = self2.getNextSibling();
    const prevKey = self2.__prev;
    const nextKey = self2.__next;
    const parentKey = self2.__parent;
    $removeNode(self2, false, true);
    if (prevSibling === null) {
      writableParent.__first = key;
    } else {
      const writablePrevSibling = prevSibling.getWritable();
      writablePrevSibling.__next = key;
    }
    writableReplaceWith.__prev = prevKey;
    if (nextSibling === null) {
      writableParent.__last = key;
    } else {
      const writableNextSibling = nextSibling.getWritable();
      writableNextSibling.__prev = key;
    }
    writableReplaceWith.__next = nextKey;
    writableReplaceWith.__parent = parentKey;
    writableParent.__size = size;
    if (includeChildren) {
      if (!($isElementNode(this) && $isElementNode(writableReplaceWith))) {
        formatDevErrorMessage(`includeChildren should only be true for ElementNodes`);
      }
      this.getChildren().forEach((child) => {
        writableReplaceWith.append(child);
      });
    }
    if ($isRangeSelection(selection)) {
      $setSelection(selection);
      const anchor = selection.anchor;
      const focus = selection.focus;
      if (anchor.key === toReplaceKey) {
        $moveSelectionPointToEnd(anchor, writableReplaceWith);
      }
      if (focus.key === toReplaceKey) {
        $moveSelectionPointToEnd(focus, writableReplaceWith);
      }
    }
    if ($getCompositionKey() === toReplaceKey) {
      $setCompositionKey(key);
    }
    return writableReplaceWith;
  }
  /**
   * Inserts a node after this LexicalNode (as the next sibling).
   *
   * @param nodeToInsert - The node to insert after this one.
   * @param restoreSelection - Whether or not to attempt to resolve the
   * selection to the appropriate place after the operation is complete.
   * */
  insertAfter(nodeToInsert, restoreSelection = true) {
    errorOnReadOnly();
    errorOnInsertTextNodeOnRoot(this, nodeToInsert);
    const writableSelf = this.getWritable();
    const writableNodeToInsert = nodeToInsert.getWritable();
    const oldParent = writableNodeToInsert.getParent();
    const selection = $getSelection();
    let elementAnchorSelectionOnNode = false;
    let elementFocusSelectionOnNode = false;
    if (oldParent !== null) {
      const oldIndex = nodeToInsert.getIndexWithinParent();
      removeFromParent(writableNodeToInsert);
      if ($isRangeSelection(selection)) {
        const oldParentKey = oldParent.__key;
        const anchor = selection.anchor;
        const focus = selection.focus;
        elementAnchorSelectionOnNode = anchor.type === "element" && anchor.key === oldParentKey && anchor.offset === oldIndex + 1;
        elementFocusSelectionOnNode = focus.type === "element" && focus.key === oldParentKey && focus.offset === oldIndex + 1;
      }
    }
    const nextSibling = this.getNextSibling();
    const writableParent = this.getParentOrThrow().getWritable();
    const insertKey = writableNodeToInsert.__key;
    const nextKey = writableSelf.__next;
    if (nextSibling === null) {
      writableParent.__last = insertKey;
    } else {
      const writableNextSibling = nextSibling.getWritable();
      writableNextSibling.__prev = insertKey;
    }
    writableParent.__size++;
    writableSelf.__next = insertKey;
    writableNodeToInsert.__next = nextKey;
    writableNodeToInsert.__prev = writableSelf.__key;
    writableNodeToInsert.__parent = writableSelf.__parent;
    if (restoreSelection && $isRangeSelection(selection)) {
      const index = this.getIndexWithinParent();
      $updateElementSelectionOnCreateDeleteNode(selection, writableParent, index + 1);
      const writableParentKey = writableParent.__key;
      if (elementAnchorSelectionOnNode) {
        selection.anchor.set(writableParentKey, index + 2, "element");
      }
      if (elementFocusSelectionOnNode) {
        selection.focus.set(writableParentKey, index + 2, "element");
      }
    }
    return nodeToInsert;
  }
  /**
   * Inserts a node before this LexicalNode (as the previous sibling).
   *
   * @param nodeToInsert - The node to insert before this one.
   * @param restoreSelection - Whether or not to attempt to resolve the
   * selection to the appropriate place after the operation is complete.
   * */
  insertBefore(nodeToInsert, restoreSelection = true) {
    errorOnReadOnly();
    errorOnInsertTextNodeOnRoot(this, nodeToInsert);
    const writableSelf = this.getWritable();
    const writableNodeToInsert = nodeToInsert.getWritable();
    const insertKey = writableNodeToInsert.__key;
    removeFromParent(writableNodeToInsert);
    const prevSibling = this.getPreviousSibling();
    const writableParent = this.getParentOrThrow().getWritable();
    const prevKey = writableSelf.__prev;
    const index = this.getIndexWithinParent();
    if (prevSibling === null) {
      writableParent.__first = insertKey;
    } else {
      const writablePrevSibling = prevSibling.getWritable();
      writablePrevSibling.__next = insertKey;
    }
    writableParent.__size++;
    writableSelf.__prev = insertKey;
    writableNodeToInsert.__prev = prevKey;
    writableNodeToInsert.__next = writableSelf.__key;
    writableNodeToInsert.__parent = writableSelf.__parent;
    const selection = $getSelection();
    if (restoreSelection && $isRangeSelection(selection)) {
      const parent = this.getParentOrThrow();
      $updateElementSelectionOnCreateDeleteNode(selection, parent, index);
    }
    return nodeToInsert;
  }
  /**
   * Whether or not this node has a required parent. Used during copy + paste operations
   * to normalize nodes that would otherwise be orphaned. For example, ListItemNodes without
   * a ListNode parent or TextNodes with a ParagraphNode parent.
   *
   * */
  isParentRequired() {
    return false;
  }
  /**
   * The creation logic for any required parent. Should be implemented if {@link isParentRequired} returns true.
   *
   * */
  createParentElementNode() {
    return $createParagraphNode();
  }
  selectStart() {
    return this.selectPrevious();
  }
  selectEnd() {
    return this.selectNext(0, 0);
  }
  /**
   * Moves selection to the previous sibling of this node, at the specified offsets.
   *
   * @param anchorOffset - The anchor offset for selection.
   * @param focusOffset -  The focus offset for selection
   * */
  selectPrevious(anchorOffset, focusOffset) {
    errorOnReadOnly();
    const prevSibling = this.getPreviousSibling();
    const parent = this.getParentOrThrow();
    if (prevSibling === null) {
      return parent.select(0, 0);
    }
    if ($isElementNode(prevSibling)) {
      return prevSibling.select();
    } else if (!$isTextNode(prevSibling)) {
      const index = prevSibling.getIndexWithinParent() + 1;
      return parent.select(index, index);
    }
    return prevSibling.select(anchorOffset, focusOffset);
  }
  /**
   * Moves selection to the next sibling of this node, at the specified offsets.
   *
   * @param anchorOffset - The anchor offset for selection.
   * @param focusOffset -  The focus offset for selection
   * */
  selectNext(anchorOffset, focusOffset) {
    errorOnReadOnly();
    const nextSibling = this.getNextSibling();
    const parent = this.getParentOrThrow();
    if (nextSibling === null) {
      return parent.select();
    }
    if ($isElementNode(nextSibling)) {
      return nextSibling.select(0, 0);
    } else if (!$isTextNode(nextSibling)) {
      const index = nextSibling.getIndexWithinParent();
      return parent.select(index, index);
    }
    return nextSibling.select(anchorOffset, focusOffset);
  }
  /**
   * Marks a node dirty, triggering transforms and
   * forcing it to be reconciled during the update cycle.
   *
   * */
  markDirty() {
    this.getWritable();
  }
  /**
   * @internal
   *
   * When the reconciler detects that a node was mutated, this method
   * may be called to restore the node to a known good state.
   */
  reconcileObservedMutation(dom, editor) {
    this.markDirty();
  }
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
__publicField(LexicalNode, "importDOM");
function errorOnTypeKlassMismatch(type, klass) {
  const registeredNode = getRegisteredNode(getActiveEditor(), type);
  if (registeredNode === void 0) {
    {
      formatDevErrorMessage(`Create node: Attempted to create node ${klass.name} that was not configured to be used on the editor.`);
    }
  }
  const editorKlass = registeredNode.klass;
  if (editorKlass !== klass) {
    {
      formatDevErrorMessage(`Create node: Type ${type} in node ${klass.name} does not match registered node ${editorKlass.name} with the same type`);
    }
  }
}
function insertRangeAfter(node, firstToInsert, lastToInsert) {
  const lastToInsert2 = firstToInsert.getParentOrThrow().getLastChild();
  let current = firstToInsert;
  const nodesToInsert = [firstToInsert];
  while (current !== lastToInsert2) {
    if (!current.getNextSibling()) {
      {
        formatDevErrorMessage(`insertRangeAfter: lastToInsert must be a later sibling of firstToInsert`);
      }
    }
    current = current.getNextSibling();
    nodesToInsert.push(current);
  }
  let currentNode = node;
  for (const nodeToInsert of nodesToInsert) {
    currentNode = currentNode.insertAfter(nodeToInsert);
  }
}
var HISTORIC_TAG = "historic";
var HISTORY_PUSH_TAG = "history-push";
var HISTORY_MERGE_TAG = "history-merge";
var PASTE_TAG = "paste";
var COLLABORATION_TAG = "collaboration";
var SKIP_COLLAB_TAG = "skip-collab";
var SKIP_SCROLL_INTO_VIEW_TAG = "skip-scroll-into-view";
var SKIP_DOM_SELECTION_TAG = "skip-dom-selection";
var SKIP_SELECTION_FOCUS_TAG = "skip-selection-focus";
var FOCUS_TAG = "focus";
var LineBreakNode = class _LineBreakNode extends LexicalNode {
  /** @internal */
  static getType() {
    return "linebreak";
  }
  static clone(node) {
    return new _LineBreakNode(node.__key);
  }
  constructor(key) {
    super(key);
  }
  getTextContent() {
    return "\n";
  }
  createDOM() {
    return document.createElement("br");
  }
  updateDOM() {
    return false;
  }
  isInline() {
    return true;
  }
  static importDOM() {
    return {
      br: (node) => {
        if (isOnlyChildInBlockNode(node) || isLastChildInBlockNode(node)) {
          return null;
        }
        return {
          conversion: $convertLineBreakElement,
          priority: 0
        };
      }
    };
  }
  static importJSON(serializedLineBreakNode) {
    return $createLineBreakNode().updateFromJSON(serializedLineBreakNode);
  }
};
function $convertLineBreakElement(node) {
  return {
    node: $createLineBreakNode()
  };
}
function $createLineBreakNode() {
  return $applyNodeReplacement(new LineBreakNode());
}
function $isLineBreakNode(node) {
  return node instanceof LineBreakNode;
}
function isOnlyChildInBlockNode(node) {
  const parentElement = node.parentElement;
  if (parentElement !== null && isBlockDomNode(parentElement)) {
    const firstChild = parentElement.firstChild;
    if (firstChild === node || firstChild.nextSibling === node && isWhitespaceDomTextNode(firstChild)) {
      const lastChild = parentElement.lastChild;
      if (lastChild === node || lastChild.previousSibling === node && isWhitespaceDomTextNode(lastChild)) {
        return true;
      }
    }
  }
  return false;
}
function isLastChildInBlockNode(node) {
  const parentElement = node.parentElement;
  if (parentElement !== null && isBlockDomNode(parentElement)) {
    const firstChild = parentElement.firstChild;
    if (firstChild === node || firstChild.nextSibling === node && isWhitespaceDomTextNode(firstChild)) {
      return false;
    }
    const lastChild = parentElement.lastChild;
    if (lastChild === node || lastChild.previousSibling === node && isWhitespaceDomTextNode(lastChild)) {
      return true;
    }
  }
  return false;
}
function isWhitespaceDomTextNode(node) {
  return isDOMTextNode(node) && /^( |\t|\r?\n)+$/.test(node.textContent || "");
}
function getElementOuterTag(node, format) {
  if (format & IS_CODE) {
    return "code";
  }
  if (format & IS_HIGHLIGHT) {
    return "mark";
  }
  if (format & IS_SUBSCRIPT) {
    return "sub";
  }
  if (format & IS_SUPERSCRIPT) {
    return "sup";
  }
  return null;
}
function getElementInnerTag(node, format) {
  if (format & IS_BOLD) {
    return "strong";
  }
  if (format & IS_ITALIC) {
    return "em";
  }
  return "span";
}
function setTextThemeClassNames(tag, prevFormat, nextFormat, dom, textClassNames) {
  const domClassList = dom.classList;
  let classNames = getCachedClassNameArray(textClassNames, "base");
  if (classNames !== void 0) {
    domClassList.add(...classNames);
  }
  classNames = getCachedClassNameArray(textClassNames, "underlineStrikethrough");
  let hasUnderlineStrikethrough = false;
  const prevUnderlineStrikethrough = prevFormat & IS_UNDERLINE && prevFormat & IS_STRIKETHROUGH;
  const nextUnderlineStrikethrough = nextFormat & IS_UNDERLINE && nextFormat & IS_STRIKETHROUGH;
  if (classNames !== void 0) {
    if (nextUnderlineStrikethrough) {
      hasUnderlineStrikethrough = true;
      if (!prevUnderlineStrikethrough) {
        domClassList.add(...classNames);
      }
    } else if (prevUnderlineStrikethrough) {
      domClassList.remove(...classNames);
    }
  }
  for (const key in TEXT_TYPE_TO_FORMAT) {
    const format = key;
    const flag = TEXT_TYPE_TO_FORMAT[format];
    classNames = getCachedClassNameArray(textClassNames, key);
    if (classNames !== void 0) {
      if (nextFormat & flag) {
        if (hasUnderlineStrikethrough && (key === "underline" || key === "strikethrough")) {
          if (prevFormat & flag) {
            domClassList.remove(...classNames);
          }
          continue;
        }
        if ((prevFormat & flag) === 0 || prevUnderlineStrikethrough && key === "underline" || key === "strikethrough") {
          domClassList.add(...classNames);
        }
      } else if (prevFormat & flag) {
        domClassList.remove(...classNames);
      }
    }
  }
}
function diffComposedText(a2, b2) {
  const aLength = a2.length;
  const bLength = b2.length;
  let left = 0;
  let right = 0;
  while (left < aLength && left < bLength && a2[left] === b2[left]) {
    left++;
  }
  while (right + left < aLength && right + left < bLength && a2[aLength - right - 1] === b2[bLength - right - 1]) {
    right++;
  }
  return [left, aLength - left - right, b2.slice(left, bLength - right)];
}
function setTextContent(nextText, dom, node) {
  const firstChild = dom.firstChild;
  const isComposing = node.isComposing();
  const suffix = isComposing ? COMPOSITION_SUFFIX : "";
  const text = nextText + suffix;
  if (firstChild == null) {
    dom.textContent = text;
  } else {
    const nodeValue = firstChild.nodeValue;
    if (nodeValue !== text) {
      if (isComposing || IS_FIREFOX) {
        const [index, remove, insert] = diffComposedText(nodeValue, text);
        if (remove !== 0) {
          firstChild.deleteData(index, remove);
        }
        firstChild.insertData(index, insert);
      } else {
        firstChild.nodeValue = text;
      }
    }
  }
}
function createTextInnerDOM(innerDOM, node, innerTag, format, text, config) {
  setTextContent(text, innerDOM, node);
  const theme2 = config.theme;
  const textClassNames = theme2.text;
  if (textClassNames !== void 0) {
    setTextThemeClassNames(innerTag, 0, format, innerDOM, textClassNames);
  }
}
function wrapElementWith(element, tag) {
  const el = document.createElement(tag);
  el.appendChild(element);
  return el;
}
var TextNode = class _TextNode extends LexicalNode {
  constructor(text = "", key) {
    super(key);
    /** @internal */
    __publicField(this, "__text");
    /** @internal */
    __publicField(this, "__format");
    /** @internal */
    __publicField(this, "__style");
    /** @internal */
    __publicField(this, "__mode");
    /** @internal */
    __publicField(this, "__detail");
    this.__text = text;
    this.__format = 0;
    this.__style = "";
    this.__mode = 0;
    this.__detail = 0;
  }
  static getType() {
    return "text";
  }
  static clone(node) {
    return new _TextNode(node.__text, node.__key);
  }
  afterCloneFrom(prevNode) {
    super.afterCloneFrom(prevNode);
    this.__text = prevNode.__text;
    this.__format = prevNode.__format;
    this.__style = prevNode.__style;
    this.__mode = prevNode.__mode;
    this.__detail = prevNode.__detail;
  }
  /**
   * Returns a 32-bit integer that represents the TextFormatTypes currently applied to the
   * TextNode. You probably don't want to use this method directly - consider using TextNode.hasFormat instead.
   *
   * @returns a number representing the format of the text node.
   */
  getFormat() {
    const self2 = this.getLatest();
    return self2.__format;
  }
  /**
   * Returns a 32-bit integer that represents the TextDetailTypes currently applied to the
   * TextNode. You probably don't want to use this method directly - consider using TextNode.isDirectionless
   * or TextNode.isUnmergeable instead.
   *
   * @returns a number representing the detail of the text node.
   */
  getDetail() {
    const self2 = this.getLatest();
    return self2.__detail;
  }
  /**
   * Returns the mode (TextModeType) of the TextNode, which may be "normal", "token", or "segmented"
   *
   * @returns TextModeType.
   */
  getMode() {
    const self2 = this.getLatest();
    return TEXT_TYPE_TO_MODE[self2.__mode];
  }
  /**
   * Returns the styles currently applied to the node. This is analogous to CSSText in the DOM.
   *
   * @returns CSSText-like string of styles applied to the underlying DOM node.
   */
  getStyle() {
    const self2 = this.getLatest();
    return self2.__style;
  }
  /**
   * Returns whether or not the node is in "token" mode. TextNodes in token mode can be navigated through character-by-character
   * with a RangeSelection, but are deleted as a single entity (not individually by character).
   *
   * @returns true if the node is in token mode, false otherwise.
   */
  isToken() {
    const self2 = this.getLatest();
    return self2.__mode === IS_TOKEN;
  }
  /**
   *
   * @returns true if Lexical detects that an IME or other 3rd-party script is attempting to
   * mutate the TextNode, false otherwise.
   */
  isComposing() {
    return this.__key === $getCompositionKey();
  }
  /**
   * Returns whether or not the node is in "segmented" mode. TextNodes in segmented mode can be navigated through character-by-character
   * with a RangeSelection, but are deleted in space-delimited "segments".
   *
   * @returns true if the node is in segmented mode, false otherwise.
   */
  isSegmented() {
    const self2 = this.getLatest();
    return self2.__mode === IS_SEGMENTED;
  }
  /**
   * Returns whether or not the node is "directionless". Directionless nodes don't respect changes between RTL and LTR modes.
   *
   * @returns true if the node is directionless, false otherwise.
   */
  isDirectionless() {
    const self2 = this.getLatest();
    return (self2.__detail & IS_DIRECTIONLESS) !== 0;
  }
  /**
   * Returns whether or not the node is unmergeable. In some scenarios, Lexical tries to merge
   * adjacent TextNodes into a single TextNode. If a TextNode is unmergeable, this won't happen.
   *
   * @returns true if the node is unmergeable, false otherwise.
   */
  isUnmergeable() {
    const self2 = this.getLatest();
    return (self2.__detail & IS_UNMERGEABLE) !== 0;
  }
  /**
   * Returns whether or not the node has the provided format applied. Use this with the human-readable TextFormatType
   * string values to get the format of a TextNode.
   *
   * @param type - the TextFormatType to check for.
   *
   * @returns true if the node has the provided format, false otherwise.
   */
  hasFormat(type) {
    const formatFlag = TEXT_TYPE_TO_FORMAT[type];
    return (this.getFormat() & formatFlag) !== 0;
  }
  /**
   * Returns whether or not the node is simple text. Simple text is defined as a TextNode that has the string type "text"
   * (i.e., not a subclass) and has no mode applied to it (i.e., not segmented or token).
   *
   * @returns true if the node is simple text, false otherwise.
   */
  isSimpleText() {
    return this.__type === "text" && this.__mode === 0;
  }
  /**
   * Returns the text content of the node as a string.
   *
   * @returns a string representing the text content of the node.
   */
  getTextContent() {
    const self2 = this.getLatest();
    return self2.__text;
  }
  /**
   * Returns the format flags applied to the node as a 32-bit integer.
   *
   * @returns a number representing the TextFormatTypes applied to the node.
   */
  getFormatFlags(type, alignWithFormat) {
    const self2 = this.getLatest();
    const format = self2.__format;
    return toggleTextFormatType(format, type, alignWithFormat);
  }
  /**
   *
   * @returns true if the text node supports font styling, false otherwise.
   */
  canHaveFormat() {
    return true;
  }
  /**
   * @returns true if the text node is inline, false otherwise.
   */
  isInline() {
    return true;
  }
  // View
  createDOM(config, editor) {
    const format = this.__format;
    const outerTag = getElementOuterTag(this, format);
    const innerTag = getElementInnerTag(this, format);
    const tag = outerTag === null ? innerTag : outerTag;
    const dom = document.createElement(tag);
    let innerDOM = dom;
    if (this.hasFormat("code")) {
      dom.setAttribute("spellcheck", "false");
    }
    if (outerTag !== null) {
      innerDOM = document.createElement(innerTag);
      dom.appendChild(innerDOM);
    }
    const text = this.__text;
    createTextInnerDOM(innerDOM, this, innerTag, format, text, config);
    const style = this.__style;
    if (style !== "") {
      dom.style.cssText = style;
    }
    return dom;
  }
  updateDOM(prevNode, dom, config) {
    const nextText = this.__text;
    const prevFormat = prevNode.__format;
    const nextFormat = this.__format;
    const prevOuterTag = getElementOuterTag(this, prevFormat);
    const nextOuterTag = getElementOuterTag(this, nextFormat);
    const prevInnerTag = getElementInnerTag(this, prevFormat);
    const nextInnerTag = getElementInnerTag(this, nextFormat);
    const prevTag = prevOuterTag === null ? prevInnerTag : prevOuterTag;
    const nextTag = nextOuterTag === null ? nextInnerTag : nextOuterTag;
    if (prevTag !== nextTag) {
      return true;
    }
    if (prevOuterTag === nextOuterTag && prevInnerTag !== nextInnerTag) {
      const prevInnerDOM = dom.firstChild;
      if (prevInnerDOM == null) {
        {
          formatDevErrorMessage(`updateDOM: prevInnerDOM is null or undefined`);
        }
      }
      const nextInnerDOM = document.createElement(nextInnerTag);
      createTextInnerDOM(nextInnerDOM, this, nextInnerTag, nextFormat, nextText, config);
      dom.replaceChild(nextInnerDOM, prevInnerDOM);
      return false;
    }
    let innerDOM = dom;
    if (nextOuterTag !== null) {
      if (prevOuterTag !== null) {
        innerDOM = dom.firstChild;
        if (innerDOM == null) {
          {
            formatDevErrorMessage(`updateDOM: innerDOM is null or undefined`);
          }
        }
      }
    }
    setTextContent(nextText, innerDOM, this);
    const theme2 = config.theme;
    const textClassNames = theme2.text;
    if (textClassNames !== void 0 && prevFormat !== nextFormat) {
      setTextThemeClassNames(nextInnerTag, prevFormat, nextFormat, innerDOM, textClassNames);
    }
    const prevStyle = prevNode.__style;
    const nextStyle = this.__style;
    if (prevStyle !== nextStyle) {
      dom.style.cssText = nextStyle;
    }
    return false;
  }
  static importDOM() {
    return {
      "#text": () => ({
        conversion: $convertTextDOMNode,
        priority: 0
      }),
      b: () => ({
        conversion: convertBringAttentionToElement,
        priority: 0
      }),
      code: () => ({
        conversion: convertTextFormatElement,
        priority: 0
      }),
      em: () => ({
        conversion: convertTextFormatElement,
        priority: 0
      }),
      i: () => ({
        conversion: convertTextFormatElement,
        priority: 0
      }),
      mark: () => ({
        conversion: convertTextFormatElement,
        priority: 0
      }),
      s: () => ({
        conversion: convertTextFormatElement,
        priority: 0
      }),
      span: () => ({
        conversion: convertSpanElement,
        priority: 0
      }),
      strong: () => ({
        conversion: convertTextFormatElement,
        priority: 0
      }),
      sub: () => ({
        conversion: convertTextFormatElement,
        priority: 0
      }),
      sup: () => ({
        conversion: convertTextFormatElement,
        priority: 0
      }),
      u: () => ({
        conversion: convertTextFormatElement,
        priority: 0
      })
    };
  }
  static importJSON(serializedNode) {
    return $createTextNode().updateFromJSON(serializedNode);
  }
  updateFromJSON(serializedNode) {
    return super.updateFromJSON(serializedNode).setTextContent(serializedNode.text).setFormat(serializedNode.format).setDetail(serializedNode.detail).setMode(serializedNode.mode).setStyle(serializedNode.style);
  }
  // This improves Lexical's basic text output in copy+paste plus
  // for headless mode where people might use Lexical to generate
  // HTML content and not have the ability to use CSS classes.
  exportDOM(editor) {
    let {
      element
    } = super.exportDOM(editor);
    if (!isHTMLElement(element)) {
      formatDevErrorMessage(`Expected TextNode createDOM to always return a HTMLElement`);
    }
    element.style.whiteSpace = "pre-wrap";
    if (this.hasFormat("lowercase")) {
      element.style.textTransform = "lowercase";
    } else if (this.hasFormat("uppercase")) {
      element.style.textTransform = "uppercase";
    } else if (this.hasFormat("capitalize")) {
      element.style.textTransform = "capitalize";
    }
    if (this.hasFormat("bold")) {
      element = wrapElementWith(element, "b");
    }
    if (this.hasFormat("italic")) {
      element = wrapElementWith(element, "i");
    }
    if (this.hasFormat("strikethrough")) {
      element = wrapElementWith(element, "s");
    }
    if (this.hasFormat("underline")) {
      element = wrapElementWith(element, "u");
    }
    return {
      element
    };
  }
  exportJSON() {
    return {
      detail: this.getDetail(),
      format: this.getFormat(),
      mode: this.getMode(),
      style: this.getStyle(),
      text: this.getTextContent(),
      // As an exception here we invoke super at the end for historical reasons.
      // Namely, to preserve the order of the properties and not to break the tests
      // that use the serialized string representation.
      ...super.exportJSON()
    };
  }
  // Mutators
  selectionTransform(prevSelection, nextSelection) {
    return;
  }
  /**
   * Sets the node format to the provided TextFormatType or 32-bit integer. Note that the TextFormatType
   * version of the argument can only specify one format and doing so will remove all other formats that
   * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleFormat}
   *
   * @param format - TextFormatType or 32-bit integer representing the node format.
   *
   * @returns this TextNode.
   * // TODO 0.12 This should just be a `string`.
   */
  setFormat(format) {
    const self2 = this.getWritable();
    self2.__format = typeof format === "string" ? TEXT_TYPE_TO_FORMAT[format] : format;
    return self2;
  }
  /**
   * Sets the node detail to the provided TextDetailType or 32-bit integer. Note that the TextDetailType
   * version of the argument can only specify one detail value and doing so will remove all other detail values that
   * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleDirectionless}
   * or {@link TextNode.toggleUnmergeable}
   *
   * @param detail - TextDetailType or 32-bit integer representing the node detail.
   *
   * @returns this TextNode.
   * // TODO 0.12 This should just be a `string`.
   */
  setDetail(detail) {
    const self2 = this.getWritable();
    self2.__detail = typeof detail === "string" ? DETAIL_TYPE_TO_DETAIL[detail] : detail;
    return self2;
  }
  /**
   * Sets the node style to the provided CSSText-like string. Set this property as you
   * would an HTMLElement style attribute to apply inline styles to the underlying DOM Element.
   *
   * @param style - CSSText to be applied to the underlying HTMLElement.
   *
   * @returns this TextNode.
   */
  setStyle(style) {
    const self2 = this.getWritable();
    self2.__style = style;
    return self2;
  }
  /**
   * Applies the provided format to this TextNode if it's not present. Removes it if it's present.
   * The subscript and superscript formats are mutually exclusive.
   * Prefer using this method to turn specific formats on and off.
   *
   * @param type - TextFormatType to toggle.
   *
   * @returns this TextNode.
   */
  toggleFormat(type) {
    const format = this.getFormat();
    const newFormat = toggleTextFormatType(format, type, null);
    return this.setFormat(newFormat);
  }
  /**
   * Toggles the directionless detail value of the node. Prefer using this method over setDetail.
   *
   * @returns this TextNode.
   */
  toggleDirectionless() {
    const self2 = this.getWritable();
    self2.__detail ^= IS_DIRECTIONLESS;
    return self2;
  }
  /**
   * Toggles the unmergeable detail value of the node. Prefer using this method over setDetail.
   *
   * @returns this TextNode.
   */
  toggleUnmergeable() {
    const self2 = this.getWritable();
    self2.__detail ^= IS_UNMERGEABLE;
    return self2;
  }
  /**
   * Sets the mode of the node.
   *
   * @returns this TextNode.
   */
  setMode(type) {
    const mode = TEXT_MODE_TO_TYPE[type];
    if (this.__mode === mode) {
      return this;
    }
    const self2 = this.getWritable();
    self2.__mode = mode;
    return self2;
  }
  /**
   * Sets the text content of the node.
   *
   * @param text - the string to set as the text value of the node.
   *
   * @returns this TextNode.
   */
  setTextContent(text) {
    if (this.__text === text) {
      return this;
    }
    const self2 = this.getWritable();
    self2.__text = text;
    return self2;
  }
  /**
   * Sets the current Lexical selection to be a RangeSelection with anchor and focus on this TextNode at the provided offsets.
   *
   * @param _anchorOffset - the offset at which the Selection anchor will be placed.
   * @param _focusOffset - the offset at which the Selection focus will be placed.
   *
   * @returns the new RangeSelection.
   */
  select(_anchorOffset, _focusOffset) {
    errorOnReadOnly();
    let anchorOffset = _anchorOffset;
    let focusOffset = _focusOffset;
    const selection = $getSelection();
    const text = this.getTextContent();
    const key = this.__key;
    if (typeof text === "string") {
      const lastOffset = text.length;
      if (anchorOffset === void 0) {
        anchorOffset = lastOffset;
      }
      if (focusOffset === void 0) {
        focusOffset = lastOffset;
      }
    } else {
      anchorOffset = 0;
      focusOffset = 0;
    }
    if (!$isRangeSelection(selection)) {
      return $internalMakeRangeSelection(key, anchorOffset, key, focusOffset, "text", "text");
    } else {
      const compositionKey = $getCompositionKey();
      if (compositionKey === selection.anchor.key || compositionKey === selection.focus.key) {
        $setCompositionKey(key);
      }
      selection.setTextNodeRange(this, anchorOffset, this, focusOffset);
    }
    return selection;
  }
  selectStart() {
    return this.select(0, 0);
  }
  selectEnd() {
    const size = this.getTextContentSize();
    return this.select(size, size);
  }
  /**
   * Inserts the provided text into this TextNode at the provided offset, deleting the number of characters
   * specified. Can optionally calculate a new selection after the operation is complete.
   *
   * @param offset - the offset at which the splice operation should begin.
   * @param delCount - the number of characters to delete, starting from the offset.
   * @param newText - the text to insert into the TextNode at the offset.
   * @param moveSelection - optional, whether or not to move selection to the end of the inserted substring.
   *
   * @returns this TextNode.
   */
  spliceText(offset, delCount, newText, moveSelection) {
    const writableSelf = this.getWritable();
    const text = writableSelf.__text;
    const handledTextLength = newText.length;
    let index = offset;
    if (index < 0) {
      index = handledTextLength + index;
      if (index < 0) {
        index = 0;
      }
    }
    const selection = $getSelection();
    if (moveSelection && $isRangeSelection(selection)) {
      const newOffset = offset + handledTextLength;
      selection.setTextNodeRange(writableSelf, newOffset, writableSelf, newOffset);
    }
    const updatedText = text.slice(0, index) + newText + text.slice(index + delCount);
    writableSelf.__text = updatedText;
    return writableSelf;
  }
  /**
   * This method is meant to be overridden by TextNode subclasses to control the behavior of those nodes
   * when a user event would cause text to be inserted before them in the editor. If true, Lexical will attempt
   * to insert text into this node. If false, it will insert the text in a new sibling node.
   *
   * @returns true if text can be inserted before the node, false otherwise.
   */
  canInsertTextBefore() {
    return true;
  }
  /**
   * This method is meant to be overridden by TextNode subclasses to control the behavior of those nodes
   * when a user event would cause text to be inserted after them in the editor. If true, Lexical will attempt
   * to insert text into this node. If false, it will insert the text in a new sibling node.
   *
   * @returns true if text can be inserted after the node, false otherwise.
   */
  canInsertTextAfter() {
    return true;
  }
  /**
   * Splits this TextNode at the provided character offsets, forming new TextNodes from the substrings
   * formed by the split, and inserting those new TextNodes into the editor, replacing the one that was split.
   *
   * @param splitOffsets - rest param of the text content character offsets at which this node should be split.
   *
   * @returns an Array containing the newly-created TextNodes.
   */
  splitText(...splitOffsets) {
    errorOnReadOnly();
    const self2 = this.getLatest();
    const textContent = self2.getTextContent();
    if (textContent === "") {
      return [];
    }
    const key = self2.__key;
    const compositionKey = $getCompositionKey();
    const textLength = textContent.length;
    splitOffsets.sort((a2, b2) => a2 - b2);
    splitOffsets.push(textLength);
    const parts = [];
    const splitOffsetsLength = splitOffsets.length;
    for (let start = 0, offsetIndex = 0; start < textLength && offsetIndex <= splitOffsetsLength; offsetIndex++) {
      const end = splitOffsets[offsetIndex];
      if (end > start) {
        parts.push(textContent.slice(start, end));
        start = end;
      }
    }
    const partsLength = parts.length;
    if (partsLength === 1) {
      return [self2];
    }
    const firstPart = parts[0];
    const parent = self2.getParent();
    let writableNode;
    const format = self2.getFormat();
    const style = self2.getStyle();
    const detail = self2.__detail;
    let hasReplacedSelf = false;
    let startTextPoint = null;
    let endTextPoint = null;
    const selection = $getSelection();
    if ($isRangeSelection(selection)) {
      const [startPoint, endPoint] = selection.isBackward() ? [selection.focus, selection.anchor] : [selection.anchor, selection.focus];
      if (startPoint.type === "text" && startPoint.key === key) {
        startTextPoint = startPoint;
      }
      if (endPoint.type === "text" && endPoint.key === key) {
        endTextPoint = endPoint;
      }
    }
    if (self2.isSegmented()) {
      writableNode = $createTextNode(firstPart);
      writableNode.__format = format;
      writableNode.__style = style;
      writableNode.__detail = detail;
      writableNode.__state = $cloneNodeState(self2, writableNode);
      hasReplacedSelf = true;
    } else {
      writableNode = self2.setTextContent(firstPart);
    }
    const splitNodes = [writableNode];
    for (let i2 = 1; i2 < partsLength; i2++) {
      const part = parts[i2];
      const sibling = $createTextNode(part);
      sibling.__format = format;
      sibling.__style = style;
      sibling.__detail = detail;
      sibling.__state = $cloneNodeState(self2, sibling);
      const siblingKey = sibling.__key;
      if (compositionKey === key) {
        $setCompositionKey(siblingKey);
      }
      splitNodes.push(sibling);
    }
    const originalStartOffset = startTextPoint ? startTextPoint.offset : null;
    const originalEndOffset = endTextPoint ? endTextPoint.offset : null;
    let startOffset = 0;
    for (const node of splitNodes) {
      if (!(startTextPoint || endTextPoint)) {
        break;
      }
      const endOffset = startOffset + node.getTextContentSize();
      if (startTextPoint !== null && originalStartOffset !== null && originalStartOffset <= endOffset && originalStartOffset >= startOffset) {
        startTextPoint.set(node.getKey(), originalStartOffset - startOffset, "text");
        if (originalStartOffset < endOffset) {
          startTextPoint = null;
        }
      }
      if (endTextPoint !== null && originalEndOffset !== null && originalEndOffset <= endOffset && originalEndOffset >= startOffset) {
        endTextPoint.set(node.getKey(), originalEndOffset - startOffset, "text");
        break;
      }
      startOffset = endOffset;
    }
    if (parent !== null) {
      internalMarkSiblingsAsDirty(this);
      const writableParent = parent.getWritable();
      const insertionIndex = this.getIndexWithinParent();
      if (hasReplacedSelf) {
        writableParent.splice(insertionIndex, 0, splitNodes);
        this.remove();
      } else {
        writableParent.splice(insertionIndex, 1, splitNodes);
      }
      if ($isRangeSelection(selection)) {
        $updateElementSelectionOnCreateDeleteNode(selection, parent, insertionIndex, partsLength - 1);
      }
    }
    return splitNodes;
  }
  /**
   * Merges the target TextNode into this TextNode, removing the target node.
   *
   * @param target - the TextNode to merge into this one.
   *
   * @returns this TextNode.
   */
  mergeWithSibling(target) {
    const isBefore = target === this.getPreviousSibling();
    if (!isBefore && target !== this.getNextSibling()) {
      {
        formatDevErrorMessage(`mergeWithSibling: sibling must be a previous or next sibling`);
      }
    }
    const key = this.__key;
    const targetKey = target.__key;
    const text = this.__text;
    const textLength = text.length;
    const compositionKey = $getCompositionKey();
    if (compositionKey === targetKey) {
      $setCompositionKey(key);
    }
    const selection = $getSelection();
    if ($isRangeSelection(selection)) {
      const anchor = selection.anchor;
      const focus = selection.focus;
      if (anchor !== null && anchor.key === targetKey) {
        adjustPointOffsetForMergedSibling(anchor, isBefore, key, target, textLength);
      }
      if (focus !== null && focus.key === targetKey) {
        adjustPointOffsetForMergedSibling(focus, isBefore, key, target, textLength);
      }
    }
    const targetText = target.__text;
    const newText = isBefore ? targetText + text : text + targetText;
    this.setTextContent(newText);
    const writableSelf = this.getWritable();
    target.remove();
    return writableSelf;
  }
  /**
   * This method is meant to be overridden by TextNode subclasses to control the behavior of those nodes
   * when used with the registerLexicalTextEntity function. If you're using registerLexicalTextEntity, the
   * node class that you create and replace matched text with should return true from this method.
   *
   * @returns true if the node is to be treated as a "text entity", false otherwise.
   */
  isTextEntity() {
    return false;
  }
};
function convertSpanElement(domNode) {
  const span = domNode;
  const style = span.style;
  return {
    forChild: applyTextFormatFromStyle(style),
    node: null
  };
}
function convertBringAttentionToElement(domNode) {
  const b2 = domNode;
  const hasNormalFontWeight = b2.style.fontWeight === "normal";
  return {
    forChild: applyTextFormatFromStyle(b2.style, hasNormalFontWeight ? void 0 : "bold"),
    node: null
  };
}
var preParentCache = /* @__PURE__ */ new WeakMap();
function isNodePre(node) {
  if (!isHTMLElement(node)) {
    return false;
  } else if (node.nodeName === "PRE") {
    return true;
  }
  const whiteSpace = node.style.whiteSpace;
  return typeof whiteSpace === "string" && whiteSpace.startsWith("pre");
}
function findParentPreDOMNode(node) {
  let cached;
  let parent = node.parentNode;
  const visited = [node];
  while (parent !== null && (cached = preParentCache.get(parent)) === void 0 && !isNodePre(parent)) {
    visited.push(parent);
    parent = parent.parentNode;
  }
  const resultNode = cached === void 0 ? parent : cached;
  for (let i2 = 0; i2 < visited.length; i2++) {
    preParentCache.set(visited[i2], resultNode);
  }
  return resultNode;
}
function $convertTextDOMNode(domNode) {
  const domNode_ = domNode;
  const parentDom = domNode.parentElement;
  if (!(parentDom !== null)) {
    formatDevErrorMessage(`Expected parentElement of Text not to be null`);
  }
  let textContent = domNode_.textContent || "";
  if (findParentPreDOMNode(domNode_) !== null) {
    const parts = textContent.split(/(\r?\n|\t)/);
    const nodes = [];
    const length = parts.length;
    for (let i2 = 0; i2 < length; i2++) {
      const part = parts[i2];
      if (part === "\n" || part === "\r\n") {
        nodes.push($createLineBreakNode());
      } else if (part === "	") {
        nodes.push($createTabNode());
      } else if (part !== "") {
        nodes.push($createTextNode(part));
      }
    }
    return {
      node: nodes
    };
  }
  textContent = textContent.replace(/\r/g, "").replace(/[ \t\n]+/g, " ");
  if (textContent === "") {
    return {
      node: null
    };
  }
  if (textContent[0] === " ") {
    let previousText = domNode_;
    let isStartOfLine = true;
    while (previousText !== null && (previousText = findTextInLine(previousText, false)) !== null) {
      const previousTextContent = previousText.textContent || "";
      if (previousTextContent.length > 0) {
        if (/[ \t\n]$/.test(previousTextContent)) {
          textContent = textContent.slice(1);
        }
        isStartOfLine = false;
        break;
      }
    }
    if (isStartOfLine) {
      textContent = textContent.slice(1);
    }
  }
  if (textContent[textContent.length - 1] === " ") {
    let nextText = domNode_;
    let isEndOfLine = true;
    while (nextText !== null && (nextText = findTextInLine(nextText, true)) !== null) {
      const nextTextContent = (nextText.textContent || "").replace(/^( |\t|\r?\n)+/, "");
      if (nextTextContent.length > 0) {
        isEndOfLine = false;
        break;
      }
    }
    if (isEndOfLine) {
      textContent = textContent.slice(0, textContent.length - 1);
    }
  }
  if (textContent === "") {
    return {
      node: null
    };
  }
  return {
    node: $createTextNode(textContent)
  };
}
function findTextInLine(text, forward) {
  let node = text;
  while (true) {
    let sibling;
    while ((sibling = forward ? node.nextSibling : node.previousSibling) === null) {
      const parentElement = node.parentElement;
      if (parentElement === null) {
        return null;
      }
      node = parentElement;
    }
    node = sibling;
    if (isHTMLElement(node)) {
      const display = node.style.display;
      if (display === "" && !isInlineDomNode(node) || display !== "" && !display.startsWith("inline")) {
        return null;
      }
    }
    let descendant = node;
    while ((descendant = forward ? node.firstChild : node.lastChild) !== null) {
      node = descendant;
    }
    if (isDOMTextNode(node)) {
      return node;
    } else if (node.nodeName === "BR") {
      return null;
    }
  }
}
var nodeNameToTextFormat = {
  code: "code",
  em: "italic",
  i: "italic",
  mark: "highlight",
  s: "strikethrough",
  strong: "bold",
  sub: "subscript",
  sup: "superscript",
  u: "underline"
};
function convertTextFormatElement(domNode) {
  const format = nodeNameToTextFormat[domNode.nodeName.toLowerCase()];
  if (format === void 0) {
    return {
      node: null
    };
  }
  return {
    forChild: applyTextFormatFromStyle(domNode.style, format),
    node: null
  };
}
function $createTextNode(text = "") {
  return $applyNodeReplacement(new TextNode(text));
}
function $isTextNode(node) {
  return node instanceof TextNode;
}
function applyTextFormatFromStyle(style, shouldApply) {
  const fontWeight = style.fontWeight;
  const textDecoration = style.textDecoration.split(" ");
  const hasBoldFontWeight = fontWeight === "700" || fontWeight === "bold";
  const hasLinethroughTextDecoration = textDecoration.includes("line-through");
  const hasItalicFontStyle = style.fontStyle === "italic";
  const hasUnderlineTextDecoration = textDecoration.includes("underline");
  const verticalAlign = style.verticalAlign;
  return (lexicalNode) => {
    if (!$isTextNode(lexicalNode)) {
      return lexicalNode;
    }
    if (hasBoldFontWeight && !lexicalNode.hasFormat("bold")) {
      lexicalNode.toggleFormat("bold");
    }
    if (hasLinethroughTextDecoration && !lexicalNode.hasFormat("strikethrough")) {
      lexicalNode.toggleFormat("strikethrough");
    }
    if (hasItalicFontStyle && !lexicalNode.hasFormat("italic")) {
      lexicalNode.toggleFormat("italic");
    }
    if (hasUnderlineTextDecoration && !lexicalNode.hasFormat("underline")) {
      lexicalNode.toggleFormat("underline");
    }
    if (verticalAlign === "sub" && !lexicalNode.hasFormat("subscript")) {
      lexicalNode.toggleFormat("subscript");
    }
    if (verticalAlign === "super" && !lexicalNode.hasFormat("superscript")) {
      lexicalNode.toggleFormat("superscript");
    }
    if (shouldApply && !lexicalNode.hasFormat(shouldApply)) {
      lexicalNode.toggleFormat(shouldApply);
    }
    return lexicalNode;
  };
}
var TabNode = class _TabNode extends TextNode {
  static getType() {
    return "tab";
  }
  static clone(node) {
    return new _TabNode(node.__key);
  }
  constructor(key) {
    super("	", key);
    this.__detail = IS_UNMERGEABLE;
  }
  static importDOM() {
    return null;
  }
  createDOM(config) {
    const dom = super.createDOM(config);
    const classNames = getCachedClassNameArray(config.theme, "tab");
    if (classNames !== void 0) {
      const domClassList = dom.classList;
      domClassList.add(...classNames);
    }
    return dom;
  }
  static importJSON(serializedTabNode) {
    return $createTabNode().updateFromJSON(serializedTabNode);
  }
  setTextContent(text) {
    if (!(text === "	" || text === "")) {
      formatDevErrorMessage(`TabNode does not support setTextContent`);
    }
    return super.setTextContent("	");
  }
  spliceText(offset, delCount, newText, moveSelection) {
    if (!(newText === "" && delCount === 0 || newText === "	" && delCount === 1)) {
      formatDevErrorMessage(`TabNode does not support spliceText`);
    }
    return this;
  }
  setDetail(detail) {
    if (!(detail === IS_UNMERGEABLE)) {
      formatDevErrorMessage(`TabNode does not support setDetail`);
    }
    return this;
  }
  setMode(type) {
    if (!(type === "normal")) {
      formatDevErrorMessage(`TabNode does not support setMode`);
    }
    return this;
  }
  canInsertTextBefore() {
    return false;
  }
  canInsertTextAfter() {
    return false;
  }
};
function $createTabNode() {
  return $applyNodeReplacement(new TabNode());
}
function $isTabNode(node) {
  return node instanceof TabNode;
}
var Point = class {
  constructor(key, offset, type) {
    __publicField(this, "key");
    __publicField(this, "offset");
    __publicField(this, "type");
    __publicField(this, "_selection");
    {
      Object.defineProperty(this, "_selection", {
        enumerable: false,
        writable: true
      });
    }
    this._selection = null;
    this.key = key;
    this.offset = offset;
    this.type = type;
  }
  is(point) {
    return this.key === point.key && this.offset === point.offset && this.type === point.type;
  }
  isBefore(b2) {
    if (this.key === b2.key) {
      return this.offset < b2.offset;
    }
    const aCaret = $normalizeCaret($caretFromPoint(this, "next"));
    const bCaret = $normalizeCaret($caretFromPoint(b2, "next"));
    return $comparePointCaretNext(aCaret, bCaret) < 0;
  }
  getNode() {
    const key = this.key;
    const node = $getNodeByKey(key);
    if (node === null) {
      {
        formatDevErrorMessage(`Point.getNode: node not found`);
      }
    }
    return node;
  }
  set(key, offset, type, onlyIfChanged) {
    const selection = this._selection;
    const oldKey = this.key;
    if (onlyIfChanged && this.key === key && this.offset === offset && this.type === type) {
      return;
    }
    this.key = key;
    this.offset = offset;
    this.type = type;
    {
      const node = $getNodeByKey(key);
      if (!(type === "text" ? $isTextNode(node) : $isElementNode(node))) {
        formatDevErrorMessage(`PointType.set: node with key ${key} is ${node ? node.__type : "[not found]"} and can not be used for a ${type} point`);
      }
    }
    if (!isCurrentlyReadOnlyMode()) {
      if ($getCompositionKey() === oldKey) {
        $setCompositionKey(key);
      }
      if (selection !== null) {
        selection.setCachedNodes(null);
        selection.dirty = true;
      }
    }
  }
};
function $createPoint(key, offset, type) {
  return new Point(key, offset, type);
}
function selectPointOnNode(point, node) {
  let key = node.__key;
  let offset = point.offset;
  let type = "element";
  if ($isTextNode(node)) {
    type = "text";
    const textContentLength = node.getTextContentSize();
    if (offset > textContentLength) {
      offset = textContentLength;
    }
  } else if (!$isElementNode(node)) {
    const nextSibling = node.getNextSibling();
    if ($isTextNode(nextSibling)) {
      key = nextSibling.__key;
      offset = 0;
      type = "text";
    } else {
      const parentNode = node.getParent();
      if (parentNode) {
        key = parentNode.__key;
        offset = node.getIndexWithinParent() + 1;
      }
    }
  }
  point.set(key, offset, type);
}
function $moveSelectionPointToEnd(point, node) {
  if ($isElementNode(node)) {
    const lastNode = node.getLastDescendant();
    if ($isElementNode(lastNode) || $isTextNode(lastNode)) {
      selectPointOnNode(point, lastNode);
    } else {
      selectPointOnNode(point, node);
    }
  } else {
    selectPointOnNode(point, node);
  }
}
function $transferStartingElementPointToTextPoint(start, end, format, style) {
  const element = start.getNode();
  const placementNode = element.getChildAtIndex(start.offset);
  const textNode = $createTextNode();
  textNode.setFormat(format);
  textNode.setStyle(style);
  if ($isParagraphNode(placementNode)) {
    placementNode.splice(0, 0, [textNode]);
  } else {
    const target = $isRootNode(element) ? $createParagraphNode().append(textNode) : textNode;
    if (placementNode === null) {
      element.append(target);
    } else {
      placementNode.insertBefore(target);
    }
  }
  if (start.is(end)) {
    end.set(textNode.__key, 0, "text");
  }
  start.set(textNode.__key, 0, "text");
}
var NodeSelection = class _NodeSelection {
  constructor(objects) {
    __publicField(this, "_nodes");
    __publicField(this, "_cachedNodes");
    __publicField(this, "dirty");
    this._cachedNodes = null;
    this._nodes = objects;
    this.dirty = false;
  }
  getCachedNodes() {
    return this._cachedNodes;
  }
  setCachedNodes(nodes) {
    this._cachedNodes = nodes;
  }
  is(selection) {
    if (!$isNodeSelection(selection)) {
      return false;
    }
    const a2 = this._nodes;
    const b2 = selection._nodes;
    return a2.size === b2.size && Array.from(a2).every((key) => b2.has(key));
  }
  isCollapsed() {
    return false;
  }
  isBackward() {
    return false;
  }
  getStartEndPoints() {
    return null;
  }
  add(key) {
    this.dirty = true;
    this._nodes.add(key);
    this._cachedNodes = null;
  }
  delete(key) {
    this.dirty = true;
    this._nodes.delete(key);
    this._cachedNodes = null;
  }
  clear() {
    this.dirty = true;
    this._nodes.clear();
    this._cachedNodes = null;
  }
  has(key) {
    return this._nodes.has(key);
  }
  clone() {
    return new _NodeSelection(new Set(this._nodes));
  }
  extract() {
    return this.getNodes();
  }
  insertRawText(text) {
  }
  insertText() {
  }
  insertNodes(nodes) {
    const selectedNodes = this.getNodes();
    const selectedNodesLength = selectedNodes.length;
    const lastSelectedNode = selectedNodes[selectedNodesLength - 1];
    let selectionAtEnd;
    if ($isTextNode(lastSelectedNode)) {
      selectionAtEnd = lastSelectedNode.select();
    } else {
      const index = lastSelectedNode.getIndexWithinParent() + 1;
      selectionAtEnd = lastSelectedNode.getParentOrThrow().select(index, index);
    }
    selectionAtEnd.insertNodes(nodes);
    for (let i2 = 0; i2 < selectedNodesLength; i2++) {
      selectedNodes[i2].remove();
    }
  }
  getNodes() {
    const cachedNodes = this._cachedNodes;
    if (cachedNodes !== null) {
      return cachedNodes;
    }
    const objects = this._nodes;
    const nodes = [];
    for (const object of objects) {
      const node = $getNodeByKey(object);
      if (node !== null) {
        nodes.push(node);
      }
    }
    if (!isCurrentlyReadOnlyMode()) {
      this._cachedNodes = nodes;
    }
    return nodes;
  }
  getTextContent() {
    const nodes = this.getNodes();
    let textContent = "";
    for (let i2 = 0; i2 < nodes.length; i2++) {
      textContent += nodes[i2].getTextContent();
    }
    return textContent;
  }
  /**
   * Remove all nodes in the NodeSelection. If there were any nodes,
   * replace the selection with a new RangeSelection at the previous
   * location of the first node.
   */
  deleteNodes() {
    const nodes = this.getNodes();
    if (($getSelection() || $getPreviousSelection()) === this && nodes[0]) {
      const firstCaret = $getSiblingCaret(nodes[0], "next");
      $setSelectionFromCaretRange($getCaretRange(firstCaret, firstCaret));
    }
    for (const node of nodes) {
      node.remove();
    }
  }
};
function $isRangeSelection(x) {
  return x instanceof RangeSelection;
}
var RangeSelection = class _RangeSelection {
  constructor(anchor, focus, format, style) {
    __publicField(this, "format");
    __publicField(this, "style");
    __publicField(this, "anchor");
    __publicField(this, "focus");
    __publicField(this, "_cachedNodes");
    __publicField(this, "dirty");
    this.anchor = anchor;
    this.focus = focus;
    anchor._selection = this;
    focus._selection = this;
    this._cachedNodes = null;
    this.format = format;
    this.style = style;
    this.dirty = false;
  }
  getCachedNodes() {
    return this._cachedNodes;
  }
  setCachedNodes(nodes) {
    this._cachedNodes = nodes;
  }
  /**
   * Used to check if the provided selections is equal to this one by value,
   * including anchor, focus, format, and style properties.
   * @param selection - the Selection to compare this one to.
   * @returns true if the Selections are equal, false otherwise.
   */
  is(selection) {
    if (!$isRangeSelection(selection)) {
      return false;
    }
    return this.anchor.is(selection.anchor) && this.focus.is(selection.focus) && this.format === selection.format && this.style === selection.style;
  }
  /**
   * Returns whether the Selection is "collapsed", meaning the anchor and focus are
   * the same node and have the same offset.
   *
   * @returns true if the Selection is collapsed, false otherwise.
   */
  isCollapsed() {
    return this.anchor.is(this.focus);
  }
  /**
   * Gets all the nodes in the Selection. Uses caching to make it generally suitable
   * for use in hot paths.
   *
   * See also the {@link CaretRange} APIs (starting with
   * {@link $caretRangeFromSelection}), which are likely to provide a better
   * foundation for any operation where partial selection is relevant
   * (e.g. the anchor or focus are inside an ElementNode and TextNode)
   *
   * @returns an Array containing all the nodes in the Selection
   */
  getNodes() {
    const cachedNodes = this._cachedNodes;
    if (cachedNodes !== null) {
      return cachedNodes;
    }
    const range = $getCaretRangeInDirection($caretRangeFromSelection(this), "next");
    const nodes = $getNodesFromCaretRangeCompat(range);
    {
      if (this.isCollapsed() && nodes.length > 1) {
        {
          formatDevErrorMessage(`RangeSelection.getNodes() returned ${String(nodes.length)} > 1 nodes in a collapsed selection`);
        }
      }
    }
    if (!isCurrentlyReadOnlyMode()) {
      this._cachedNodes = nodes;
    }
    return nodes;
  }
  /**
   * Sets this Selection to be of type "text" at the provided anchor and focus values.
   *
   * @param anchorNode - the anchor node to set on the Selection
   * @param anchorOffset - the offset to set on the Selection
   * @param focusNode - the focus node to set on the Selection
   * @param focusOffset - the focus offset to set on the Selection
   */
  setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset) {
    this.anchor.set(anchorNode.__key, anchorOffset, "text");
    this.focus.set(focusNode.__key, focusOffset, "text");
  }
  /**
   * Gets the (plain) text content of all the nodes in the selection.
   *
   * @returns a string representing the text content of all the nodes in the Selection
   */
  getTextContent() {
    const nodes = this.getNodes();
    if (nodes.length === 0) {
      return "";
    }
    const firstNode = nodes[0];
    const lastNode = nodes[nodes.length - 1];
    const anchor = this.anchor;
    const focus = this.focus;
    const isBefore = anchor.isBefore(focus);
    const [anchorOffset, focusOffset] = $getCharacterOffsets(this);
    let textContent = "";
    let prevWasElement = true;
    for (let i2 = 0; i2 < nodes.length; i2++) {
      const node = nodes[i2];
      if ($isElementNode(node) && !node.isInline()) {
        if (!prevWasElement) {
          textContent += "\n";
        }
        if (node.isEmpty()) {
          prevWasElement = false;
        } else {
          prevWasElement = true;
        }
      } else {
        prevWasElement = false;
        if ($isTextNode(node)) {
          let text = node.getTextContent();
          if (node === firstNode) {
            if (node === lastNode) {
              if (anchor.type !== "element" || focus.type !== "element" || focus.offset === anchor.offset) {
                text = anchorOffset < focusOffset ? text.slice(anchorOffset, focusOffset) : text.slice(focusOffset, anchorOffset);
              }
            } else {
              text = isBefore ? text.slice(anchorOffset) : text.slice(focusOffset);
            }
          } else if (node === lastNode) {
            text = isBefore ? text.slice(0, focusOffset) : text.slice(0, anchorOffset);
          }
          textContent += text;
        } else if (($isDecoratorNode(node) || $isLineBreakNode(node)) && (node !== lastNode || !this.isCollapsed())) {
          textContent += node.getTextContent();
        }
      }
    }
    return textContent;
  }
  /**
   * Attempts to map a DOM selection range onto this Lexical Selection,
   * setting the anchor, focus, and type accordingly
   *
   * @param range a DOM Selection range conforming to the StaticRange interface.
   */
  applyDOMRange(range) {
    const editor = getActiveEditor();
    const currentEditorState = editor.getEditorState();
    const lastSelection = currentEditorState._selection;
    const resolvedSelectionPoints = $internalResolveSelectionPoints(range.startContainer, range.startOffset, range.endContainer, range.endOffset, editor, lastSelection);
    if (resolvedSelectionPoints === null) {
      return;
    }
    const [anchorPoint, focusPoint] = resolvedSelectionPoints;
    this.anchor.set(anchorPoint.key, anchorPoint.offset, anchorPoint.type, true);
    this.focus.set(focusPoint.key, focusPoint.offset, focusPoint.type, true);
    $normalizeSelection(this);
  }
  /**
   * Creates a new RangeSelection, copying over all the property values from this one.
   *
   * @returns a new RangeSelection with the same property values as this one.
   */
  clone() {
    const anchor = this.anchor;
    const focus = this.focus;
    const selection = new _RangeSelection($createPoint(anchor.key, anchor.offset, anchor.type), $createPoint(focus.key, focus.offset, focus.type), this.format, this.style);
    return selection;
  }
  /**
   * Toggles the provided format on all the TextNodes in the Selection.
   *
   * @param format a string TextFormatType to toggle on the TextNodes in the selection
   */
  toggleFormat(format) {
    this.format = toggleTextFormatType(this.format, format, null);
    this.dirty = true;
  }
  /**
   * Sets the value of the format property on the Selection
   *
   * @param format - the format to set at the value of the format property.
   */
  setFormat(format) {
    this.format = format;
    this.dirty = true;
  }
  /**
   * Sets the value of the style property on the Selection
   *
   * @param style - the style to set at the value of the style property.
   */
  setStyle(style) {
    this.style = style;
    this.dirty = true;
  }
  /**
   * Returns whether the provided TextFormatType is present on the Selection. This will be true if any node in the Selection
   * has the specified format.
   *
   * @param type the TextFormatType to check for.
   * @returns true if the provided format is currently toggled on on the Selection, false otherwise.
   */
  hasFormat(type) {
    const formatFlag = TEXT_TYPE_TO_FORMAT[type];
    return (this.format & formatFlag) !== 0;
  }
  /**
   * Attempts to insert the provided text into the EditorState at the current Selection.
   * converts tabs, newlines, and carriage returns into LexicalNodes.
   *
   * @param text the text to insert into the Selection
   */
  insertRawText(text) {
    const parts = text.split(/(\r?\n|\t)/);
    const nodes = [];
    const length = parts.length;
    for (let i2 = 0; i2 < length; i2++) {
      const part = parts[i2];
      if (part === "\n" || part === "\r\n") {
        nodes.push($createLineBreakNode());
      } else if (part === "	") {
        nodes.push($createTabNode());
      } else {
        nodes.push($createTextNode(part));
      }
    }
    this.insertNodes(nodes);
  }
  /**
   * Insert the provided text into the EditorState at the current Selection.
   *
   * @param text the text to insert into the Selection
   */
  insertText(text) {
    const anchor = this.anchor;
    const focus = this.focus;
    const format = this.format;
    const style = this.style;
    let firstPoint = anchor;
    let endPoint = focus;
    if (!this.isCollapsed() && focus.isBefore(anchor)) {
      firstPoint = focus;
      endPoint = anchor;
    }
    if (firstPoint.type === "element") {
      $transferStartingElementPointToTextPoint(firstPoint, endPoint, format, style);
    }
    if (endPoint.type === "element") {
      $setPointFromCaret(endPoint, $normalizeCaret($caretFromPoint(endPoint, "next")));
    }
    const startOffset = firstPoint.offset;
    let endOffset = endPoint.offset;
    const selectedNodes = this.getNodes();
    const selectedNodesLength = selectedNodes.length;
    let firstNode = selectedNodes[0];
    if (!$isTextNode(firstNode)) {
      {
        formatDevErrorMessage(`insertText: first node is not a text node`);
      }
    }
    const firstNodeText = firstNode.getTextContent();
    const firstNodeTextLength = firstNodeText.length;
    const firstNodeParent = firstNode.getParentOrThrow();
    const lastIndex = selectedNodesLength - 1;
    let lastNode = selectedNodes[lastIndex];
    if (selectedNodesLength === 1 && endPoint.type === "element") {
      endOffset = firstNodeTextLength;
      endPoint.set(firstPoint.key, endOffset, "text");
    }
    if (this.isCollapsed() && startOffset === firstNodeTextLength && ($isTokenOrSegmented(firstNode) || !firstNode.canInsertTextAfter() || !firstNodeParent.canInsertTextAfter() && firstNode.getNextSibling() === null)) {
      let nextSibling = firstNode.getNextSibling();
      if (!$isTextNode(nextSibling) || !nextSibling.canInsertTextBefore() || $isTokenOrSegmented(nextSibling)) {
        nextSibling = $createTextNode();
        nextSibling.setFormat(format);
        nextSibling.setStyle(style);
        if (!firstNodeParent.canInsertTextAfter()) {
          firstNodeParent.insertAfter(nextSibling);
        } else {
          firstNode.insertAfter(nextSibling);
        }
      }
      nextSibling.select(0, 0);
      firstNode = nextSibling;
      if (text !== "") {
        this.insertText(text);
        return;
      }
    } else if (this.isCollapsed() && startOffset === 0 && ($isTokenOrSegmented(firstNode) || !firstNode.canInsertTextBefore() || !firstNodeParent.canInsertTextBefore() && firstNode.getPreviousSibling() === null)) {
      let prevSibling = firstNode.getPreviousSibling();
      if (!$isTextNode(prevSibling) || $isTokenOrSegmented(prevSibling)) {
        prevSibling = $createTextNode();
        prevSibling.setFormat(format);
        if (!firstNodeParent.canInsertTextBefore()) {
          firstNodeParent.insertBefore(prevSibling);
        } else {
          firstNode.insertBefore(prevSibling);
        }
      }
      prevSibling.select();
      firstNode = prevSibling;
      if (text !== "") {
        this.insertText(text);
        return;
      }
    } else if (firstNode.isSegmented() && startOffset !== firstNodeTextLength) {
      const textNode = $createTextNode(firstNode.getTextContent());
      textNode.setFormat(format);
      firstNode.replace(textNode);
      firstNode = textNode;
    } else if (!this.isCollapsed() && text !== "") {
      const lastNodeParent = lastNode.getParent();
      if (!firstNodeParent.canInsertTextBefore() || !firstNodeParent.canInsertTextAfter() || $isElementNode(lastNodeParent) && (!lastNodeParent.canInsertTextBefore() || !lastNodeParent.canInsertTextAfter())) {
        this.insertText("");
        $normalizeSelectionPointsForBoundaries(this.anchor, this.focus, null);
        this.insertText(text);
        return;
      }
    }
    if (selectedNodesLength === 1) {
      if ($isTokenOrTab(firstNode)) {
        const textNode = $createTextNode(text);
        textNode.select();
        firstNode.replace(textNode);
        return;
      }
      const firstNodeFormat = firstNode.getFormat();
      const firstNodeStyle = firstNode.getStyle();
      if (startOffset === endOffset && (firstNodeFormat !== format || firstNodeStyle !== style)) {
        if (firstNode.getTextContent() === "") {
          firstNode.setFormat(format);
          firstNode.setStyle(style);
        } else {
          const textNode = $createTextNode(text);
          textNode.setFormat(format);
          textNode.setStyle(style);
          textNode.select();
          if (startOffset === 0) {
            firstNode.insertBefore(textNode, false);
          } else {
            const [targetNode] = firstNode.splitText(startOffset);
            targetNode.insertAfter(textNode, false);
          }
          if (textNode.isComposing() && this.anchor.type === "text") {
            this.anchor.offset -= text.length;
          }
          return;
        }
      } else if ($isTabNode(firstNode)) {
        const textNode = $createTextNode(text);
        textNode.setFormat(format);
        textNode.setStyle(style);
        textNode.select();
        firstNode.replace(textNode);
        return;
      }
      const delCount = endOffset - startOffset;
      firstNode = firstNode.spliceText(startOffset, delCount, text, true);
      if (firstNode.getTextContent() === "") {
        firstNode.remove();
      } else if (this.anchor.type === "text") {
        if (firstNode.isComposing()) {
          this.anchor.offset -= text.length;
        } else {
          this.format = firstNodeFormat;
          this.style = firstNodeStyle;
        }
      }
    } else {
      const markedNodeKeysForKeep = /* @__PURE__ */ new Set([...firstNode.getParentKeys(), ...lastNode.getParentKeys()]);
      const firstElement = $isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();
      let lastElement = $isElementNode(lastNode) ? lastNode : lastNode.getParentOrThrow();
      let lastElementChild = lastNode;
      if (!firstElement.is(lastElement) && lastElement.isInline()) {
        do {
          lastElementChild = lastElement;
          lastElement = lastElement.getParentOrThrow();
        } while (lastElement.isInline());
      }
      if (endPoint.type === "text" && (endOffset !== 0 || lastNode.getTextContent() === "") || endPoint.type === "element" && lastNode.getIndexWithinParent() < endOffset) {
        if ($isTextNode(lastNode) && !$isTokenOrTab(lastNode) && endOffset !== lastNode.getTextContentSize()) {
          if (lastNode.isSegmented()) {
            const textNode = $createTextNode(lastNode.getTextContent());
            lastNode.replace(textNode);
            lastNode = textNode;
          }
          if (!$isRootNode(endPoint.getNode()) && endPoint.type === "text") {
            lastNode = lastNode.spliceText(0, endOffset, "");
          }
          markedNodeKeysForKeep.add(lastNode.__key);
        } else {
          const lastNodeParent = lastNode.getParentOrThrow();
          if (!lastNodeParent.canBeEmpty() && lastNodeParent.getChildrenSize() === 1) {
            lastNodeParent.remove();
          } else {
            lastNode.remove();
          }
        }
      } else {
        markedNodeKeysForKeep.add(lastNode.__key);
      }
      const lastNodeChildren = lastElement.getChildren();
      const selectedNodesSet = new Set(selectedNodes);
      const firstAndLastElementsAreEqual = firstElement.is(lastElement);
      const insertionTarget = firstElement.isInline() && firstNode.getNextSibling() === null ? firstElement : firstNode;
      for (let i2 = lastNodeChildren.length - 1; i2 >= 0; i2--) {
        const lastNodeChild = lastNodeChildren[i2];
        if (lastNodeChild.is(firstNode) || $isElementNode(lastNodeChild) && lastNodeChild.isParentOf(firstNode)) {
          break;
        }
        if (lastNodeChild.isAttached()) {
          if (!selectedNodesSet.has(lastNodeChild) || lastNodeChild.is(lastElementChild)) {
            if (!firstAndLastElementsAreEqual) {
              insertionTarget.insertAfter(lastNodeChild, false);
            }
          } else {
            lastNodeChild.remove();
          }
        }
      }
      if (!firstAndLastElementsAreEqual) {
        let parent = lastElement;
        let lastRemovedParent = null;
        while (parent !== null) {
          const children = parent.getChildren();
          const childrenLength = children.length;
          if (childrenLength === 0 || children[childrenLength - 1].is(lastRemovedParent)) {
            markedNodeKeysForKeep.delete(parent.__key);
            lastRemovedParent = parent;
          }
          parent = parent.getParent();
        }
      }
      if (!$isTokenOrTab(firstNode)) {
        firstNode = firstNode.spliceText(startOffset, firstNodeTextLength - startOffset, text, true);
        if (firstNode.getTextContent() === "") {
          firstNode.remove();
        } else if (firstNode.isComposing() && this.anchor.type === "text") {
          this.anchor.offset -= text.length;
        }
      } else if (startOffset === firstNodeTextLength) {
        firstNode.select();
      } else {
        const textNode = $createTextNode(text);
        textNode.select();
        firstNode.replace(textNode);
      }
      for (let i2 = 1; i2 < selectedNodesLength; i2++) {
        const selectedNode = selectedNodes[i2];
        const key = selectedNode.__key;
        if (!markedNodeKeysForKeep.has(key)) {
          selectedNode.remove();
        }
      }
    }
  }
  /**
   * Removes the text in the Selection, adjusting the EditorState accordingly.
   */
  removeText() {
    const isCurrentSelection = $getSelection() === this;
    const newRange = $removeTextFromCaretRange($caretRangeFromSelection(this));
    $updateRangeSelectionFromCaretRange(this, newRange);
    if (isCurrentSelection && $getSelection() !== this) {
      $setSelection(this);
    }
  }
  // TO-DO: Migrate this method to the new utility function $forEachSelectedTextNode (share similar logic)
  /**
   * Applies the provided format to the TextNodes in the Selection, splitting or
   * merging nodes as necessary.
   *
   * @param formatType the format type to apply to the nodes in the Selection.
   * @param alignWithFormat a 32-bit integer representing formatting flags to align with.
   */
  formatText(formatType, alignWithFormat = null) {
    if (this.isCollapsed()) {
      this.toggleFormat(formatType);
      $setCompositionKey(null);
      return;
    }
    const selectedNodes = this.getNodes();
    const selectedTextNodes = [];
    for (const selectedNode of selectedNodes) {
      if ($isTextNode(selectedNode)) {
        selectedTextNodes.push(selectedNode);
      }
    }
    const applyFormatToElements = (alignWith) => {
      selectedNodes.forEach((node) => {
        if ($isElementNode(node)) {
          const newFormat = node.getFormatFlags(formatType, alignWith);
          node.setTextFormat(newFormat);
        }
      });
    };
    const selectedTextNodesLength = selectedTextNodes.length;
    if (selectedTextNodesLength === 0) {
      this.toggleFormat(formatType);
      $setCompositionKey(null);
      applyFormatToElements(alignWithFormat);
      return;
    }
    const anchor = this.anchor;
    const focus = this.focus;
    const isBackward = this.isBackward();
    const startPoint = isBackward ? focus : anchor;
    const endPoint = isBackward ? anchor : focus;
    let firstIndex = 0;
    let firstNode = selectedTextNodes[0];
    let startOffset = startPoint.type === "element" ? 0 : startPoint.offset;
    if (startPoint.type === "text" && startOffset === firstNode.getTextContentSize()) {
      firstIndex = 1;
      firstNode = selectedTextNodes[1];
      startOffset = 0;
    }
    if (firstNode == null) {
      return;
    }
    const firstNextFormat = firstNode.getFormatFlags(formatType, alignWithFormat);
    applyFormatToElements(firstNextFormat);
    const lastIndex = selectedTextNodesLength - 1;
    let lastNode = selectedTextNodes[lastIndex];
    const endOffset = endPoint.type === "text" ? endPoint.offset : lastNode.getTextContentSize();
    if (firstNode.is(lastNode)) {
      if (startOffset === endOffset) {
        return;
      }
      if ($isTokenOrSegmented(firstNode) || startOffset === 0 && endOffset === firstNode.getTextContentSize()) {
        firstNode.setFormat(firstNextFormat);
      } else {
        const splitNodes = firstNode.splitText(startOffset, endOffset);
        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];
        replacement.setFormat(firstNextFormat);
        if (startPoint.type === "text") {
          startPoint.set(replacement.__key, 0, "text");
        }
        if (endPoint.type === "text") {
          endPoint.set(replacement.__key, endOffset - startOffset, "text");
        }
      }
      this.format = firstNextFormat;
      return;
    }
    if (startOffset !== 0 && !$isTokenOrSegmented(firstNode)) {
      [, firstNode] = firstNode.splitText(startOffset);
      startOffset = 0;
    }
    firstNode.setFormat(firstNextFormat);
    const lastNextFormat = lastNode.getFormatFlags(formatType, firstNextFormat);
    if (endOffset > 0) {
      if (endOffset !== lastNode.getTextContentSize() && !$isTokenOrSegmented(lastNode)) {
        [lastNode] = lastNode.splitText(endOffset);
      }
      lastNode.setFormat(lastNextFormat);
    }
    for (let i2 = firstIndex + 1; i2 < lastIndex; i2++) {
      const textNode = selectedTextNodes[i2];
      const nextFormat = textNode.getFormatFlags(formatType, lastNextFormat);
      textNode.setFormat(nextFormat);
    }
    if (startPoint.type === "text") {
      startPoint.set(firstNode.__key, startOffset, "text");
    }
    if (endPoint.type === "text") {
      endPoint.set(lastNode.__key, endOffset, "text");
    }
    this.format = firstNextFormat | lastNextFormat;
  }
  /**
   * Attempts to "intelligently" insert an arbitrary list of Lexical nodes into the EditorState at the
   * current Selection according to a set of heuristics that determine how surrounding nodes
   * should be changed, replaced, or moved to accommodate the incoming ones.
   *
   * @param nodes - the nodes to insert
   */
  insertNodes(nodes) {
    if (nodes.length === 0) {
      return;
    }
    if (!this.isCollapsed()) {
      this.removeText();
    }
    if (this.anchor.key === "root") {
      this.insertParagraph();
      const selection = $getSelection();
      if (!$isRangeSelection(selection)) {
        formatDevErrorMessage(`Expected RangeSelection after insertParagraph`);
      }
      return selection.insertNodes(nodes);
    }
    const firstPoint = this.isBackward() ? this.focus : this.anchor;
    const firstNode = firstPoint.getNode();
    const firstBlock = $findMatchingParent(firstNode, INTERNAL_$isBlock);
    const last = nodes[nodes.length - 1];
    if ($isElementNode(firstBlock) && "__language" in firstBlock) {
      if ("__language" in nodes[0]) {
        this.insertText(nodes[0].getTextContent());
      } else {
        const index = $removeTextAndSplitBlock(this);
        firstBlock.splice(index, 0, nodes);
        last.selectEnd();
      }
      return;
    }
    const notInline = (node) => ($isElementNode(node) || $isDecoratorNode(node)) && !node.isInline();
    if (!nodes.some(notInline)) {
      if (!$isElementNode(firstBlock)) {
        formatDevErrorMessage(`Expected node ${firstNode.constructor.name} of type ${firstNode.getType()} to have a block ElementNode ancestor`);
      }
      const index = $removeTextAndSplitBlock(this);
      firstBlock.splice(index, 0, nodes);
      last.selectEnd();
      return;
    }
    const blocksParent = $wrapInlineNodes(nodes);
    const nodeToSelect = blocksParent.getLastDescendant();
    const blocks = blocksParent.getChildren();
    const isMergeable = (node) => $isElementNode(node) && INTERNAL_$isBlock(node) && !node.isEmpty() && $isElementNode(firstBlock) && (!firstBlock.isEmpty() || firstBlock.canMergeWhenEmpty());
    const shouldInsert = !$isElementNode(firstBlock) || !firstBlock.isEmpty();
    const insertedParagraph = shouldInsert ? this.insertParagraph() : null;
    const lastToInsert = blocks[blocks.length - 1];
    let firstToInsert = blocks[0];
    if (isMergeable(firstToInsert)) {
      if (!$isElementNode(firstBlock)) {
        formatDevErrorMessage(`Expected node ${firstNode.constructor.name} of type ${firstNode.getType()} to have a block ElementNode ancestor`);
      }
      firstBlock.append(...firstToInsert.getChildren());
      firstToInsert = blocks[1];
    }
    if (firstToInsert) {
      if (!(firstBlock !== null)) {
        formatDevErrorMessage(`Expected node ${firstNode.constructor.name} of type ${firstNode.getType()} to have a block ancestor`);
      }
      insertRangeAfter(firstBlock, firstToInsert);
    }
    const lastInsertedBlock = $findMatchingParent(nodeToSelect, INTERNAL_$isBlock);
    if (insertedParagraph && $isElementNode(lastInsertedBlock) && (insertedParagraph.canMergeWhenEmpty() || INTERNAL_$isBlock(lastToInsert))) {
      lastInsertedBlock.append(...insertedParagraph.getChildren());
      insertedParagraph.remove();
    }
    if ($isElementNode(firstBlock) && firstBlock.isEmpty()) {
      firstBlock.remove();
    }
    nodeToSelect.selectEnd();
    const lastChild = $isElementNode(firstBlock) ? firstBlock.getLastChild() : null;
    if ($isLineBreakNode(lastChild) && lastInsertedBlock !== firstBlock) {
      lastChild.remove();
    }
  }
  /**
   * Inserts a new ParagraphNode into the EditorState at the current Selection
   *
   * @returns the newly inserted node.
   */
  insertParagraph() {
    if (this.anchor.key === "root") {
      const paragraph = $createParagraphNode();
      $getRoot().splice(this.anchor.offset, 0, [paragraph]);
      paragraph.select();
      return paragraph;
    }
    const index = $removeTextAndSplitBlock(this);
    const block = $findMatchingParent(this.anchor.getNode(), INTERNAL_$isBlock);
    if (!$isElementNode(block)) {
      formatDevErrorMessage(`Expected ancestor to be a block ElementNode`);
    }
    const firstToAppend = block.getChildAtIndex(index);
    const nodesToInsert = firstToAppend ? [firstToAppend, ...firstToAppend.getNextSiblings()] : [];
    const newBlock = block.insertNewAfter(this, false);
    if (newBlock) {
      newBlock.append(...nodesToInsert);
      newBlock.selectStart();
      return newBlock;
    }
    return null;
  }
  /**
   * Inserts a logical linebreak, which may be a new LineBreakNode or a new ParagraphNode, into the EditorState at the
   * current Selection.
   */
  insertLineBreak(selectStart) {
    const lineBreak = $createLineBreakNode();
    this.insertNodes([lineBreak]);
    if (selectStart) {
      const parent = lineBreak.getParentOrThrow();
      const index = lineBreak.getIndexWithinParent();
      parent.select(index, index);
    }
  }
  /**
   * Extracts the nodes in the Selection, splitting nodes where necessary
   * to get offset-level precision.
   *
   * @returns The nodes in the Selection
   */
  extract() {
    const selectedNodes = [...this.getNodes()];
    const selectedNodesLength = selectedNodes.length;
    let firstNode = selectedNodes[0];
    let lastNode = selectedNodes[selectedNodesLength - 1];
    const [anchorOffset, focusOffset] = $getCharacterOffsets(this);
    const isBackward = this.isBackward();
    const [startPoint, endPoint] = isBackward ? [this.focus, this.anchor] : [this.anchor, this.focus];
    const [startOffset, endOffset] = isBackward ? [focusOffset, anchorOffset] : [anchorOffset, focusOffset];
    if (selectedNodesLength === 0) {
      return [];
    } else if (selectedNodesLength === 1) {
      if ($isTextNode(firstNode) && !this.isCollapsed()) {
        const splitNodes = firstNode.splitText(startOffset, endOffset);
        const node = startOffset === 0 ? splitNodes[0] : splitNodes[1];
        if (node) {
          startPoint.set(node.getKey(), 0, "text");
          endPoint.set(node.getKey(), node.getTextContentSize(), "text");
          return [node];
        }
        return [];
      }
      return [firstNode];
    }
    if ($isTextNode(firstNode)) {
      if (startOffset === firstNode.getTextContentSize()) {
        selectedNodes.shift();
      } else if (startOffset !== 0) {
        [, firstNode] = firstNode.splitText(startOffset);
        selectedNodes[0] = firstNode;
        startPoint.set(firstNode.getKey(), 0, "text");
      }
    }
    if ($isTextNode(lastNode)) {
      const lastNodeText = lastNode.getTextContent();
      const lastNodeTextLength = lastNodeText.length;
      if (endOffset === 0) {
        selectedNodes.pop();
      } else if (endOffset !== lastNodeTextLength) {
        [lastNode] = lastNode.splitText(endOffset);
        selectedNodes[selectedNodes.length - 1] = lastNode;
        endPoint.set(lastNode.getKey(), lastNode.getTextContentSize(), "text");
      }
    }
    return selectedNodes;
  }
  /**
   * Modifies the Selection according to the parameters and a set of heuristics that account for
   * various node types. Can be used to safely move or extend selection by one logical "unit" without
   * dealing explicitly with all the possible node types.
   *
   * @param alter the type of modification to perform
   * @param isBackward whether or not selection is backwards
   * @param granularity the granularity at which to apply the modification
   */
  modify(alter, isBackward, granularity) {
    if ($modifySelectionAroundDecoratorsAndBlocks(this, alter, isBackward, granularity)) {
      return;
    }
    const collapse = alter === "move";
    const editor = getActiveEditor();
    const domSelection = getDOMSelection(getWindow(editor));
    if (!domSelection) {
      return;
    }
    const blockCursorElement = editor._blockCursorElement;
    const rootElement = editor._rootElement;
    const focusNode = this.focus.getNode();
    if (rootElement !== null && blockCursorElement !== null && $isElementNode(focusNode) && !focusNode.isInline() && !focusNode.canBeEmpty()) {
      removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);
    }
    if (this.dirty) {
      let nextAnchorDOM = getElementByKeyOrThrow(editor, this.anchor.key);
      let nextFocusDOM = getElementByKeyOrThrow(editor, this.focus.key);
      if (this.anchor.type === "text") {
        nextAnchorDOM = getDOMTextNode(nextAnchorDOM);
      }
      if (this.focus.type === "text") {
        nextFocusDOM = getDOMTextNode(nextFocusDOM);
      }
      if (nextAnchorDOM && nextFocusDOM) {
        setDOMSelectionBaseAndExtent(domSelection, nextAnchorDOM, this.anchor.offset, nextFocusDOM, this.focus.offset);
      }
    }
    moveNativeSelection(domSelection, alter, isBackward ? "backward" : "forward", granularity);
    if (domSelection.rangeCount > 0) {
      const range = domSelection.getRangeAt(0);
      const anchorNode = this.anchor.getNode();
      const root = $isRootNode(anchorNode) ? anchorNode : $getNearestRootOrShadowRoot(anchorNode);
      this.applyDOMRange(range);
      this.dirty = true;
      if (!collapse) {
        const nodes = this.getNodes();
        const validNodes = [];
        let shrinkSelection = false;
        for (let i2 = 0; i2 < nodes.length; i2++) {
          const nextNode = nodes[i2];
          if ($hasAncestor(nextNode, root)) {
            validNodes.push(nextNode);
          } else {
            shrinkSelection = true;
          }
        }
        if (shrinkSelection && validNodes.length > 0) {
          if (isBackward) {
            const firstValidNode = validNodes[0];
            if ($isElementNode(firstValidNode)) {
              firstValidNode.selectStart();
            } else {
              firstValidNode.getParentOrThrow().selectStart();
            }
          } else {
            const lastValidNode = validNodes[validNodes.length - 1];
            if ($isElementNode(lastValidNode)) {
              lastValidNode.selectEnd();
            } else {
              lastValidNode.getParentOrThrow().selectEnd();
            }
          }
        }
        if (domSelection.anchorNode !== range.startContainer || domSelection.anchorOffset !== range.startOffset) {
          $swapPoints(this);
        }
      }
    }
    if (granularity === "lineboundary") {
      $modifySelectionAroundDecoratorsAndBlocks(this, alter, isBackward, granularity, "decorators");
    }
  }
  /**
   * Helper for handling forward character and word deletion that prevents element nodes
   * like a table, columns layout being destroyed
   *
   * @param anchor the anchor
   * @param anchorNode the anchor node in the selection
   * @param isBackward whether or not selection is backwards
   */
  forwardDeletion(anchor, anchorNode, isBackward) {
    if (!isBackward && // Delete forward handle case
    (anchor.type === "element" && $isElementNode(anchorNode) && anchor.offset === anchorNode.getChildrenSize() || anchor.type === "text" && anchor.offset === anchorNode.getTextContentSize())) {
      const parent = anchorNode.getParent();
      const nextSibling = anchorNode.getNextSibling() || (parent === null ? null : parent.getNextSibling());
      if ($isElementNode(nextSibling) && nextSibling.isShadowRoot()) {
        return true;
      }
    }
    return false;
  }
  /**
   * Performs one logical character deletion operation on the EditorState based on the current Selection.
   * Handles different node types.
   *
   * @param isBackward whether or not the selection is backwards.
   */
  deleteCharacter(isBackward) {
    const wasCollapsed = this.isCollapsed();
    if (this.isCollapsed()) {
      const anchor = this.anchor;
      let anchorNode = anchor.getNode();
      if (this.forwardDeletion(anchor, anchorNode, isBackward)) {
        return;
      }
      const direction = isBackward ? "previous" : "next";
      const initialCaret = $caretFromPoint(anchor, direction);
      const initialRange = $extendCaretToRange(initialCaret);
      if (initialRange.getTextSlices().every((slice) => slice === null || slice.distance === 0)) {
        let state = {
          type: "initial"
        };
        for (const caret of initialRange.iterNodeCarets("shadowRoot")) {
          if ($isChildCaret(caret)) {
            if (caret.origin.isInline()) ;
            else if (caret.origin.isShadowRoot()) {
              if (state.type === "merge-block") {
                break;
              }
              if ($isElementNode(initialRange.anchor.origin) && initialRange.anchor.origin.isEmpty()) {
                const normCaret = $normalizeCaret(caret);
                $updateRangeSelectionFromCaretRange(this, $getCaretRange(normCaret, normCaret));
                initialRange.anchor.origin.remove();
              }
              return;
            } else if (state.type === "merge-next-block" || state.type === "merge-block") {
              state = {
                block: state.block,
                caret,
                type: "merge-block"
              };
            }
          } else if (state.type === "merge-block") {
            break;
          } else if ($isSiblingCaret(caret)) {
            if ($isElementNode(caret.origin)) {
              if (!caret.origin.isInline()) {
                state = {
                  block: caret.origin,
                  type: "merge-next-block"
                };
              } else if (!caret.origin.isParentOf(initialRange.anchor.origin)) {
                break;
              }
              continue;
            } else if ($isDecoratorNode(caret.origin)) {
              if (caret.origin.isIsolated()) ;
              else if (state.type === "merge-next-block" && (caret.origin.isKeyboardSelectable() || !caret.origin.isInline()) && $isElementNode(initialRange.anchor.origin) && initialRange.anchor.origin.isEmpty()) {
                initialRange.anchor.origin.remove();
                const nodeSelection = $createNodeSelection();
                nodeSelection.add(caret.origin.getKey());
                $setSelection(nodeSelection);
              } else {
                caret.origin.remove();
              }
              return;
            }
            break;
          }
        }
        if (state.type === "merge-block") {
          const {
            caret,
            block
          } = state;
          $updateRangeSelectionFromCaretRange(this, $getCaretRange(!caret.origin.isEmpty() && block.isEmpty() ? $rewindSiblingCaret($getSiblingCaret(block, caret.direction)) : initialRange.anchor, caret));
          return this.removeText();
        }
      }
      const focus = this.focus;
      this.modify("extend", isBackward, "character");
      if (!this.isCollapsed()) {
        const focusNode = focus.type === "text" ? focus.getNode() : null;
        anchorNode = anchor.type === "text" ? anchor.getNode() : null;
        if (focusNode !== null && focusNode.isSegmented()) {
          const offset = focus.offset;
          const textContentSize = focusNode.getTextContentSize();
          if (focusNode.is(anchorNode) || isBackward && offset !== textContentSize || !isBackward && offset !== 0) {
            $removeSegment(focusNode, isBackward, offset);
            return;
          }
        } else if (anchorNode !== null && anchorNode.isSegmented()) {
          const offset = anchor.offset;
          const textContentSize = anchorNode.getTextContentSize();
          if (anchorNode.is(focusNode) || isBackward && offset !== 0 || !isBackward && offset !== textContentSize) {
            $removeSegment(anchorNode, isBackward, offset);
            return;
          }
        }
        $updateCaretSelectionForUnicodeCharacter(this, isBackward);
      } else if (isBackward && anchor.offset === 0) {
        if ($collapseAtStart(this, anchor.getNode())) {
          return;
        }
      }
    }
    this.removeText();
    if (isBackward && !wasCollapsed && this.isCollapsed() && this.anchor.type === "element" && this.anchor.offset === 0) {
      const anchorNode = this.anchor.getNode();
      if (anchorNode.isEmpty() && $isRootNode(anchorNode.getParent()) && anchorNode.getPreviousSibling() === null) {
        $collapseAtStart(this, anchorNode);
      }
    }
  }
  /**
   * Performs one logical line deletion operation on the EditorState based on the current Selection.
   * Handles different node types.
   *
   * @param isBackward whether or not the selection is backwards.
   */
  deleteLine(isBackward) {
    if (this.isCollapsed()) {
      this.modify("extend", isBackward, "lineboundary");
    }
    if (this.isCollapsed()) {
      this.deleteCharacter(isBackward);
    } else {
      this.removeText();
    }
  }
  /**
   * Performs one logical word deletion operation on the EditorState based on the current Selection.
   * Handles different node types.
   *
   * @param isBackward whether or not the selection is backwards.
   */
  deleteWord(isBackward) {
    if (this.isCollapsed()) {
      const anchor = this.anchor;
      const anchorNode = anchor.getNode();
      if (this.forwardDeletion(anchor, anchorNode, isBackward)) {
        return;
      }
      this.modify("extend", isBackward, "word");
    }
    this.removeText();
  }
  /**
   * Returns whether the Selection is "backwards", meaning the focus
   * logically precedes the anchor in the EditorState.
   * @returns true if the Selection is backwards, false otherwise.
   */
  isBackward() {
    return this.focus.isBefore(this.anchor);
  }
  getStartEndPoints() {
    return [this.anchor, this.focus];
  }
};
function $isNodeSelection(x) {
  return x instanceof NodeSelection;
}
function getCharacterOffset(point) {
  const offset = point.offset;
  if (point.type === "text") {
    return offset;
  }
  const parent = point.getNode();
  return offset === parent.getChildrenSize() ? parent.getTextContent().length : 0;
}
function $getCharacterOffsets(selection) {
  const anchorAndFocus = selection.getStartEndPoints();
  if (anchorAndFocus === null) {
    return [0, 0];
  }
  const [anchor, focus] = anchorAndFocus;
  if (anchor.type === "element" && focus.type === "element" && anchor.key === focus.key && anchor.offset === focus.offset) {
    return [0, 0];
  }
  return [getCharacterOffset(anchor), getCharacterOffset(focus)];
}
function $collapseAtStart(selection, startNode) {
  for (let node = startNode; node; node = node.getParent()) {
    if ($isElementNode(node)) {
      if (node.collapseAtStart(selection)) {
        return true;
      }
      if ($isRootOrShadowRoot(node)) {
        break;
      }
    }
    if (node.getPreviousSibling()) {
      break;
    }
  }
  return false;
}
function $swapPoints(selection) {
  const focus = selection.focus;
  const anchor = selection.anchor;
  const anchorKey = anchor.key;
  const anchorOffset = anchor.offset;
  const anchorType = anchor.type;
  anchor.set(focus.key, focus.offset, focus.type, true);
  focus.set(anchorKey, anchorOffset, anchorType, true);
}
function moveNativeSelection(domSelection, alter, direction, granularity) {
  domSelection.modify(alter, direction, granularity);
}
function $updateCaretSelectionForUnicodeCharacter(selection, isBackward) {
  const anchor = selection.anchor;
  const focus = selection.focus;
  const anchorNode = anchor.getNode();
  const focusNode = focus.getNode();
  if (anchorNode === focusNode && anchor.type === "text" && focus.type === "text") {
    const anchorOffset = anchor.offset;
    const focusOffset = focus.offset;
    const isBefore = anchorOffset < focusOffset;
    const startOffset = isBefore ? anchorOffset : focusOffset;
    const endOffset = isBefore ? focusOffset : anchorOffset;
    const characterOffset = endOffset - 1;
    if (startOffset !== characterOffset) {
      const text = anchorNode.getTextContent().slice(startOffset, endOffset);
      if (shouldDeleteExactlyOneCodeUnit(text)) {
        if (isBackward) {
          focus.set(focus.key, characterOffset, focus.type);
        } else {
          anchor.set(anchor.key, characterOffset, anchor.type);
        }
      }
    }
  }
}
function shouldDeleteExactlyOneCodeUnit(text) {
  {
    if (!(text.length > 1)) {
      formatDevErrorMessage(`shouldDeleteExactlyOneCodeUnit: expecting to be called only with sequences of two or more code units`);
    }
  }
  return !(doesContainSurrogatePair(text) || doesContainEmoji(text));
}
var doesContainEmoji = (() => {
  try {
    const re = new RegExp("\\p{Emoji}", "u");
    const test = re.test.bind(re);
    if (
      // Emoji in the BMP (heart) with variation selector
      test("\u2764\uFE0F") && // Emoji in the BMP (#) with variation selector
      test("#\uFE0F\u20E3") && // Emoji outside the BMP (thumbs up) that is encoded with a surrogate pair
      test("\u{1F44D}")
    ) {
      return test;
    }
  } catch (_e) {
  }
  return () => false;
})();
function $removeSegment(node, isBackward, offset) {
  const textNode = node;
  const textContent = textNode.getTextContent();
  const split = textContent.split(/(?=\s)/g);
  const splitLength = split.length;
  let segmentOffset = 0;
  let restoreOffset = 0;
  for (let i2 = 0; i2 < splitLength; i2++) {
    const text = split[i2];
    const isLast = i2 === splitLength - 1;
    restoreOffset = segmentOffset;
    segmentOffset += text.length;
    if (isBackward && segmentOffset === offset || segmentOffset > offset || isLast) {
      split.splice(i2, 1);
      if (isLast) {
        restoreOffset = void 0;
      }
      break;
    }
  }
  const nextTextContent = split.join("").trim();
  if (nextTextContent === "") {
    textNode.remove();
  } else {
    textNode.setTextContent(nextTextContent);
    textNode.select(restoreOffset, restoreOffset);
  }
}
function shouldResolveAncestor(resolvedElement, resolvedOffset, lastPoint) {
  const parent = resolvedElement.getParent();
  return lastPoint === null || parent === null || !parent.canBeEmpty() || parent !== lastPoint.getNode();
}
function $internalResolveSelectionPoint(dom, offset, lastPoint, editor) {
  let resolvedOffset = offset;
  let resolvedNode;
  if (isHTMLElement(dom)) {
    let moveSelectionToEnd = false;
    const childNodes = dom.childNodes;
    const childNodesLength = childNodes.length;
    const blockCursorElement = editor._blockCursorElement;
    if (resolvedOffset === childNodesLength) {
      moveSelectionToEnd = true;
      resolvedOffset = childNodesLength - 1;
    }
    let childDOM = childNodes[resolvedOffset];
    let hasBlockCursor = false;
    if (childDOM === blockCursorElement) {
      childDOM = childNodes[resolvedOffset + 1];
      hasBlockCursor = true;
    } else if (blockCursorElement !== null) {
      const blockCursorElementParent = blockCursorElement.parentNode;
      if (dom === blockCursorElementParent) {
        const blockCursorOffset = Array.prototype.indexOf.call(blockCursorElementParent.children, blockCursorElement);
        if (offset > blockCursorOffset) {
          resolvedOffset--;
        }
      }
    }
    resolvedNode = $getNodeFromDOM(childDOM);
    if ($isTextNode(resolvedNode)) {
      resolvedOffset = $getTextNodeOffset(resolvedNode, moveSelectionToEnd ? "next" : "previous");
    } else {
      let resolvedElement = $getNodeFromDOM(dom);
      if (resolvedElement === null) {
        return null;
      }
      if ($isElementNode(resolvedElement)) {
        const elementDOM = editor.getElementByKey(resolvedElement.getKey());
        if (!(elementDOM !== null)) {
          formatDevErrorMessage(`$internalResolveSelectionPoint: node in DOM but not keyToDOMMap`);
        }
        const slot = resolvedElement.getDOMSlot(elementDOM);
        [resolvedElement, resolvedOffset] = slot.resolveChildIndex(resolvedElement, elementDOM, dom, offset);
        if (!$isElementNode(resolvedElement)) {
          formatDevErrorMessage(`$internalResolveSelectionPoint: resolvedElement is not an ElementNode`);
        }
        if (moveSelectionToEnd && resolvedOffset >= resolvedElement.getChildrenSize()) {
          resolvedOffset = Math.max(0, resolvedElement.getChildrenSize() - 1);
        }
        let child = resolvedElement.getChildAtIndex(resolvedOffset);
        if ($isElementNode(child) && shouldResolveAncestor(child, resolvedOffset, lastPoint)) {
          const descendant = moveSelectionToEnd ? child.getLastDescendant() : child.getFirstDescendant();
          if (descendant === null) {
            resolvedElement = child;
          } else {
            child = descendant;
            resolvedElement = $isElementNode(child) ? child : child.getParentOrThrow();
          }
          resolvedOffset = 0;
        }
        if ($isTextNode(child)) {
          resolvedNode = child;
          resolvedElement = null;
          resolvedOffset = $getTextNodeOffset(child, moveSelectionToEnd ? "next" : "previous");
        } else if (child !== resolvedElement && moveSelectionToEnd && !hasBlockCursor) {
          if (!$isElementNode(resolvedElement)) {
            formatDevErrorMessage(`invariant`);
          }
          resolvedOffset = Math.min(resolvedElement.getChildrenSize(), resolvedOffset + 1);
        }
      } else {
        const index = resolvedElement.getIndexWithinParent();
        if (offset === 0 && $isDecoratorNode(resolvedElement) && $getNodeFromDOM(dom) === resolvedElement) {
          resolvedOffset = index;
        } else {
          resolvedOffset = index + 1;
        }
        resolvedElement = resolvedElement.getParentOrThrow();
      }
      if ($isElementNode(resolvedElement)) {
        return $createPoint(resolvedElement.__key, resolvedOffset, "element");
      }
    }
  } else {
    resolvedNode = $getNodeFromDOM(dom);
  }
  if (!$isTextNode(resolvedNode)) {
    return null;
  }
  return $createPoint(resolvedNode.__key, $getTextNodeOffset(resolvedNode, resolvedOffset, "clamp"), "text");
}
function resolveSelectionPointOnBoundary(point, isBackward, isCollapsed) {
  const offset = point.offset;
  const node = point.getNode();
  if (offset === 0) {
    const prevSibling = node.getPreviousSibling();
    const parent = node.getParent();
    if (!isBackward) {
      if ($isElementNode(prevSibling) && !isCollapsed && prevSibling.isInline()) {
        point.set(prevSibling.__key, prevSibling.getChildrenSize(), "element");
      } else if ($isTextNode(prevSibling)) {
        point.set(prevSibling.__key, prevSibling.getTextContent().length, "text");
      }
    } else if ((isCollapsed || !isBackward) && prevSibling === null && $isElementNode(parent) && parent.isInline()) {
      const parentSibling = parent.getPreviousSibling();
      if ($isTextNode(parentSibling)) {
        point.set(parentSibling.__key, parentSibling.getTextContent().length, "text");
      }
    }
  } else if (offset === node.getTextContent().length) {
    const nextSibling = node.getNextSibling();
    const parent = node.getParent();
    if (isBackward && $isElementNode(nextSibling) && nextSibling.isInline()) {
      point.set(nextSibling.__key, 0, "element");
    } else if ((isCollapsed || isBackward) && nextSibling === null && $isElementNode(parent) && parent.isInline() && !parent.canInsertTextAfter()) {
      const parentSibling = parent.getNextSibling();
      if ($isTextNode(parentSibling)) {
        point.set(parentSibling.__key, 0, "text");
      }
    }
  }
}
function $normalizeSelectionPointsForBoundaries(anchor, focus, lastSelection) {
  if (anchor.type === "text" && focus.type === "text") {
    const isBackward = anchor.isBefore(focus);
    const isCollapsed = anchor.is(focus);
    resolveSelectionPointOnBoundary(anchor, isBackward, isCollapsed);
    resolveSelectionPointOnBoundary(focus, !isBackward, isCollapsed);
    if (isCollapsed) {
      focus.set(anchor.key, anchor.offset, anchor.type);
    }
    const editor = getActiveEditor();
    if (editor.isComposing() && editor._compositionKey !== anchor.key && $isRangeSelection(lastSelection)) {
      const lastAnchor = lastSelection.anchor;
      const lastFocus = lastSelection.focus;
      anchor.set(lastAnchor.key, lastAnchor.offset, lastAnchor.type, true);
      focus.set(lastFocus.key, lastFocus.offset, lastFocus.type, true);
    }
  }
}
function $internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection) {
  if (anchorDOM === null || focusDOM === null || !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {
    return null;
  }
  const resolvedAnchorPoint = $internalResolveSelectionPoint(anchorDOM, anchorOffset, $isRangeSelection(lastSelection) ? lastSelection.anchor : null, editor);
  if (resolvedAnchorPoint === null) {
    return null;
  }
  const resolvedFocusPoint = $internalResolveSelectionPoint(focusDOM, focusOffset, $isRangeSelection(lastSelection) ? lastSelection.focus : null, editor);
  if (resolvedFocusPoint === null) {
    return null;
  }
  {
    $validatePoint("anchor", resolvedAnchorPoint);
    $validatePoint("focus", resolvedFocusPoint);
  }
  if (resolvedAnchorPoint.type === "element" && resolvedFocusPoint.type === "element") {
    const anchorNode = $getNodeFromDOM(anchorDOM);
    const focusNode = $getNodeFromDOM(focusDOM);
    if ($isDecoratorNode(anchorNode) && $isDecoratorNode(focusNode)) {
      return null;
    }
  }
  $normalizeSelectionPointsForBoundaries(resolvedAnchorPoint, resolvedFocusPoint, lastSelection);
  return [resolvedAnchorPoint, resolvedFocusPoint];
}
function $isBlockElementNode(node) {
  return $isElementNode(node) && !node.isInline();
}
function $internalMakeRangeSelection(anchorKey, anchorOffset, focusKey, focusOffset, anchorType, focusType) {
  const editorState = getActiveEditorState();
  const selection = new RangeSelection($createPoint(anchorKey, anchorOffset, anchorType), $createPoint(focusKey, focusOffset, focusType), 0, "");
  selection.dirty = true;
  editorState._selection = selection;
  return selection;
}
function $createRangeSelection() {
  const anchor = $createPoint("root", 0, "element");
  const focus = $createPoint("root", 0, "element");
  return new RangeSelection(anchor, focus, 0, "");
}
function $createNodeSelection() {
  return new NodeSelection(/* @__PURE__ */ new Set());
}
function $internalCreateSelection(editor, event) {
  const currentEditorState = editor.getEditorState();
  const lastSelection = currentEditorState._selection;
  const domSelection = getDOMSelection(getWindow(editor));
  if ($isRangeSelection(lastSelection) || lastSelection == null) {
    return $internalCreateRangeSelection(lastSelection, domSelection, editor, event);
  }
  return lastSelection.clone();
}
function $createRangeSelectionFromDom(domSelection, editor) {
  return $internalCreateRangeSelection(null, domSelection, editor, null);
}
function $internalCreateRangeSelection(lastSelection, domSelection, editor, event) {
  const windowObj = editor._window;
  if (windowObj === null) {
    return null;
  }
  const windowEvent = event || windowObj.event;
  const eventType = windowEvent ? windowEvent.type : void 0;
  const isSelectionChange = eventType === "selectionchange";
  const useDOMSelection = !getIsProcessingMutations() && (isSelectionChange || eventType === "beforeinput" || eventType === "compositionstart" || eventType === "compositionend" || eventType === "click" && windowEvent && windowEvent.detail === 3 || eventType === "drop" || eventType === void 0);
  let anchorDOM, focusDOM, anchorOffset, focusOffset;
  if (!$isRangeSelection(lastSelection) || useDOMSelection) {
    if (domSelection === null) {
      return null;
    }
    anchorDOM = domSelection.anchorNode;
    focusDOM = domSelection.focusNode;
    anchorOffset = domSelection.anchorOffset;
    focusOffset = domSelection.focusOffset;
    if ((isSelectionChange || eventType === void 0) && $isRangeSelection(lastSelection) && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {
      return lastSelection.clone();
    }
  } else {
    return lastSelection.clone();
  }
  const resolvedSelectionPoints = $internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection);
  if (resolvedSelectionPoints === null) {
    return null;
  }
  const [resolvedAnchorPoint, resolvedFocusPoint] = resolvedSelectionPoints;
  return new RangeSelection(resolvedAnchorPoint, resolvedFocusPoint, !$isRangeSelection(lastSelection) ? 0 : lastSelection.format, !$isRangeSelection(lastSelection) ? "" : lastSelection.style);
}
function $validatePoint(name, point) {
  const node = $getNodeByKey(point.key);
  if (!(node !== void 0)) {
    formatDevErrorMessage(`$validatePoint: ${name} key ${point.key} not found in current editorState`);
  }
  if (point.type === "text") {
    if (!$isTextNode(node)) {
      formatDevErrorMessage(`$validatePoint: ${name} key ${point.key} is not a TextNode`);
    }
    const size = node.getTextContentSize();
    if (!(point.offset <= size)) {
      formatDevErrorMessage(`$validatePoint: ${name} point.offset > node.getTextContentSize() (${String(point.offset)} > ${String(size)})`);
    }
  } else {
    if (!$isElementNode(node)) {
      formatDevErrorMessage(`$validatePoint: ${name} key ${point.key} is not an ElementNode`);
    }
    const size = node.getChildrenSize();
    if (!(point.offset <= size)) {
      formatDevErrorMessage(`$validatePoint: ${name} point.offset > node.getChildrenSize() (${String(point.offset)} > ${String(size)})`);
    }
  }
}
function $getSelection() {
  const editorState = getActiveEditorState();
  return editorState._selection;
}
function $getPreviousSelection() {
  const editor = getActiveEditor();
  return editor._editorState._selection;
}
function $updateElementSelectionOnCreateDeleteNode(selection, parentNode, nodeOffset, times = 1) {
  const anchor = selection.anchor;
  const focus = selection.focus;
  const anchorNode = anchor.getNode();
  const focusNode = focus.getNode();
  if (!parentNode.is(anchorNode) && !parentNode.is(focusNode)) {
    return;
  }
  const parentKey = parentNode.__key;
  if (selection.isCollapsed()) {
    const selectionOffset = anchor.offset;
    if (nodeOffset <= selectionOffset && times > 0 || nodeOffset < selectionOffset && times < 0) {
      const newSelectionOffset = Math.max(0, selectionOffset + times);
      anchor.set(parentKey, newSelectionOffset, "element");
      focus.set(parentKey, newSelectionOffset, "element");
      $updateSelectionResolveTextNodes(selection);
    }
  } else {
    const isBackward = selection.isBackward();
    const firstPoint = isBackward ? focus : anchor;
    const firstPointNode = firstPoint.getNode();
    const lastPoint = isBackward ? anchor : focus;
    const lastPointNode = lastPoint.getNode();
    if (parentNode.is(firstPointNode)) {
      const firstPointOffset = firstPoint.offset;
      if (nodeOffset <= firstPointOffset && times > 0 || nodeOffset < firstPointOffset && times < 0) {
        firstPoint.set(parentKey, Math.max(0, firstPointOffset + times), "element");
      }
    }
    if (parentNode.is(lastPointNode)) {
      const lastPointOffset = lastPoint.offset;
      if (nodeOffset <= lastPointOffset && times > 0 || nodeOffset < lastPointOffset && times < 0) {
        lastPoint.set(parentKey, Math.max(0, lastPointOffset + times), "element");
      }
    }
  }
  $updateSelectionResolveTextNodes(selection);
}
function $updateSelectionResolveTextNodes(selection) {
  const anchor = selection.anchor;
  const anchorOffset = anchor.offset;
  const focus = selection.focus;
  const focusOffset = focus.offset;
  const anchorNode = anchor.getNode();
  const focusNode = focus.getNode();
  if (selection.isCollapsed()) {
    if (!$isElementNode(anchorNode)) {
      return;
    }
    const childSize = anchorNode.getChildrenSize();
    const anchorOffsetAtEnd = anchorOffset >= childSize;
    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);
    if ($isTextNode(child)) {
      let newOffset = 0;
      if (anchorOffsetAtEnd) {
        newOffset = child.getTextContentSize();
      }
      anchor.set(child.__key, newOffset, "text");
      focus.set(child.__key, newOffset, "text");
    }
    return;
  }
  if ($isElementNode(anchorNode)) {
    const childSize = anchorNode.getChildrenSize();
    const anchorOffsetAtEnd = anchorOffset >= childSize;
    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);
    if ($isTextNode(child)) {
      let newOffset = 0;
      if (anchorOffsetAtEnd) {
        newOffset = child.getTextContentSize();
      }
      anchor.set(child.__key, newOffset, "text");
    }
  }
  if ($isElementNode(focusNode)) {
    const childSize = focusNode.getChildrenSize();
    const focusOffsetAtEnd = focusOffset >= childSize;
    const child = focusOffsetAtEnd ? focusNode.getChildAtIndex(childSize - 1) : focusNode.getChildAtIndex(focusOffset);
    if ($isTextNode(child)) {
      let newOffset = 0;
      if (focusOffsetAtEnd) {
        newOffset = child.getTextContentSize();
      }
      focus.set(child.__key, newOffset, "text");
    }
  }
}
function applySelectionTransforms(nextEditorState, editor) {
  const prevEditorState = editor.getEditorState();
  const prevSelection = prevEditorState._selection;
  const nextSelection = nextEditorState._selection;
  if ($isRangeSelection(nextSelection)) {
    const anchor = nextSelection.anchor;
    const focus = nextSelection.focus;
    let anchorNode;
    if (anchor.type === "text") {
      anchorNode = anchor.getNode();
      anchorNode.selectionTransform(prevSelection, nextSelection);
    }
    if (focus.type === "text") {
      const focusNode = focus.getNode();
      if (anchorNode !== focusNode) {
        focusNode.selectionTransform(prevSelection, nextSelection);
      }
    }
  }
}
function moveSelectionPointToSibling(point, node, parent, prevSibling, nextSibling) {
  let siblingKey = null;
  let offset = 0;
  let type = null;
  if (prevSibling !== null) {
    siblingKey = prevSibling.__key;
    if ($isTextNode(prevSibling)) {
      offset = prevSibling.getTextContentSize();
      type = "text";
    } else if ($isElementNode(prevSibling)) {
      offset = prevSibling.getChildrenSize();
      type = "element";
    }
  } else {
    if (nextSibling !== null) {
      siblingKey = nextSibling.__key;
      if ($isTextNode(nextSibling)) {
        type = "text";
      } else if ($isElementNode(nextSibling)) {
        type = "element";
      }
    }
  }
  if (siblingKey !== null && type !== null) {
    point.set(siblingKey, offset, type);
  } else {
    offset = node.getIndexWithinParent();
    if (offset === -1) {
      offset = parent.getChildrenSize();
    }
    point.set(parent.__key, offset, "element");
  }
}
function adjustPointOffsetForMergedSibling(point, isBefore, key, target, textLength) {
  if (point.type === "text") {
    point.set(key, point.offset + (isBefore ? 0 : textLength), "text");
  } else if (point.offset > target.getIndexWithinParent()) {
    point.set(point.key, point.offset - 1, "element");
  }
}
function setDOMSelectionBaseAndExtent(domSelection, nextAnchorDOM, nextAnchorOffset, nextFocusDOM, nextFocusOffset) {
  try {
    domSelection.setBaseAndExtent(nextAnchorDOM, nextAnchorOffset, nextFocusDOM, nextFocusOffset);
  } catch (error) {
    {
      console.warn(error);
    }
  }
}
function updateDOMSelection(prevSelection, nextSelection, editor, domSelection, tags, rootElement, nodeCount) {
  const anchorDOMNode = domSelection.anchorNode;
  const focusDOMNode = domSelection.focusNode;
  const anchorOffset = domSelection.anchorOffset;
  const focusOffset = domSelection.focusOffset;
  const activeElement = document.activeElement;
  if (tags.has(COLLABORATION_TAG) && activeElement !== rootElement || activeElement !== null && isSelectionCapturedInDecoratorInput(activeElement)) {
    return;
  }
  if (!$isRangeSelection(nextSelection)) {
    if (prevSelection !== null && isSelectionWithinEditor(editor, anchorDOMNode, focusDOMNode)) {
      domSelection.removeAllRanges();
    }
    return;
  }
  const anchor = nextSelection.anchor;
  const focus = nextSelection.focus;
  const anchorKey = anchor.key;
  const focusKey = focus.key;
  const anchorDOM = getElementByKeyOrThrow(editor, anchorKey);
  const focusDOM = getElementByKeyOrThrow(editor, focusKey);
  const nextAnchorOffset = anchor.offset;
  const nextFocusOffset = focus.offset;
  const nextFormat = nextSelection.format;
  const nextStyle = nextSelection.style;
  const isCollapsed = nextSelection.isCollapsed();
  let nextAnchorNode = anchorDOM;
  let nextFocusNode = focusDOM;
  let anchorFormatOrStyleChanged = false;
  if (anchor.type === "text") {
    nextAnchorNode = getDOMTextNode(anchorDOM);
    const anchorNode = anchor.getNode();
    anchorFormatOrStyleChanged = anchorNode.getFormat() !== nextFormat || anchorNode.getStyle() !== nextStyle;
  } else if ($isRangeSelection(prevSelection) && prevSelection.anchor.type === "text") {
    anchorFormatOrStyleChanged = true;
  }
  if (focus.type === "text") {
    nextFocusNode = getDOMTextNode(focusDOM);
  }
  if (nextAnchorNode === null || nextFocusNode === null) {
    return;
  }
  if (isCollapsed && (prevSelection === null || anchorFormatOrStyleChanged || $isRangeSelection(prevSelection) && (prevSelection.format !== nextFormat || prevSelection.style !== nextStyle))) {
    markCollapsedSelectionFormat(nextFormat, nextStyle, nextAnchorOffset, anchorKey, performance.now());
  }
  if (anchorOffset === nextAnchorOffset && focusOffset === nextFocusOffset && anchorDOMNode === nextAnchorNode && focusDOMNode === nextFocusNode && // Badly interpreted range selection when collapsed - #1482
  !(domSelection.type === "Range" && isCollapsed)) {
    if (activeElement === null || !rootElement.contains(activeElement)) {
      if (!tags.has(SKIP_SELECTION_FOCUS_TAG)) {
        rootElement.focus({
          preventScroll: true
        });
      }
    }
    if (anchor.type !== "element") {
      return;
    }
  }
  setDOMSelectionBaseAndExtent(domSelection, nextAnchorNode, nextAnchorOffset, nextFocusNode, nextFocusOffset);
  if (!tags.has(SKIP_SCROLL_INTO_VIEW_TAG) && nextSelection.isCollapsed() && rootElement !== null && rootElement === document.activeElement) {
    const selectionTarget = $isRangeSelection(nextSelection) && nextSelection.anchor.type === "element" ? nextAnchorNode.childNodes[nextAnchorOffset] || null : domSelection.rangeCount > 0 ? domSelection.getRangeAt(0) : null;
    if (selectionTarget !== null) {
      let selectionRect;
      if (selectionTarget instanceof Text) {
        const range = document.createRange();
        range.selectNode(selectionTarget);
        selectionRect = range.getBoundingClientRect();
      } else {
        selectionRect = selectionTarget.getBoundingClientRect();
      }
      scrollIntoViewIfNeeded(editor, selectionRect, rootElement);
    }
  }
  markSelectionChangeFromDOMUpdate();
}
function $insertNodes(nodes) {
  let selection = $getSelection() || $getPreviousSelection();
  if (selection === null) {
    selection = $getRoot().selectEnd();
  }
  selection.insertNodes(nodes);
}
function $getTextContent() {
  const selection = $getSelection();
  if (selection === null) {
    return "";
  }
  return selection.getTextContent();
}
function $removeTextAndSplitBlock(selection) {
  let selection_ = selection;
  if (!selection.isCollapsed()) {
    selection_.removeText();
  }
  const newSelection = $getSelection();
  if ($isRangeSelection(newSelection)) {
    selection_ = newSelection;
  }
  if (!$isRangeSelection(selection_)) {
    formatDevErrorMessage(`Unexpected dirty selection to be null`);
  }
  const anchor = selection_.anchor;
  let node = anchor.getNode();
  let offset = anchor.offset;
  while (!INTERNAL_$isBlock(node)) {
    const prevNode = node;
    [node, offset] = $splitNodeAtPoint(node, offset);
    if (prevNode.is(node)) {
      break;
    }
  }
  return offset;
}
function $splitNodeAtPoint(node, offset) {
  const parent = node.getParent();
  if (!parent) {
    const paragraph = $createParagraphNode();
    $getRoot().append(paragraph);
    paragraph.select();
    return [$getRoot(), 0];
  }
  if ($isTextNode(node)) {
    const split = node.splitText(offset);
    if (split.length === 0) {
      return [parent, node.getIndexWithinParent()];
    }
    const x = offset === 0 ? 0 : 1;
    const index = split[0].getIndexWithinParent() + x;
    return [parent, index];
  }
  if (!$isElementNode(node) || offset === 0) {
    return [parent, node.getIndexWithinParent()];
  }
  const firstToAppend = node.getChildAtIndex(offset);
  if (firstToAppend) {
    const insertPoint = new RangeSelection($createPoint(node.__key, offset, "element"), $createPoint(node.__key, offset, "element"), 0, "");
    const newElement = node.insertNewAfter(insertPoint);
    if (newElement) {
      newElement.append(firstToAppend, ...firstToAppend.getNextSiblings());
    }
  }
  return [parent, node.getIndexWithinParent() + 1];
}
function $wrapInlineNodes(nodes) {
  const virtualRoot = $createParagraphNode();
  let currentBlock = null;
  for (let i2 = 0; i2 < nodes.length; i2++) {
    const node = nodes[i2];
    const isLineBreakNode = $isLineBreakNode(node);
    if (isLineBreakNode || $isDecoratorNode(node) && node.isInline() || $isElementNode(node) && node.isInline() || $isTextNode(node) || node.isParentRequired()) {
      if (currentBlock === null) {
        currentBlock = node.createParentElementNode();
        virtualRoot.append(currentBlock);
        if (isLineBreakNode) {
          continue;
        }
      }
      if (currentBlock !== null) {
        currentBlock.append(node);
      }
    } else {
      virtualRoot.append(node);
      currentBlock = null;
    }
  }
  return virtualRoot;
}
function $getNodesFromCaretRangeCompat(range) {
  const nodes = [];
  const [beforeSlice, afterSlice] = range.getTextSlices();
  if (beforeSlice) {
    nodes.push(beforeSlice.caret.origin);
  }
  const seenAncestors = /* @__PURE__ */ new Set();
  const seenElements = /* @__PURE__ */ new Set();
  for (const caret of range) {
    if ($isChildCaret(caret)) {
      const {
        origin
      } = caret;
      if (nodes.length === 0) {
        seenAncestors.add(origin);
      } else {
        seenElements.add(origin);
        nodes.push(origin);
      }
    } else {
      const {
        origin
      } = caret;
      if (!$isElementNode(origin) || !seenElements.has(origin)) {
        nodes.push(origin);
      }
    }
  }
  if (afterSlice) {
    nodes.push(afterSlice.caret.origin);
  }
  if ($isSiblingCaret(range.focus) && $isElementNode(range.focus.origin) && range.focus.getNodeAtCaret() === null) {
    for (let reverseCaret = $getChildCaret(range.focus.origin, "previous"); $isChildCaret(reverseCaret) && seenAncestors.has(reverseCaret.origin) && !reverseCaret.origin.isEmpty() && reverseCaret.origin.is(nodes[nodes.length - 1]); reverseCaret = $getAdjacentChildCaret(reverseCaret)) {
      seenAncestors.delete(reverseCaret.origin);
      nodes.pop();
    }
  }
  while (nodes.length > 1) {
    const lastIncludedNode = nodes[nodes.length - 1];
    if ($isElementNode(lastIncludedNode)) {
      if (seenElements.has(lastIncludedNode) || lastIncludedNode.isEmpty() || seenAncestors.has(lastIncludedNode)) ;
      else {
        nodes.pop();
        continue;
      }
    }
    break;
  }
  if (nodes.length === 0 && range.isCollapsed()) {
    const normCaret = $normalizeCaret(range.anchor);
    const flippedNormCaret = $normalizeCaret(range.anchor.getFlipped());
    const $getCandidate = (caret) => $isTextPointCaret(caret) ? caret.origin : caret.getNodeAtCaret();
    const node = $getCandidate(normCaret) || $getCandidate(flippedNormCaret) || (range.anchor.getNodeAtCaret() ? normCaret.origin : flippedNormCaret.origin);
    nodes.push(node);
  }
  return nodes;
}
function $modifySelectionAroundDecoratorsAndBlocks(selection, alter, isBackward, granularity, mode = "decorators-and-blocks") {
  if (alter === "move" && granularity === "character" && !selection.isCollapsed()) {
    const [src, dst] = isBackward === selection.isBackward() ? [selection.focus, selection.anchor] : [selection.anchor, selection.focus];
    dst.set(src.key, src.offset, src.type);
    return true;
  }
  const initialFocus = $caretFromPoint(selection.focus, isBackward ? "previous" : "next");
  const isLineBoundary = granularity === "lineboundary";
  const collapse = alter === "move";
  let focus = initialFocus;
  let checkForBlock = mode === "decorators-and-blocks";
  if (!$isExtendableTextPointCaret(focus)) {
    for (const siblingCaret of focus) {
      checkForBlock = false;
      const {
        origin
      } = siblingCaret;
      if ($isDecoratorNode(origin) && !origin.isIsolated()) {
        focus = siblingCaret;
        if (isLineBoundary && origin.isInline()) {
          continue;
        }
      }
      break;
    }
    if (checkForBlock) {
      for (const nextCaret of $extendCaretToRange(initialFocus).iterNodeCarets(alter === "extend" ? "shadowRoot" : "root")) {
        if ($isChildCaret(nextCaret)) {
          if (!nextCaret.origin.isInline()) {
            focus = nextCaret;
          }
        } else if ($isElementNode(nextCaret.origin)) {
          continue;
        } else if ($isDecoratorNode(nextCaret.origin) && !nextCaret.origin.isInline()) {
          focus = nextCaret;
        }
        break;
      }
    }
  }
  if (focus === initialFocus) {
    return false;
  }
  if (collapse && !isLineBoundary && $isDecoratorNode(focus.origin) && focus.origin.isKeyboardSelectable()) {
    const nodeSelection = $createNodeSelection();
    nodeSelection.add(focus.origin.getKey());
    $setSelection(nodeSelection);
    return true;
  }
  focus = $normalizeCaret(focus);
  if (collapse) {
    $setPointFromCaret(selection.anchor, focus);
  }
  $setPointFromCaret(selection.focus, focus);
  return checkForBlock || !isLineBoundary;
}
var activeEditorState = null;
var activeEditor = null;
var isReadOnlyMode = false;
var isAttemptingToRecoverFromReconcilerError = false;
var infiniteTransformCount = 0;
var observerOptions = {
  characterData: true,
  childList: true,
  subtree: true
};
function isCurrentlyReadOnlyMode() {
  return isReadOnlyMode || activeEditorState !== null && activeEditorState._readOnly;
}
function errorOnReadOnly() {
  if (isReadOnlyMode) {
    {
      formatDevErrorMessage(`Cannot use method in read-only mode.`);
    }
  }
}
function errorOnInfiniteTransforms() {
  if (infiniteTransformCount > 99) {
    {
      formatDevErrorMessage(`One or more transforms are endlessly triggering additional transforms. May have encountered infinite recursion caused by transforms that have their preconditions too lose and/or conflict with each other.`);
    }
  }
}
function getActiveEditorState() {
  if (activeEditorState === null) {
    {
      formatDevErrorMessage(`Unable to find an active editor state. State helpers or node methods can only be used synchronously during the callback of editor.update(), editor.read(), or editorState.read().${collectBuildInformation()}`);
    }
  }
  return activeEditorState;
}
function getActiveEditor() {
  if (activeEditor === null) {
    {
      formatDevErrorMessage(`Unable to find an active editor. This method can only be used synchronously during the callback of editor.update() or editor.read().${collectBuildInformation()}`);
    }
  }
  return activeEditor;
}
function collectBuildInformation() {
  let compatibleEditors = 0;
  const incompatibleEditors = /* @__PURE__ */ new Set();
  const thisVersion = LexicalEditor.version;
  if (typeof window !== "undefined") {
    for (const node of document.querySelectorAll("[contenteditable]")) {
      const editor = getEditorPropertyFromDOMNode(node);
      if (isLexicalEditor(editor)) {
        compatibleEditors++;
      } else if (editor) {
        let version = String(editor.constructor.version || "<0.17.1");
        if (version === thisVersion) {
          version += " (separately built, likely a bundler configuration issue)";
        }
        incompatibleEditors.add(version);
      }
    }
  }
  let output = ` Detected on the page: ${compatibleEditors} compatible editor(s) with version ${thisVersion}`;
  if (incompatibleEditors.size) {
    output += ` and incompatible editors with versions ${Array.from(incompatibleEditors).join(", ")}`;
  }
  return output;
}
function internalGetActiveEditor() {
  return activeEditor;
}
function internalGetActiveEditorState() {
  return activeEditorState;
}
function $applyTransforms(editor, node, transformsCache) {
  const type = node.__type;
  const registeredNode = getRegisteredNodeOrThrow(editor, type);
  let transformsArr = transformsCache.get(type);
  if (transformsArr === void 0) {
    transformsArr = Array.from(registeredNode.transforms);
    transformsCache.set(type, transformsArr);
  }
  const transformsArrLength = transformsArr.length;
  for (let i2 = 0; i2 < transformsArrLength; i2++) {
    transformsArr[i2](node);
    if (!node.isAttached()) {
      break;
    }
  }
}
function $isNodeValidForTransform(node, compositionKey) {
  return node !== void 0 && // We don't want to transform nodes being composed
  node.__key !== compositionKey && node.isAttached();
}
function $normalizeAllDirtyTextNodes(editorState, editor) {
  const dirtyLeaves = editor._dirtyLeaves;
  const nodeMap = editorState._nodeMap;
  for (const nodeKey of dirtyLeaves) {
    const node = nodeMap.get(nodeKey);
    if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {
      $normalizeTextNode(node);
    }
  }
}
function addTags(editor, tags) {
  if (!tags) {
    return;
  }
  const updateTags = editor._updateTags;
  let tags_ = tags;
  if (!Array.isArray(tags)) {
    tags_ = [tags];
  }
  for (const tag of tags_) {
    updateTags.add(tag);
  }
}
function $applyAllTransforms(editorState, editor) {
  const dirtyLeaves = editor._dirtyLeaves;
  const dirtyElements = editor._dirtyElements;
  const nodeMap = editorState._nodeMap;
  const compositionKey = $getCompositionKey();
  const transformsCache = /* @__PURE__ */ new Map();
  let untransformedDirtyLeaves = dirtyLeaves;
  let untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;
  let untransformedDirtyElements = dirtyElements;
  let untransformedDirtyElementsLength = untransformedDirtyElements.size;
  while (untransformedDirtyLeavesLength > 0 || untransformedDirtyElementsLength > 0) {
    if (untransformedDirtyLeavesLength > 0) {
      editor._dirtyLeaves = /* @__PURE__ */ new Set();
      for (const nodeKey of untransformedDirtyLeaves) {
        const node = nodeMap.get(nodeKey);
        if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {
          $normalizeTextNode(node);
        }
        if (node !== void 0 && $isNodeValidForTransform(node, compositionKey)) {
          $applyTransforms(editor, node, transformsCache);
        }
        dirtyLeaves.add(nodeKey);
      }
      untransformedDirtyLeaves = editor._dirtyLeaves;
      untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;
      if (untransformedDirtyLeavesLength > 0) {
        infiniteTransformCount++;
        continue;
      }
    }
    editor._dirtyLeaves = /* @__PURE__ */ new Set();
    editor._dirtyElements = /* @__PURE__ */ new Map();
    const rootDirty = untransformedDirtyElements.delete("root");
    if (rootDirty) {
      untransformedDirtyElements.set("root", true);
    }
    for (const currentUntransformedDirtyElement of untransformedDirtyElements) {
      const nodeKey = currentUntransformedDirtyElement[0];
      const intentionallyMarkedAsDirty = currentUntransformedDirtyElement[1];
      dirtyElements.set(nodeKey, intentionallyMarkedAsDirty);
      if (!intentionallyMarkedAsDirty) {
        continue;
      }
      const node = nodeMap.get(nodeKey);
      if (node !== void 0 && $isNodeValidForTransform(node, compositionKey)) {
        $applyTransforms(editor, node, transformsCache);
      }
    }
    untransformedDirtyLeaves = editor._dirtyLeaves;
    untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;
    untransformedDirtyElements = editor._dirtyElements;
    untransformedDirtyElementsLength = untransformedDirtyElements.size;
    infiniteTransformCount++;
  }
  editor._dirtyLeaves = dirtyLeaves;
  editor._dirtyElements = dirtyElements;
}
function $parseSerializedNode(serializedNode) {
  const internalSerializedNode = serializedNode;
  return $parseSerializedNodeImpl(internalSerializedNode, getActiveEditor()._nodes);
}
function $parseSerializedNodeImpl(serializedNode, registeredNodes) {
  const type = serializedNode.type;
  const registeredNode = registeredNodes.get(type);
  if (registeredNode === void 0) {
    {
      formatDevErrorMessage(`parseEditorState: type "${type}" + not found`);
    }
  }
  const nodeClass = registeredNode.klass;
  if (serializedNode.type !== nodeClass.getType()) {
    {
      formatDevErrorMessage(`LexicalNode: Node ${nodeClass.name} does not implement .importJSON().`);
    }
  }
  const node = nodeClass.importJSON(serializedNode);
  const children = serializedNode.children;
  if ($isElementNode(node) && Array.isArray(children)) {
    for (let i2 = 0; i2 < children.length; i2++) {
      const serializedJSONChildNode = children[i2];
      const childNode = $parseSerializedNodeImpl(serializedJSONChildNode, registeredNodes);
      node.append(childNode);
    }
  }
  return node;
}
function parseEditorState(serializedEditorState, editor, updateFn) {
  const editorState = createEmptyEditorState();
  const previousActiveEditorState = activeEditorState;
  const previousReadOnlyMode = isReadOnlyMode;
  const previousActiveEditor = activeEditor;
  const previousDirtyElements = editor._dirtyElements;
  const previousDirtyLeaves = editor._dirtyLeaves;
  const previousCloneNotNeeded = editor._cloneNotNeeded;
  const previousDirtyType = editor._dirtyType;
  editor._dirtyElements = /* @__PURE__ */ new Map();
  editor._dirtyLeaves = /* @__PURE__ */ new Set();
  editor._cloneNotNeeded = /* @__PURE__ */ new Set();
  editor._dirtyType = 0;
  activeEditorState = editorState;
  isReadOnlyMode = false;
  activeEditor = editor;
  setPendingNodeToClone(null);
  try {
    const registeredNodes = editor._nodes;
    const serializedNode = serializedEditorState.root;
    $parseSerializedNodeImpl(serializedNode, registeredNodes);
    if (updateFn) {
      updateFn();
    }
    editorState._readOnly = true;
    {
      handleDEVOnlyPendingUpdateGuarantees(editorState);
    }
  } catch (error) {
    if (error instanceof Error) {
      editor._onError(error);
    }
  } finally {
    editor._dirtyElements = previousDirtyElements;
    editor._dirtyLeaves = previousDirtyLeaves;
    editor._cloneNotNeeded = previousCloneNotNeeded;
    editor._dirtyType = previousDirtyType;
    activeEditorState = previousActiveEditorState;
    isReadOnlyMode = previousReadOnlyMode;
    activeEditor = previousActiveEditor;
  }
  return editorState;
}
function readEditorState(editor, editorState, callbackFn) {
  const previousActiveEditorState = activeEditorState;
  const previousReadOnlyMode = isReadOnlyMode;
  const previousActiveEditor = activeEditor;
  activeEditorState = editorState;
  isReadOnlyMode = true;
  activeEditor = editor;
  try {
    return callbackFn();
  } finally {
    activeEditorState = previousActiveEditorState;
    isReadOnlyMode = previousReadOnlyMode;
    activeEditor = previousActiveEditor;
  }
}
function handleDEVOnlyPendingUpdateGuarantees(pendingEditorState) {
  const nodeMap = pendingEditorState._nodeMap;
  nodeMap.set = () => {
    throw new Error("Cannot call set() on a frozen Lexical node map");
  };
  nodeMap.clear = () => {
    throw new Error("Cannot call clear() on a frozen Lexical node map");
  };
  nodeMap.delete = () => {
    throw new Error("Cannot call delete() on a frozen Lexical node map");
  };
}
function $commitPendingUpdates(editor, recoveryEditorState) {
  const pendingEditorState = editor._pendingEditorState;
  const rootElement = editor._rootElement;
  const shouldSkipDOM = editor._headless || rootElement === null;
  if (pendingEditorState === null) {
    return;
  }
  const currentEditorState = editor._editorState;
  const currentSelection = currentEditorState._selection;
  const pendingSelection = pendingEditorState._selection;
  const needsUpdate = editor._dirtyType !== NO_DIRTY_NODES;
  const previousActiveEditorState = activeEditorState;
  const previousReadOnlyMode = isReadOnlyMode;
  const previousActiveEditor = activeEditor;
  const previouslyUpdating = editor._updating;
  const observer = editor._observer;
  let mutatedNodes2 = null;
  editor._pendingEditorState = null;
  editor._editorState = pendingEditorState;
  if (!shouldSkipDOM && needsUpdate && observer !== null) {
    activeEditor = editor;
    activeEditorState = pendingEditorState;
    isReadOnlyMode = false;
    editor._updating = true;
    try {
      const dirtyType = editor._dirtyType;
      const dirtyElements2 = editor._dirtyElements;
      const dirtyLeaves2 = editor._dirtyLeaves;
      observer.disconnect();
      mutatedNodes2 = $reconcileRoot(currentEditorState, pendingEditorState, editor, dirtyType, dirtyElements2, dirtyLeaves2);
    } catch (error) {
      if (error instanceof Error) {
        editor._onError(error);
      }
      if (!isAttemptingToRecoverFromReconcilerError) {
        resetEditor(editor, null, rootElement, pendingEditorState);
        initMutationObserver(editor);
        editor._dirtyType = FULL_RECONCILE;
        isAttemptingToRecoverFromReconcilerError = true;
        $commitPendingUpdates(editor, currentEditorState);
        isAttemptingToRecoverFromReconcilerError = false;
      } else {
        throw error;
      }
      return;
    } finally {
      observer.observe(rootElement, observerOptions);
      editor._updating = previouslyUpdating;
      activeEditorState = previousActiveEditorState;
      isReadOnlyMode = previousReadOnlyMode;
      activeEditor = previousActiveEditor;
    }
  }
  if (!pendingEditorState._readOnly) {
    pendingEditorState._readOnly = true;
    {
      handleDEVOnlyPendingUpdateGuarantees(pendingEditorState);
      if ($isRangeSelection(pendingSelection)) {
        Object.freeze(pendingSelection.anchor);
        Object.freeze(pendingSelection.focus);
      }
      Object.freeze(pendingSelection);
    }
  }
  const dirtyLeaves = editor._dirtyLeaves;
  const dirtyElements = editor._dirtyElements;
  const normalizedNodes = editor._normalizedNodes;
  const tags = editor._updateTags;
  const deferred = editor._deferred;
  if (needsUpdate) {
    editor._dirtyType = NO_DIRTY_NODES;
    editor._cloneNotNeeded.clear();
    editor._dirtyLeaves = /* @__PURE__ */ new Set();
    editor._dirtyElements = /* @__PURE__ */ new Map();
    editor._normalizedNodes = /* @__PURE__ */ new Set();
    editor._updateTags = /* @__PURE__ */ new Set();
  }
  $garbageCollectDetachedDecorators(editor, pendingEditorState);
  const domSelection = shouldSkipDOM ? null : getDOMSelection(getWindow(editor));
  if (editor._editable && // domSelection will be null in headless
  domSelection !== null && (needsUpdate || pendingSelection === null || pendingSelection.dirty || !pendingSelection.is(currentSelection)) && rootElement !== null && !tags.has(SKIP_DOM_SELECTION_TAG)) {
    activeEditor = editor;
    activeEditorState = pendingEditorState;
    try {
      if (observer !== null) {
        observer.disconnect();
      }
      if (needsUpdate || pendingSelection === null || pendingSelection.dirty) {
        const blockCursorElement = editor._blockCursorElement;
        if (blockCursorElement !== null) {
          removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);
        }
        updateDOMSelection(currentSelection, pendingSelection, editor, domSelection, tags, rootElement);
      }
      updateDOMBlockCursorElement(editor, rootElement, pendingSelection);
    } finally {
      if (observer !== null) {
        observer.observe(rootElement, observerOptions);
      }
      activeEditor = previousActiveEditor;
      activeEditorState = previousActiveEditorState;
    }
  }
  if (mutatedNodes2 !== null) {
    triggerMutationListeners(editor, mutatedNodes2, tags, dirtyLeaves, currentEditorState);
  }
  if (!$isRangeSelection(pendingSelection) && pendingSelection !== null && (currentSelection === null || !currentSelection.is(pendingSelection))) {
    editor.dispatchCommand(SELECTION_CHANGE_COMMAND, void 0);
  }
  const pendingDecorators = editor._pendingDecorators;
  if (pendingDecorators !== null) {
    editor._decorators = pendingDecorators;
    editor._pendingDecorators = null;
    triggerListeners("decorator", editor, true, pendingDecorators);
  }
  triggerTextContentListeners(editor, recoveryEditorState || currentEditorState, pendingEditorState);
  triggerListeners("update", editor, true, {
    dirtyElements,
    dirtyLeaves,
    editorState: pendingEditorState,
    mutatedNodes: mutatedNodes2,
    normalizedNodes,
    prevEditorState: recoveryEditorState || currentEditorState,
    tags
  });
  triggerDeferredUpdateCallbacks(editor, deferred);
  $triggerEnqueuedUpdates(editor);
}
function triggerTextContentListeners(editor, currentEditorState, pendingEditorState) {
  const currentTextContent = getEditorStateTextContent(currentEditorState);
  const latestTextContent = getEditorStateTextContent(pendingEditorState);
  if (currentTextContent !== latestTextContent) {
    triggerListeners("textcontent", editor, true, latestTextContent);
  }
}
function triggerMutationListeners(editor, mutatedNodes2, updateTags, dirtyLeaves, prevEditorState) {
  const listeners = Array.from(editor._listeners.mutation);
  const listenersLength = listeners.length;
  for (let i2 = 0; i2 < listenersLength; i2++) {
    const [listener, klassSet] = listeners[i2];
    for (const klass of klassSet) {
      const mutatedNodesByType = mutatedNodes2.get(klass);
      if (mutatedNodesByType !== void 0) {
        listener(mutatedNodesByType, {
          dirtyLeaves,
          prevEditorState,
          updateTags
        });
      }
    }
  }
}
function triggerListeners(type, editor, isCurrentlyEnqueuingUpdates, ...payload) {
  const previouslyUpdating = editor._updating;
  editor._updating = isCurrentlyEnqueuingUpdates;
  try {
    const listeners = Array.from(editor._listeners[type]);
    for (let i2 = 0; i2 < listeners.length; i2++) {
      listeners[i2].apply(null, payload);
    }
  } finally {
    editor._updating = previouslyUpdating;
  }
}
function triggerCommandListeners(editor, type, payload) {
  const editors = getEditorsToPropagate(editor);
  for (let i2 = 4; i2 >= 0; i2--) {
    for (let e2 = 0; e2 < editors.length; e2++) {
      const currentEditor = editors[e2];
      const commandListeners = currentEditor._commands;
      const listenerInPriorityOrder = commandListeners.get(type);
      if (listenerInPriorityOrder !== void 0) {
        const listenersSet = listenerInPriorityOrder[i2];
        if (listenersSet !== void 0) {
          const listeners = Array.from(listenersSet);
          const listenersLength = listeners.length;
          let returnVal = false;
          updateEditorSync(currentEditor, () => {
            for (let j = 0; j < listenersLength; j++) {
              if (listeners[j](payload, editor)) {
                returnVal = true;
                return;
              }
            }
          });
          if (returnVal) {
            return returnVal;
          }
        }
      }
    }
  }
  return false;
}
function $triggerEnqueuedUpdates(editor) {
  const queuedUpdates = editor._updates;
  if (queuedUpdates.length !== 0) {
    const queuedUpdate = queuedUpdates.shift();
    if (queuedUpdate) {
      const [updateFn, options] = queuedUpdate;
      $beginUpdate(editor, updateFn, options);
    }
  }
}
function triggerDeferredUpdateCallbacks(editor, deferred) {
  editor._deferred = [];
  if (deferred.length !== 0) {
    const previouslyUpdating = editor._updating;
    editor._updating = true;
    try {
      for (let i2 = 0; i2 < deferred.length; i2++) {
        deferred[i2]();
      }
    } finally {
      editor._updating = previouslyUpdating;
    }
  }
}
function $processNestedUpdates(editor, initialSkipTransforms) {
  const queuedUpdates = editor._updates;
  let skipTransforms = initialSkipTransforms || false;
  while (queuedUpdates.length !== 0) {
    const queuedUpdate = queuedUpdates.shift();
    if (queuedUpdate) {
      const [nextUpdateFn, options] = queuedUpdate;
      const pendingEditorState = editor._pendingEditorState;
      let onUpdate;
      if (options !== void 0) {
        onUpdate = options.onUpdate;
        if (options.skipTransforms) {
          skipTransforms = true;
        }
        if (options.discrete) {
          if (!(pendingEditorState !== null)) {
            formatDevErrorMessage(`Unexpected empty pending editor state on discrete nested update`);
          }
          pendingEditorState._flushSync = true;
        }
        if (onUpdate) {
          editor._deferred.push(onUpdate);
        }
        addTags(editor, options.tag);
      }
      if (pendingEditorState == null) {
        $beginUpdate(editor, nextUpdateFn, options);
      } else {
        nextUpdateFn();
      }
    }
  }
  return skipTransforms;
}
function $beginUpdate(editor, updateFn, options) {
  const updateTags = editor._updateTags;
  let onUpdate;
  let skipTransforms = false;
  let discrete = false;
  if (options !== void 0) {
    onUpdate = options.onUpdate;
    addTags(editor, options.tag);
    skipTransforms = options.skipTransforms || false;
    discrete = options.discrete || false;
  }
  if (onUpdate) {
    editor._deferred.push(onUpdate);
  }
  const currentEditorState = editor._editorState;
  let pendingEditorState = editor._pendingEditorState;
  let editorStateWasCloned = false;
  if (pendingEditorState === null || pendingEditorState._readOnly) {
    pendingEditorState = editor._pendingEditorState = cloneEditorState(pendingEditorState || currentEditorState);
    editorStateWasCloned = true;
  }
  pendingEditorState._flushSync = discrete;
  const previousActiveEditorState = activeEditorState;
  const previousReadOnlyMode = isReadOnlyMode;
  const previousActiveEditor = activeEditor;
  const previouslyUpdating = editor._updating;
  activeEditorState = pendingEditorState;
  isReadOnlyMode = false;
  editor._updating = true;
  activeEditor = editor;
  const headless = editor._headless || editor.getRootElement() === null;
  setPendingNodeToClone(null);
  try {
    if (editorStateWasCloned) {
      if (headless) {
        if (currentEditorState._selection !== null) {
          pendingEditorState._selection = currentEditorState._selection.clone();
        }
      } else {
        pendingEditorState._selection = $internalCreateSelection(editor, options && options.event || null);
      }
    }
    const startingCompositionKey = editor._compositionKey;
    updateFn();
    skipTransforms = $processNestedUpdates(editor, skipTransforms);
    applySelectionTransforms(pendingEditorState, editor);
    if (editor._dirtyType !== NO_DIRTY_NODES) {
      if (skipTransforms) {
        $normalizeAllDirtyTextNodes(pendingEditorState, editor);
      } else {
        $applyAllTransforms(pendingEditorState, editor);
      }
      $processNestedUpdates(editor);
      $garbageCollectDetachedNodes(currentEditorState, pendingEditorState, editor._dirtyLeaves, editor._dirtyElements);
    }
    const endingCompositionKey = editor._compositionKey;
    if (startingCompositionKey !== endingCompositionKey) {
      pendingEditorState._flushSync = true;
    }
    const pendingSelection = pendingEditorState._selection;
    if ($isRangeSelection(pendingSelection)) {
      const pendingNodeMap = pendingEditorState._nodeMap;
      const anchorKey = pendingSelection.anchor.key;
      const focusKey = pendingSelection.focus.key;
      if (pendingNodeMap.get(anchorKey) === void 0 || pendingNodeMap.get(focusKey) === void 0) {
        {
          formatDevErrorMessage(`updateEditor: selection has been lost because the previously selected nodes have been removed and selection wasn't moved to another node. Ensure selection changes after removing/replacing a selected node.`);
        }
      }
    } else if ($isNodeSelection(pendingSelection)) {
      if (pendingSelection._nodes.size === 0) {
        pendingEditorState._selection = null;
      }
    }
  } catch (error) {
    if (error instanceof Error) {
      editor._onError(error);
    }
    editor._pendingEditorState = currentEditorState;
    editor._dirtyType = FULL_RECONCILE;
    editor._cloneNotNeeded.clear();
    editor._dirtyLeaves = /* @__PURE__ */ new Set();
    editor._dirtyElements.clear();
    $commitPendingUpdates(editor);
    return;
  } finally {
    activeEditorState = previousActiveEditorState;
    isReadOnlyMode = previousReadOnlyMode;
    activeEditor = previousActiveEditor;
    editor._updating = previouslyUpdating;
    infiniteTransformCount = 0;
  }
  const shouldUpdate = editor._dirtyType !== NO_DIRTY_NODES || editor._deferred.length > 0 || editorStateHasDirtySelection(pendingEditorState, editor);
  if (shouldUpdate) {
    if (pendingEditorState._flushSync) {
      pendingEditorState._flushSync = false;
      $commitPendingUpdates(editor);
    } else if (editorStateWasCloned) {
      scheduleMicroTask(() => {
        $commitPendingUpdates(editor);
      });
    }
  } else {
    pendingEditorState._flushSync = false;
    if (editorStateWasCloned) {
      updateTags.clear();
      editor._deferred = [];
      editor._pendingEditorState = null;
    }
  }
}
function updateEditorSync(editor, updateFn, options) {
  if (activeEditor === editor && options === void 0) {
    updateFn();
  } else {
    $beginUpdate(editor, updateFn, options);
  }
}
function updateEditor(editor, updateFn, options) {
  if (editor._updating) {
    editor._updates.push([updateFn, options]);
  } else {
    $beginUpdate(editor, updateFn, options);
  }
}
var ElementDOMSlot = class _ElementDOMSlot {
  constructor(element, before, after) {
    __publicField(this, "element");
    __publicField(this, "before");
    __publicField(this, "after");
    this.element = element;
    this.before = before || null;
    this.after = after || null;
  }
  /**
   * Return a new ElementDOMSlot where all managed children will be inserted before this node
   */
  withBefore(before) {
    return new _ElementDOMSlot(this.element, before, this.after);
  }
  /**
   * Return a new ElementDOMSlot where all managed children will be inserted after this node
   */
  withAfter(after) {
    return new _ElementDOMSlot(this.element, this.before, after);
  }
  /**
   * Return a new ElementDOMSlot with an updated root element
   */
  withElement(element) {
    if (this.element === element) {
      return this;
    }
    return new _ElementDOMSlot(element, this.before, this.after);
  }
  /**
   * Insert the given child before this.before and any reconciler managed line break node,
   * or append it if this.before is not defined
   */
  insertChild(dom) {
    const before = this.before || this.getManagedLineBreak();
    if (!(before === null || before.parentElement === this.element)) {
      formatDevErrorMessage(`ElementDOMSlot.insertChild: before is not in element`);
    }
    this.element.insertBefore(dom, before);
    return this;
  }
  /**
   * Remove the managed child from this container, will throw if it was not already there
   */
  removeChild(dom) {
    if (!(dom.parentElement === this.element)) {
      formatDevErrorMessage(`ElementDOMSlot.removeChild: dom is not in element`);
    }
    this.element.removeChild(dom);
    return this;
  }
  /**
   * Replace managed child prevDom with dom. Will throw if prevDom is not a child
   *
   * @param dom The new node to replace prevDom
   * @param prevDom the node that will be replaced
   */
  replaceChild(dom, prevDom) {
    if (!(prevDom.parentElement === this.element)) {
      formatDevErrorMessage(`ElementDOMSlot.replaceChild: prevDom is not in element`);
    }
    this.element.replaceChild(dom, prevDom);
    return this;
  }
  /**
   * Returns the first managed child of this node,
   * which will either be this.after.nextSibling or this.element.firstChild,
   * and will never be this.before if it is defined.
   */
  getFirstChild() {
    const firstChild = this.after ? this.after.nextSibling : this.element.firstChild;
    return firstChild === this.before || firstChild === this.getManagedLineBreak() ? null : firstChild;
  }
  /**
   * @internal
   */
  getManagedLineBreak() {
    const element = this.element;
    return element.__lexicalLineBreak || null;
  }
  /** @internal */
  setManagedLineBreak(lineBreakType) {
    if (lineBreakType === null) {
      this.removeManagedLineBreak();
    } else {
      const webkitHack = lineBreakType === "decorator" && (IS_APPLE_WEBKIT || IS_IOS || IS_SAFARI);
      this.insertManagedLineBreak(webkitHack);
    }
  }
  /** @internal */
  removeManagedLineBreak() {
    const br = this.getManagedLineBreak();
    if (br) {
      const element = this.element;
      const sibling = br.nodeName === "IMG" ? br.nextSibling : null;
      if (sibling) {
        element.removeChild(sibling);
      }
      element.removeChild(br);
      element.__lexicalLineBreak = void 0;
    }
  }
  /** @internal */
  insertManagedLineBreak(webkitHack) {
    const prevBreak = this.getManagedLineBreak();
    if (prevBreak) {
      if (webkitHack === (prevBreak.nodeName === "IMG")) {
        return;
      }
      this.removeManagedLineBreak();
    }
    const element = this.element;
    const before = this.before;
    const br = document.createElement("br");
    element.insertBefore(br, before);
    if (webkitHack) {
      const img = document.createElement("img");
      img.setAttribute("data-lexical-linebreak", "true");
      img.style.cssText = "display: inline !important; border: 0px !important; margin: 0px !important;";
      img.alt = "";
      element.insertBefore(img, br);
      element.__lexicalLineBreak = img;
    } else {
      element.__lexicalLineBreak = br;
    }
  }
  /**
   * @internal
   *
   * Returns the offset of the first child
   */
  getFirstChildOffset() {
    let i2 = 0;
    for (let node = this.after; node !== null; node = node.previousSibling) {
      i2++;
    }
    return i2;
  }
  /**
   * @internal
   */
  resolveChildIndex(element, elementDOM, initialDOM, initialOffset) {
    if (initialDOM === this.element) {
      const firstChildOffset = this.getFirstChildOffset();
      return [element, Math.min(firstChildOffset + element.getChildrenSize(), Math.max(firstChildOffset, initialOffset))];
    }
    const initialPath = indexPath(elementDOM, initialDOM);
    initialPath.push(initialOffset);
    const elementPath = indexPath(elementDOM, this.element);
    let offset = element.getIndexWithinParent();
    for (let i2 = 0; i2 < elementPath.length; i2++) {
      const target = initialPath[i2];
      const source = elementPath[i2];
      if (target === void 0 || target < source) {
        break;
      } else if (target > source) {
        offset += 1;
        break;
      }
    }
    return [element.getParentOrThrow(), offset];
  }
};
function indexPath(root, child) {
  const path = [];
  let node = child;
  for (; node !== root && node !== null; node = node.parentNode) {
    let i2 = 0;
    for (let sibling = node.previousSibling; sibling !== null; sibling = sibling.previousSibling) {
      i2++;
    }
    path.push(i2);
  }
  if (!(node === root)) {
    formatDevErrorMessage(`indexPath: root is not a parent of child`);
  }
  return path.reverse();
}
var ElementNode = class extends LexicalNode {
  constructor(key) {
    super(key);
    /** @internal */
    /** @internal */
    __publicField(this, "__first");
    /** @internal */
    __publicField(this, "__last");
    /** @internal */
    __publicField(this, "__size");
    /** @internal */
    __publicField(this, "__format");
    /** @internal */
    __publicField(this, "__style");
    /** @internal */
    __publicField(this, "__indent");
    /** @internal */
    __publicField(this, "__dir");
    /** @internal */
    __publicField(this, "__textFormat");
    /** @internal */
    __publicField(this, "__textStyle");
    this.__first = null;
    this.__last = null;
    this.__size = 0;
    this.__format = 0;
    this.__style = "";
    this.__indent = 0;
    this.__dir = null;
    this.__textFormat = 0;
    this.__textStyle = "";
  }
  afterCloneFrom(prevNode) {
    super.afterCloneFrom(prevNode);
    if (this.__key === prevNode.__key) {
      this.__first = prevNode.__first;
      this.__last = prevNode.__last;
      this.__size = prevNode.__size;
    }
    this.__indent = prevNode.__indent;
    this.__format = prevNode.__format;
    this.__style = prevNode.__style;
    this.__dir = prevNode.__dir;
    this.__textFormat = prevNode.__textFormat;
    this.__textStyle = prevNode.__textStyle;
  }
  getFormat() {
    const self2 = this.getLatest();
    return self2.__format;
  }
  getFormatType() {
    const format = this.getFormat();
    return ELEMENT_FORMAT_TO_TYPE[format] || "";
  }
  getStyle() {
    const self2 = this.getLatest();
    return self2.__style;
  }
  getIndent() {
    const self2 = this.getLatest();
    return self2.__indent;
  }
  getChildren() {
    const children = [];
    let child = this.getFirstChild();
    while (child !== null) {
      children.push(child);
      child = child.getNextSibling();
    }
    return children;
  }
  getChildrenKeys() {
    const children = [];
    let child = this.getFirstChild();
    while (child !== null) {
      children.push(child.__key);
      child = child.getNextSibling();
    }
    return children;
  }
  getChildrenSize() {
    const self2 = this.getLatest();
    return self2.__size;
  }
  isEmpty() {
    return this.getChildrenSize() === 0;
  }
  isDirty() {
    const editor = getActiveEditor();
    const dirtyElements = editor._dirtyElements;
    return dirtyElements !== null && dirtyElements.has(this.__key);
  }
  isLastChild() {
    const self2 = this.getLatest();
    const parentLastChild = this.getParentOrThrow().getLastChild();
    return parentLastChild !== null && parentLastChild.is(self2);
  }
  getAllTextNodes() {
    const textNodes = [];
    let child = this.getFirstChild();
    while (child !== null) {
      if ($isTextNode(child)) {
        textNodes.push(child);
      }
      if ($isElementNode(child)) {
        const subChildrenNodes = child.getAllTextNodes();
        textNodes.push(...subChildrenNodes);
      }
      child = child.getNextSibling();
    }
    return textNodes;
  }
  getFirstDescendant() {
    let node = this.getFirstChild();
    while ($isElementNode(node)) {
      const child = node.getFirstChild();
      if (child === null) {
        break;
      }
      node = child;
    }
    return node;
  }
  getLastDescendant() {
    let node = this.getLastChild();
    while ($isElementNode(node)) {
      const child = node.getLastChild();
      if (child === null) {
        break;
      }
      node = child;
    }
    return node;
  }
  getDescendantByIndex(index) {
    const children = this.getChildren();
    const childrenLength = children.length;
    if (index >= childrenLength) {
      const resolvedNode2 = children[childrenLength - 1];
      return $isElementNode(resolvedNode2) && resolvedNode2.getLastDescendant() || resolvedNode2 || null;
    }
    const resolvedNode = children[index];
    return $isElementNode(resolvedNode) && resolvedNode.getFirstDescendant() || resolvedNode || null;
  }
  getFirstChild() {
    const self2 = this.getLatest();
    const firstKey = self2.__first;
    return firstKey === null ? null : $getNodeByKey(firstKey);
  }
  getFirstChildOrThrow() {
    const firstChild = this.getFirstChild();
    if (firstChild === null) {
      {
        formatDevErrorMessage(`Expected node ${this.__key} to have a first child.`);
      }
    }
    return firstChild;
  }
  getLastChild() {
    const self2 = this.getLatest();
    const lastKey = self2.__last;
    return lastKey === null ? null : $getNodeByKey(lastKey);
  }
  getLastChildOrThrow() {
    const lastChild = this.getLastChild();
    if (lastChild === null) {
      {
        formatDevErrorMessage(`Expected node ${this.__key} to have a last child.`);
      }
    }
    return lastChild;
  }
  getChildAtIndex(index) {
    const size = this.getChildrenSize();
    let node;
    let i2;
    if (index < size / 2) {
      node = this.getFirstChild();
      i2 = 0;
      while (node !== null && i2 <= index) {
        if (i2 === index) {
          return node;
        }
        node = node.getNextSibling();
        i2++;
      }
      return null;
    }
    node = this.getLastChild();
    i2 = size - 1;
    while (node !== null && i2 >= index) {
      if (i2 === index) {
        return node;
      }
      node = node.getPreviousSibling();
      i2--;
    }
    return null;
  }
  getTextContent() {
    let textContent = "";
    const children = this.getChildren();
    const childrenLength = children.length;
    for (let i2 = 0; i2 < childrenLength; i2++) {
      const child = children[i2];
      textContent += child.getTextContent();
      if ($isElementNode(child) && i2 !== childrenLength - 1 && !child.isInline()) {
        textContent += DOUBLE_LINE_BREAK;
      }
    }
    return textContent;
  }
  getTextContentSize() {
    let textContentSize = 0;
    const children = this.getChildren();
    const childrenLength = children.length;
    for (let i2 = 0; i2 < childrenLength; i2++) {
      const child = children[i2];
      textContentSize += child.getTextContentSize();
      if ($isElementNode(child) && i2 !== childrenLength - 1 && !child.isInline()) {
        textContentSize += DOUBLE_LINE_BREAK.length;
      }
    }
    return textContentSize;
  }
  getDirection() {
    const self2 = this.getLatest();
    return self2.__dir;
  }
  getTextFormat() {
    const self2 = this.getLatest();
    return self2.__textFormat;
  }
  hasFormat(type) {
    if (type !== "") {
      const formatFlag = ELEMENT_TYPE_TO_FORMAT[type];
      return (this.getFormat() & formatFlag) !== 0;
    }
    return false;
  }
  hasTextFormat(type) {
    const formatFlag = TEXT_TYPE_TO_FORMAT[type];
    return (this.getTextFormat() & formatFlag) !== 0;
  }
  /**
   * Returns the format flags applied to the node as a 32-bit integer.
   *
   * @returns a number representing the TextFormatTypes applied to the node.
   */
  getFormatFlags(type, alignWithFormat) {
    const self2 = this.getLatest();
    const format = self2.__textFormat;
    return toggleTextFormatType(format, type, alignWithFormat);
  }
  getTextStyle() {
    const self2 = this.getLatest();
    return self2.__textStyle;
  }
  // Mutators
  select(_anchorOffset, _focusOffset) {
    errorOnReadOnly();
    const selection = $getSelection();
    let anchorOffset = _anchorOffset;
    let focusOffset = _focusOffset;
    const childrenCount = this.getChildrenSize();
    if (!this.canBeEmpty()) {
      if (_anchorOffset === 0 && _focusOffset === 0) {
        const firstChild = this.getFirstChild();
        if ($isTextNode(firstChild) || $isElementNode(firstChild)) {
          return firstChild.select(0, 0);
        }
      } else if ((_anchorOffset === void 0 || _anchorOffset === childrenCount) && (_focusOffset === void 0 || _focusOffset === childrenCount)) {
        const lastChild = this.getLastChild();
        if ($isTextNode(lastChild) || $isElementNode(lastChild)) {
          return lastChild.select();
        }
      }
    }
    if (anchorOffset === void 0) {
      anchorOffset = childrenCount;
    }
    if (focusOffset === void 0) {
      focusOffset = childrenCount;
    }
    const key = this.__key;
    if (!$isRangeSelection(selection)) {
      return $internalMakeRangeSelection(key, anchorOffset, key, focusOffset, "element", "element");
    } else {
      selection.anchor.set(key, anchorOffset, "element");
      selection.focus.set(key, focusOffset, "element");
      selection.dirty = true;
    }
    return selection;
  }
  selectStart() {
    const firstNode = this.getFirstDescendant();
    return firstNode ? firstNode.selectStart() : this.select();
  }
  selectEnd() {
    const lastNode = this.getLastDescendant();
    return lastNode ? lastNode.selectEnd() : this.select();
  }
  clear() {
    const writableSelf = this.getWritable();
    const children = this.getChildren();
    children.forEach((child) => child.remove());
    return writableSelf;
  }
  append(...nodesToAppend) {
    return this.splice(this.getChildrenSize(), 0, nodesToAppend);
  }
  setDirection(direction) {
    const self2 = this.getWritable();
    self2.__dir = direction;
    return self2;
  }
  setFormat(type) {
    const self2 = this.getWritable();
    self2.__format = type !== "" ? ELEMENT_TYPE_TO_FORMAT[type] : 0;
    return this;
  }
  setStyle(style) {
    const self2 = this.getWritable();
    self2.__style = style || "";
    return this;
  }
  setTextFormat(type) {
    const self2 = this.getWritable();
    self2.__textFormat = type;
    return self2;
  }
  setTextStyle(style) {
    const self2 = this.getWritable();
    self2.__textStyle = style;
    return self2;
  }
  setIndent(indentLevel) {
    const self2 = this.getWritable();
    self2.__indent = indentLevel;
    return this;
  }
  splice(start, deleteCount, nodesToInsert) {
    if (!!$isEphemeral(this)) {
      formatDevErrorMessage(`ElementNode.splice: Ephemeral nodes can not mutate their children (key ${this.__key} type ${this.__type})`);
    }
    const oldSize = this.getChildrenSize();
    const writableSelf = this.getWritable();
    if (!(start + deleteCount <= oldSize)) {
      formatDevErrorMessage(`ElementNode.splice: start + deleteCount > oldSize (${String(start)} + ${String(deleteCount)} > ${String(oldSize)})`);
    }
    const writableSelfKey = writableSelf.__key;
    const nodesToInsertKeys = [];
    const nodesToRemoveKeys = [];
    const nodeAfterRange = this.getChildAtIndex(start + deleteCount);
    let nodeBeforeRange = null;
    let newSize = oldSize - deleteCount + nodesToInsert.length;
    if (start !== 0) {
      if (start === oldSize) {
        nodeBeforeRange = this.getLastChild();
      } else {
        const node = this.getChildAtIndex(start);
        if (node !== null) {
          nodeBeforeRange = node.getPreviousSibling();
        }
      }
    }
    if (deleteCount > 0) {
      let nodeToDelete = nodeBeforeRange === null ? this.getFirstChild() : nodeBeforeRange.getNextSibling();
      for (let i2 = 0; i2 < deleteCount; i2++) {
        if (nodeToDelete === null) {
          {
            formatDevErrorMessage(`splice: sibling not found`);
          }
        }
        const nextSibling = nodeToDelete.getNextSibling();
        const nodeKeyToDelete = nodeToDelete.__key;
        const writableNodeToDelete = nodeToDelete.getWritable();
        removeFromParent(writableNodeToDelete);
        nodesToRemoveKeys.push(nodeKeyToDelete);
        nodeToDelete = nextSibling;
      }
    }
    let prevNode = nodeBeforeRange;
    for (const nodeToInsert of nodesToInsert) {
      if (prevNode !== null && nodeToInsert.is(prevNode)) {
        nodeBeforeRange = prevNode = prevNode.getPreviousSibling();
      }
      const writableNodeToInsert = nodeToInsert.getWritable();
      if (writableNodeToInsert.__parent === writableSelfKey) {
        newSize--;
      }
      removeFromParent(writableNodeToInsert);
      const nodeKeyToInsert = nodeToInsert.__key;
      if (prevNode === null) {
        writableSelf.__first = nodeKeyToInsert;
        writableNodeToInsert.__prev = null;
      } else {
        const writablePrevNode = prevNode.getWritable();
        writablePrevNode.__next = nodeKeyToInsert;
        writableNodeToInsert.__prev = writablePrevNode.__key;
      }
      if (nodeToInsert.__key === writableSelfKey) {
        {
          formatDevErrorMessage(`append: attempting to append self`);
        }
      }
      writableNodeToInsert.__parent = writableSelfKey;
      nodesToInsertKeys.push(nodeKeyToInsert);
      prevNode = nodeToInsert;
    }
    if (start + deleteCount === oldSize) {
      if (prevNode !== null) {
        const writablePrevNode = prevNode.getWritable();
        writablePrevNode.__next = null;
        writableSelf.__last = prevNode.__key;
      }
    } else if (nodeAfterRange !== null) {
      const writableNodeAfterRange = nodeAfterRange.getWritable();
      if (prevNode !== null) {
        const writablePrevNode = prevNode.getWritable();
        writableNodeAfterRange.__prev = prevNode.__key;
        writablePrevNode.__next = nodeAfterRange.__key;
      } else {
        writableNodeAfterRange.__prev = null;
      }
    }
    writableSelf.__size = newSize;
    if (nodesToRemoveKeys.length) {
      const selection = $getSelection();
      if ($isRangeSelection(selection)) {
        const nodesToRemoveKeySet = new Set(nodesToRemoveKeys);
        const nodesToInsertKeySet = new Set(nodesToInsertKeys);
        const {
          anchor,
          focus
        } = selection;
        if (isPointRemoved(anchor, nodesToRemoveKeySet, nodesToInsertKeySet)) {
          moveSelectionPointToSibling(anchor, anchor.getNode(), this, nodeBeforeRange, nodeAfterRange);
        }
        if (isPointRemoved(focus, nodesToRemoveKeySet, nodesToInsertKeySet)) {
          moveSelectionPointToSibling(focus, focus.getNode(), this, nodeBeforeRange, nodeAfterRange);
        }
        if (newSize === 0 && !this.canBeEmpty() && !$isRootOrShadowRoot(this)) {
          this.remove();
        }
      }
    }
    return writableSelf;
  }
  /**
   * @internal
   *
   * An experimental API that an ElementNode can override to control where its
   * children are inserted into the DOM, this is useful to add a wrapping node
   * or accessory nodes before or after the children. The root of the node returned
   * by createDOM must still be exactly one HTMLElement.
   */
  getDOMSlot(element) {
    return new ElementDOMSlot(element);
  }
  exportDOM(editor) {
    const {
      element
    } = super.exportDOM(editor);
    if (isHTMLElement(element)) {
      const indent = this.getIndent();
      if (indent > 0) {
        element.style.paddingInlineStart = `${indent * 40}px`;
      }
      const direction = this.getDirection();
      if (direction) {
        element.dir = direction;
      }
    }
    return {
      element
    };
  }
  // JSON serialization
  exportJSON() {
    const json = {
      children: [],
      direction: this.getDirection(),
      format: this.getFormatType(),
      indent: this.getIndent(),
      // As an exception here we invoke super at the end for historical reasons.
      // Namely, to preserve the order of the properties and not to break the tests
      // that use the serialized string representation.
      ...super.exportJSON()
    };
    const textFormat = this.getTextFormat();
    const textStyle = this.getTextStyle();
    if ((textFormat !== 0 || textStyle !== "") && !$isRootOrShadowRoot(this) && !this.getChildren().some($isTextNode)) {
      if (textFormat !== 0) {
        json.textFormat = textFormat;
      }
      if (textStyle !== "") {
        json.textStyle = textStyle;
      }
    }
    return json;
  }
  updateFromJSON(serializedNode) {
    return super.updateFromJSON(serializedNode).setFormat(serializedNode.format).setIndent(serializedNode.indent).setDirection(serializedNode.direction).setTextFormat(serializedNode.textFormat || 0).setTextStyle(serializedNode.textStyle || "");
  }
  // These are intended to be extends for specific element heuristics.
  insertNewAfter(selection, restoreSelection) {
    return null;
  }
  canIndent() {
    return true;
  }
  /*
   * This method controls the behavior of the node during backwards
   * deletion (i.e., backspace) when selection is at the beginning of
   * the node (offset 0). You may use this to have the node replace
   * itself, change its state, or do nothing. When you do make such
   * a change, you should return true.
   *
   * When true is returned, the collapse phase will stop.
   * When false is returned, and isInline() is true, and getPreviousSibling() is null,
   * then this function will be called on its parent.
   */
  collapseAtStart(selection) {
    return false;
  }
  excludeFromCopy(destination) {
    return false;
  }
  /** @deprecated @internal */
  canReplaceWith(replacement) {
    return true;
  }
  /** @deprecated @internal */
  canInsertAfter(node) {
    return true;
  }
  canBeEmpty() {
    return true;
  }
  canInsertTextBefore() {
    return true;
  }
  canInsertTextAfter() {
    return true;
  }
  isInline() {
    return false;
  }
  // A shadow root is a Node that behaves like RootNode. The shadow root (and RootNode) mark the
  // end of the hierarchy, most implementations should treat it as there's nothing (upwards)
  // beyond this point. For example, node.getTopLevelElement(), when performed inside a TableCellNode
  // will return the immediate first child underneath TableCellNode instead of RootNode.
  isShadowRoot() {
    return false;
  }
  /** @deprecated @internal */
  canMergeWith(node) {
    return false;
  }
  extractWithChild(child, selection, destination) {
    return false;
  }
  /**
   * Determines whether this node, when empty, can merge with a first block
   * of nodes being inserted.
   *
   * This method is specifically called in {@link RangeSelection.insertNodes}
   * to determine merging behavior during nodes insertion.
   *
   * @example
   * // In a ListItemNode or QuoteNode implementation:
   * canMergeWhenEmpty(): true {
   *  return true;
   * }
   */
  canMergeWhenEmpty() {
    return false;
  }
  /** @internal */
  reconcileObservedMutation(dom, editor) {
    const slot = this.getDOMSlot(dom);
    let currentDOM = slot.getFirstChild();
    for (let currentNode = this.getFirstChild(); currentNode; currentNode = currentNode.getNextSibling()) {
      const correctDOM = editor.getElementByKey(currentNode.getKey());
      if (correctDOM === null) {
        continue;
      }
      if (currentDOM == null) {
        slot.insertChild(correctDOM);
        currentDOM = correctDOM;
      } else if (currentDOM !== correctDOM) {
        slot.replaceChild(correctDOM, currentDOM);
      }
      currentDOM = currentDOM.nextSibling;
    }
  }
};
function $isElementNode(node) {
  return node instanceof ElementNode;
}
function isPointRemoved(point, nodesToRemoveKeySet, nodesToInsertKeySet) {
  let node = point.getNode();
  while (node) {
    const nodeKey = node.__key;
    if (nodesToRemoveKeySet.has(nodeKey) && !nodesToInsertKeySet.has(nodeKey)) {
      return true;
    }
    node = node.getParent();
  }
  return false;
}
var DecoratorNode = class extends LexicalNode {
  /** @internal */
  /**
   * The returned value is added to the LexicalEditor._decorators
   */
  decorate(editor, config) {
    return null;
  }
  isIsolated() {
    return false;
  }
  isInline() {
    return true;
  }
  isKeyboardSelectable() {
    return true;
  }
};
function $isDecoratorNode(node) {
  return node instanceof DecoratorNode;
}
var RootNode = class _RootNode extends ElementNode {
  constructor() {
    super("root");
    /** @internal */
    __publicField(this, "__cachedText");
    this.__cachedText = null;
  }
  static getType() {
    return "root";
  }
  static clone() {
    return new _RootNode();
  }
  getTopLevelElementOrThrow() {
    {
      formatDevErrorMessage(`getTopLevelElementOrThrow: root nodes are not top level elements`);
    }
  }
  getTextContent() {
    const cachedText = this.__cachedText;
    if (isCurrentlyReadOnlyMode() || getActiveEditor()._dirtyType === NO_DIRTY_NODES) {
      if (cachedText !== null) {
        return cachedText;
      }
    }
    return super.getTextContent();
  }
  remove() {
    {
      formatDevErrorMessage(`remove: cannot be called on root nodes`);
    }
  }
  replace(node) {
    {
      formatDevErrorMessage(`replace: cannot be called on root nodes`);
    }
  }
  insertBefore(nodeToInsert) {
    {
      formatDevErrorMessage(`insertBefore: cannot be called on root nodes`);
    }
  }
  insertAfter(nodeToInsert) {
    {
      formatDevErrorMessage(`insertAfter: cannot be called on root nodes`);
    }
  }
  // View
  updateDOM(prevNode, dom) {
    return false;
  }
  // Mutate
  splice(start, deleteCount, nodesToInsert) {
    for (const node of nodesToInsert) {
      if (!($isElementNode(node) || $isDecoratorNode(node))) {
        formatDevErrorMessage(`rootNode.splice: Only element or decorator nodes can be inserted to the root node`);
      }
    }
    return super.splice(start, deleteCount, nodesToInsert);
  }
  static importJSON(serializedNode) {
    return $getRoot().updateFromJSON(serializedNode);
  }
  collapseAtStart() {
    return true;
  }
};
function $createRootNode() {
  return new RootNode();
}
function $isRootNode(node) {
  return node instanceof RootNode;
}
function editorStateHasDirtySelection(editorState, editor) {
  const currentSelection = editor.getEditorState()._selection;
  const pendingSelection = editorState._selection;
  if (pendingSelection !== null) {
    if (pendingSelection.dirty || !pendingSelection.is(currentSelection)) {
      return true;
    }
  } else if (currentSelection !== null) {
    return true;
  }
  return false;
}
function cloneEditorState(current) {
  return new EditorState(new Map(current._nodeMap));
}
function createEmptyEditorState() {
  return new EditorState(/* @__PURE__ */ new Map([["root", $createRootNode()]]));
}
function exportNodeToJSON(node) {
  const serializedNode = node.exportJSON();
  const nodeClass = node.constructor;
  if (serializedNode.type !== nodeClass.getType()) {
    {
      formatDevErrorMessage(`LexicalNode: Node ${nodeClass.name} does not match the serialized type. Check if .exportJSON() is implemented and it is returning the correct type.`);
    }
  }
  if ($isElementNode(node)) {
    const serializedChildren = serializedNode.children;
    if (!Array.isArray(serializedChildren)) {
      {
        formatDevErrorMessage(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);
      }
    }
    const children = node.getChildren();
    for (let i2 = 0; i2 < children.length; i2++) {
      const child = children[i2];
      const serializedChildNode = exportNodeToJSON(child);
      serializedChildren.push(serializedChildNode);
    }
  }
  return serializedNode;
}
function $isEditorState(x) {
  return x instanceof EditorState;
}
var EditorState = class _EditorState {
  constructor(nodeMap, selection) {
    __publicField(this, "_nodeMap");
    __publicField(this, "_selection");
    __publicField(this, "_flushSync");
    __publicField(this, "_readOnly");
    this._nodeMap = nodeMap;
    this._selection = selection || null;
    this._flushSync = false;
    this._readOnly = false;
  }
  isEmpty() {
    return this._nodeMap.size === 1 && this._selection === null;
  }
  read(callbackFn, options) {
    return readEditorState(options && options.editor || null, this, callbackFn);
  }
  clone(selection) {
    const editorState = new _EditorState(this._nodeMap, selection === void 0 ? this._selection : selection);
    editorState._readOnly = true;
    return editorState;
  }
  toJSON() {
    return readEditorState(null, this, () => ({
      root: exportNodeToJSON($getRoot())
    }));
  }
};
var ArtificialNode__DO_NOT_USE = class extends ElementNode {
  static getType() {
    return "artificial";
  }
  createDOM(config) {
    const dom = document.createElement("div");
    return dom;
  }
};
var ParagraphNode = class _ParagraphNode extends ElementNode {
  /** @internal */
  static getType() {
    return "paragraph";
  }
  static clone(node) {
    return new _ParagraphNode(node.__key);
  }
  // View
  createDOM(config) {
    const dom = document.createElement("p");
    const classNames = getCachedClassNameArray(config.theme, "paragraph");
    if (classNames !== void 0) {
      const domClassList = dom.classList;
      domClassList.add(...classNames);
    }
    return dom;
  }
  updateDOM(prevNode, dom, config) {
    return false;
  }
  static importDOM() {
    return {
      p: (node) => ({
        conversion: $convertParagraphElement,
        priority: 0
      })
    };
  }
  exportDOM(editor) {
    const {
      element
    } = super.exportDOM(editor);
    if (isHTMLElement(element)) {
      if (this.isEmpty()) {
        element.append(document.createElement("br"));
      }
      const formatType = this.getFormatType();
      if (formatType) {
        element.style.textAlign = formatType;
      }
    }
    return {
      element
    };
  }
  static importJSON(serializedNode) {
    return $createParagraphNode().updateFromJSON(serializedNode);
  }
  exportJSON() {
    const json = super.exportJSON();
    if (json.textFormat === void 0 || json.textStyle === void 0) {
      const firstTextNode = this.getChildren().find($isTextNode);
      if (firstTextNode) {
        json.textFormat = firstTextNode.getFormat();
        json.textStyle = firstTextNode.getStyle();
      } else {
        json.textFormat = this.getTextFormat();
        json.textStyle = this.getTextStyle();
      }
    }
    return json;
  }
  // Mutation
  insertNewAfter(rangeSelection, restoreSelection) {
    const newElement = $createParagraphNode();
    newElement.setTextFormat(rangeSelection.format);
    newElement.setTextStyle(rangeSelection.style);
    const direction = this.getDirection();
    newElement.setDirection(direction);
    newElement.setFormat(this.getFormatType());
    newElement.setStyle(this.getStyle());
    this.insertAfter(newElement, restoreSelection);
    return newElement;
  }
  collapseAtStart() {
    const children = this.getChildren();
    if (children.length === 0 || $isTextNode(children[0]) && children[0].getTextContent().trim() === "") {
      const nextSibling = this.getNextSibling();
      if (nextSibling !== null) {
        this.selectNext();
        this.remove();
        return true;
      }
      const prevSibling = this.getPreviousSibling();
      if (prevSibling !== null) {
        this.selectPrevious();
        this.remove();
        return true;
      }
    }
    return false;
  }
};
function $convertParagraphElement(element) {
  const node = $createParagraphNode();
  if (element.style) {
    node.setFormat(element.style.textAlign);
    setNodeIndentFromDOM(element, node);
  }
  return {
    node
  };
}
function $createParagraphNode() {
  return $applyNodeReplacement(new ParagraphNode());
}
function $isParagraphNode(node) {
  return node instanceof ParagraphNode;
}
var DEFAULT_SKIP_INITIALIZATION = false;
var COMMAND_PRIORITY_EDITOR = 0;
var COMMAND_PRIORITY_LOW = 1;
var COMMAND_PRIORITY_NORMAL = 2;
var COMMAND_PRIORITY_HIGH = 3;
var COMMAND_PRIORITY_CRITICAL = 4;
function resetEditor(editor, prevRootElement, nextRootElement, pendingEditorState) {
  const keyNodeMap = editor._keyToDOMMap;
  keyNodeMap.clear();
  editor._editorState = createEmptyEditorState();
  editor._pendingEditorState = pendingEditorState;
  editor._compositionKey = null;
  editor._dirtyType = NO_DIRTY_NODES;
  editor._cloneNotNeeded.clear();
  editor._dirtyLeaves = /* @__PURE__ */ new Set();
  editor._dirtyElements.clear();
  editor._normalizedNodes = /* @__PURE__ */ new Set();
  editor._updateTags = /* @__PURE__ */ new Set();
  editor._updates = [];
  editor._blockCursorElement = null;
  const observer = editor._observer;
  if (observer !== null) {
    observer.disconnect();
    editor._observer = null;
  }
  if (prevRootElement !== null) {
    prevRootElement.textContent = "";
  }
  if (nextRootElement !== null) {
    nextRootElement.textContent = "";
    keyNodeMap.set("root", nextRootElement);
  }
}
function initializeConversionCache(nodes, additionalConversions) {
  const conversionCache = /* @__PURE__ */ new Map();
  const handledConversions = /* @__PURE__ */ new Set();
  const addConversionsToCache = (map) => {
    Object.keys(map).forEach((key) => {
      let currentCache = conversionCache.get(key);
      if (currentCache === void 0) {
        currentCache = [];
        conversionCache.set(key, currentCache);
      }
      currentCache.push(map[key]);
    });
  };
  nodes.forEach((node) => {
    const importDOM = node.klass.importDOM;
    if (importDOM == null || handledConversions.has(importDOM)) {
      return;
    }
    handledConversions.add(importDOM);
    const map = importDOM.call(node.klass);
    if (map !== null) {
      addConversionsToCache(map);
    }
  });
  if (additionalConversions) {
    addConversionsToCache(additionalConversions);
  }
  return conversionCache;
}
function getTransformSetFromKlass(klass) {
  const transforms = /* @__PURE__ */ new Set();
  const staticTransforms = /* @__PURE__ */ new Set();
  let currentKlass = klass;
  while (currentKlass) {
    const {
      ownNodeConfig
    } = getStaticNodeConfig(currentKlass);
    const staticTransform = currentKlass.transform;
    if (!staticTransforms.has(staticTransform)) {
      staticTransforms.add(staticTransform);
      const transform = currentKlass.transform();
      if (transform) {
        transforms.add(transform);
      }
    }
    if (ownNodeConfig) {
      const $transform = ownNodeConfig.$transform;
      if ($transform) {
        transforms.add($transform);
      }
      currentKlass = ownNodeConfig.extends;
    } else {
      const parent = Object.getPrototypeOf(currentKlass);
      currentKlass = parent.prototype instanceof LexicalNode && parent !== LexicalNode ? parent : void 0;
    }
  }
  return transforms;
}
function createEditor(editorConfig) {
  const config = editorConfig || {};
  const activeEditor2 = internalGetActiveEditor();
  const theme2 = config.theme || {};
  const parentEditor = editorConfig === void 0 ? activeEditor2 : config.parentEditor || null;
  const disableEvents = config.disableEvents || false;
  const editorState = createEmptyEditorState();
  const namespace = config.namespace || (parentEditor !== null ? parentEditor._config.namespace : createUID());
  const initialEditorState = config.editorState;
  const nodes = [RootNode, TextNode, LineBreakNode, TabNode, ParagraphNode, ArtificialNode__DO_NOT_USE, ...config.nodes || []];
  const {
    onError,
    html
  } = config;
  const isEditable = config.editable !== void 0 ? config.editable : true;
  let registeredNodes;
  if (editorConfig === void 0 && activeEditor2 !== null) {
    registeredNodes = activeEditor2._nodes;
  } else {
    registeredNodes = /* @__PURE__ */ new Map();
    for (let i2 = 0; i2 < nodes.length; i2++) {
      let klass = nodes[i2];
      let replace = null;
      let replaceWithKlass = null;
      if (typeof klass !== "function") {
        const options = klass;
        klass = options.replace;
        replace = options.with;
        replaceWithKlass = options.withKlass || null;
      }
      void getStaticNodeConfig(klass);
      {
        const name = klass.name;
        const nodeType = hasOwnStaticMethod(klass, "getType") && klass.getType();
        if (replaceWithKlass) {
          if (!(replaceWithKlass.prototype instanceof klass)) {
            formatDevErrorMessage(`${replaceWithKlass.name} doesn't extend the ${name}`);
          }
        } else if (replace) {
          console.warn(`Override for ${name} specifies 'replace' without 'withKlass'. 'withKlass' will be required in a future version.`);
        }
        if (name !== "RootNode" && nodeType !== "root" && nodeType !== "artificial" && // This is mostly for the unit test suite which
        // uses LexicalNode in an otherwise incorrect way
        // by mocking its static getType
        klass !== LexicalNode) {
          ["getType", "clone"].forEach((method) => {
            if (!hasOwnStaticMethod(klass, method)) {
              console.warn(`${name} must implement static "${method}" method`);
            }
          });
          if (!hasOwnStaticMethod(klass, "importDOM") && hasOwnExportDOM(klass)) {
            console.warn(`${name} should implement "importDOM" if using a custom "exportDOM" method to ensure HTML serialization (important for copy & paste) works as expected`);
          }
          if (!hasOwnStaticMethod(klass, "importJSON")) {
            console.warn(`${name} should implement "importJSON" method to ensure JSON and default HTML serialization works as expected`);
          }
        }
      }
      const type = klass.getType();
      const transforms = getTransformSetFromKlass(klass);
      registeredNodes.set(type, {
        exportDOM: html && html.export ? html.export.get(klass) : void 0,
        klass,
        replace,
        replaceWithKlass,
        sharedNodeState: createSharedNodeState(nodes[i2]),
        transforms
      });
    }
  }
  const editor = new LexicalEditor(editorState, parentEditor, registeredNodes, {
    disableEvents,
    namespace,
    theme: theme2
  }, onError ? onError : console.error, initializeConversionCache(registeredNodes, html ? html.import : void 0), isEditable, editorConfig);
  if (initialEditorState !== void 0) {
    editor._pendingEditorState = initialEditorState;
    editor._dirtyType = FULL_RECONCILE;
  }
  registerDefaultCommandHandlers(editor);
  return editor;
}
var LexicalEditor = class {
  /** @internal */
  constructor(editorState, parentEditor, nodes, config, onError, htmlConversions, editable, createEditorArgs) {
    /** @internal */
    __publicField(this, "_headless");
    /** @internal */
    __publicField(this, "_parentEditor");
    /** @internal */
    __publicField(this, "_rootElement");
    /** @internal */
    __publicField(this, "_editorState");
    /** @internal */
    __publicField(this, "_pendingEditorState");
    /** @internal */
    __publicField(this, "_compositionKey");
    /** @internal */
    __publicField(this, "_deferred");
    /** @internal */
    __publicField(this, "_keyToDOMMap");
    /** @internal */
    __publicField(this, "_updates");
    /** @internal */
    __publicField(this, "_updating");
    /** @internal */
    __publicField(this, "_listeners");
    /** @internal */
    __publicField(this, "_commands");
    /** @internal */
    __publicField(this, "_nodes");
    /** @internal */
    __publicField(this, "_decorators");
    /** @internal */
    __publicField(this, "_pendingDecorators");
    /** @internal */
    __publicField(this, "_config");
    /** @internal */
    __publicField(this, "_dirtyType");
    /** @internal */
    __publicField(this, "_cloneNotNeeded");
    /** @internal */
    __publicField(this, "_dirtyLeaves");
    /** @internal */
    __publicField(this, "_dirtyElements");
    /** @internal */
    __publicField(this, "_normalizedNodes");
    /** @internal */
    __publicField(this, "_updateTags");
    /** @internal */
    __publicField(this, "_observer");
    /** @internal */
    __publicField(this, "_key");
    /** @internal */
    __publicField(this, "_onError");
    /** @internal */
    __publicField(this, "_htmlConversions");
    /** @internal */
    __publicField(this, "_window");
    /** @internal */
    __publicField(this, "_editable");
    /** @internal */
    __publicField(this, "_blockCursorElement");
    /** @internal */
    __publicField(this, "_createEditorArgs");
    this._createEditorArgs = createEditorArgs;
    this._parentEditor = parentEditor;
    this._rootElement = null;
    this._editorState = editorState;
    this._pendingEditorState = null;
    this._compositionKey = null;
    this._deferred = [];
    this._keyToDOMMap = /* @__PURE__ */ new Map();
    this._updates = [];
    this._updating = false;
    this._listeners = {
      decorator: /* @__PURE__ */ new Set(),
      editable: /* @__PURE__ */ new Set(),
      mutation: /* @__PURE__ */ new Map(),
      root: /* @__PURE__ */ new Set(),
      textcontent: /* @__PURE__ */ new Set(),
      update: /* @__PURE__ */ new Set()
    };
    this._commands = /* @__PURE__ */ new Map();
    this._config = config;
    this._nodes = nodes;
    this._decorators = {};
    this._pendingDecorators = null;
    this._dirtyType = NO_DIRTY_NODES;
    this._cloneNotNeeded = /* @__PURE__ */ new Set();
    this._dirtyLeaves = /* @__PURE__ */ new Set();
    this._dirtyElements = /* @__PURE__ */ new Map();
    this._normalizedNodes = /* @__PURE__ */ new Set();
    this._updateTags = /* @__PURE__ */ new Set();
    this._observer = null;
    this._key = createUID();
    this._onError = onError;
    this._htmlConversions = htmlConversions;
    this._editable = editable;
    this._headless = parentEditor !== null && parentEditor._headless;
    this._window = null;
    this._blockCursorElement = null;
  }
  /**
   *
   * @returns true if the editor is currently in "composition" mode due to receiving input
   * through an IME, or 3P extension, for example. Returns false otherwise.
   */
  isComposing() {
    return this._compositionKey != null;
  }
  /**
   * Registers a listener for Editor update event. Will trigger the provided callback
   * each time the editor goes through an update (via {@link LexicalEditor.update}) until the
   * teardown function is called.
   *
   * @returns a teardown function that can be used to cleanup the listener.
   */
  registerUpdateListener(listener) {
    const listenerSetOrMap = this._listeners.update;
    listenerSetOrMap.add(listener);
    return () => {
      listenerSetOrMap.delete(listener);
    };
  }
  /**
   * Registers a listener for for when the editor changes between editable and non-editable states.
   * Will trigger the provided callback each time the editor transitions between these states until the
   * teardown function is called.
   *
   * @returns a teardown function that can be used to cleanup the listener.
   */
  registerEditableListener(listener) {
    const listenerSetOrMap = this._listeners.editable;
    listenerSetOrMap.add(listener);
    return () => {
      listenerSetOrMap.delete(listener);
    };
  }
  /**
   * Registers a listener for when the editor's decorator object changes. The decorator object contains
   * all DecoratorNode keys -> their decorated value. This is primarily used with external UI frameworks.
   *
   * Will trigger the provided callback each time the editor transitions between these states until the
   * teardown function is called.
   *
   * @returns a teardown function that can be used to cleanup the listener.
   */
  registerDecoratorListener(listener) {
    const listenerSetOrMap = this._listeners.decorator;
    listenerSetOrMap.add(listener);
    return () => {
      listenerSetOrMap.delete(listener);
    };
  }
  /**
   * Registers a listener for when Lexical commits an update to the DOM and the text content of
   * the editor changes from the previous state of the editor. If the text content is the
   * same between updates, no notifications to the listeners will happen.
   *
   * Will trigger the provided callback each time the editor transitions between these states until the
   * teardown function is called.
   *
   * @returns a teardown function that can be used to cleanup the listener.
   */
  registerTextContentListener(listener) {
    const listenerSetOrMap = this._listeners.textcontent;
    listenerSetOrMap.add(listener);
    return () => {
      listenerSetOrMap.delete(listener);
    };
  }
  /**
   * Registers a listener for when the editor's root DOM element (the content editable
   * Lexical attaches to) changes. This is primarily used to attach event listeners to the root
   *  element. The root listener function is executed directly upon registration and then on
   * any subsequent update.
   *
   * Will trigger the provided callback each time the editor transitions between these states until the
   * teardown function is called.
   *
   * @returns a teardown function that can be used to cleanup the listener.
   */
  registerRootListener(listener) {
    const listenerSetOrMap = this._listeners.root;
    listener(this._rootElement, null);
    listenerSetOrMap.add(listener);
    return () => {
      listener(null, this._rootElement);
      listenerSetOrMap.delete(listener);
    };
  }
  /**
   * Registers a listener that will trigger anytime the provided command
   * is dispatched with {@link LexicalEditor.dispatch}, subject to priority.
   * Listeners that run at a higher priority can "intercept" commands and
   * prevent them from propagating to other handlers by returning true.
   *
   * Listeners are always invoked in an {@link LexicalEditor.update} and can
   * call dollar functions.
   *
   * Listeners registered at the same priority level will run
   * deterministically in the order of registration.
   *
   * @param command - the command that will trigger the callback.
   * @param listener - the function that will execute when the command is dispatched.
   * @param priority - the relative priority of the listener. 0 | 1 | 2 | 3 | 4
   *   (or {@link COMMAND_PRIORITY_EDITOR} |
   *     {@link COMMAND_PRIORITY_LOW} |
   *     {@link COMMAND_PRIORITY_NORMAL} |
   *     {@link COMMAND_PRIORITY_HIGH} |
   *     {@link COMMAND_PRIORITY_CRITICAL})
   * @returns a teardown function that can be used to cleanup the listener.
   */
  registerCommand(command, listener, priority) {
    if (priority === void 0) {
      {
        formatDevErrorMessage(`Listener for type "command" requires a "priority".`);
      }
    }
    const commandsMap = this._commands;
    if (!commandsMap.has(command)) {
      commandsMap.set(command, [/* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set()]);
    }
    const listenersInPriorityOrder = commandsMap.get(command);
    if (listenersInPriorityOrder === void 0) {
      {
        formatDevErrorMessage(`registerCommand: Command ${String(command)} not found in command map`);
      }
    }
    const listeners = listenersInPriorityOrder[priority];
    listeners.add(listener);
    return () => {
      listeners.delete(listener);
      if (listenersInPriorityOrder.every((listenersSet) => listenersSet.size === 0)) {
        commandsMap.delete(command);
      }
    };
  }
  /**
   * Registers a listener that will run when a Lexical node of the provided class is
   * mutated. The listener will receive a list of nodes along with the type of mutation
   * that was performed on each: created, destroyed, or updated.
   *
   * One common use case for this is to attach DOM event listeners to the underlying DOM nodes as Lexical nodes are created.
   * {@link LexicalEditor.getElementByKey} can be used for this.
   *
   * If any existing nodes are in the DOM, and skipInitialization is not true, the listener
   * will be called immediately with an updateTag of 'registerMutationListener' where all
   * nodes have the 'created' NodeMutation. This can be controlled with the skipInitialization option
   * (whose default was previously true for backwards compatibility with &lt;=0.16.1 but has been changed to false as of 0.21.0).
   *
   * @param klass - The class of the node that you want to listen to mutations on.
   * @param listener - The logic you want to run when the node is mutated.
   * @param options - see {@link MutationListenerOptions}
   * @returns a teardown function that can be used to cleanup the listener.
   */
  registerMutationListener(klass, listener, options) {
    const klassToMutate = this.resolveRegisteredNodeAfterReplacements(this.getRegisteredNode(klass)).klass;
    const mutations = this._listeners.mutation;
    let klassSet = mutations.get(listener);
    if (klassSet === void 0) {
      klassSet = /* @__PURE__ */ new Set();
      mutations.set(listener, klassSet);
    }
    klassSet.add(klassToMutate);
    const skipInitialization = options && options.skipInitialization;
    if (!(skipInitialization === void 0 ? DEFAULT_SKIP_INITIALIZATION : skipInitialization)) {
      this.initializeMutationListener(listener, klassToMutate);
    }
    return () => {
      klassSet.delete(klassToMutate);
      if (klassSet.size === 0) {
        mutations.delete(listener);
      }
    };
  }
  /** @internal */
  getRegisteredNode(klass) {
    const registeredNode = this._nodes.get(klass.getType());
    if (registeredNode === void 0) {
      {
        formatDevErrorMessage(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);
      }
    }
    return registeredNode;
  }
  /** @internal */
  resolveRegisteredNodeAfterReplacements(registeredNode) {
    while (registeredNode.replaceWithKlass) {
      registeredNode = this.getRegisteredNode(registeredNode.replaceWithKlass);
    }
    return registeredNode;
  }
  /** @internal */
  initializeMutationListener(listener, klass) {
    const prevEditorState = this._editorState;
    const nodeMap = getCachedTypeToNodeMap(prevEditorState).get(klass.getType());
    if (!nodeMap) {
      return;
    }
    const nodeMutationMap = /* @__PURE__ */ new Map();
    for (const k of nodeMap.keys()) {
      nodeMutationMap.set(k, "created");
    }
    if (nodeMutationMap.size > 0) {
      listener(nodeMutationMap, {
        dirtyLeaves: /* @__PURE__ */ new Set(),
        prevEditorState,
        updateTags: /* @__PURE__ */ new Set(["registerMutationListener"])
      });
    }
  }
  /** @internal */
  registerNodeTransformToKlass(klass, listener) {
    const registeredNode = this.getRegisteredNode(klass);
    registeredNode.transforms.add(listener);
    return registeredNode;
  }
  /**
   * Registers a listener that will run when a Lexical node of the provided class is
   * marked dirty during an update. The listener will continue to run as long as the node
   * is marked dirty. There are no guarantees around the order of transform execution!
   *
   * Watch out for infinite loops. See [Node Transforms](https://lexical.dev/docs/concepts/transforms)
   * @param klass - The class of the node that you want to run transforms on.
   * @param listener - The logic you want to run when the node is updated.
   * @returns a teardown function that can be used to cleanup the listener.
   */
  registerNodeTransform(klass, listener) {
    const registeredNode = this.registerNodeTransformToKlass(klass, listener);
    const registeredNodes = [registeredNode];
    const replaceWithKlass = registeredNode.replaceWithKlass;
    if (replaceWithKlass != null) {
      const registeredReplaceWithNode = this.registerNodeTransformToKlass(replaceWithKlass, listener);
      registeredNodes.push(registeredReplaceWithNode);
    }
    markNodesWithTypesAsDirty(this, registeredNodes.map((node) => node.klass.getType()));
    return () => {
      registeredNodes.forEach((node) => node.transforms.delete(listener));
    };
  }
  /**
   * Used to assert that a certain node is registered, usually by plugins to ensure nodes that they
   * depend on have been registered.
   * @returns True if the editor has registered the provided node type, false otherwise.
   */
  hasNode(node) {
    return this._nodes.has(node.getType());
  }
  /**
   * Used to assert that certain nodes are registered, usually by plugins to ensure nodes that they
   * depend on have been registered.
   * @returns True if the editor has registered all of the provided node types, false otherwise.
   */
  hasNodes(nodes) {
    return nodes.every(this.hasNode.bind(this));
  }
  /**
   * Dispatches a command of the specified type with the specified payload.
   * This triggers all command listeners (set by {@link LexicalEditor.registerCommand})
   * for this type, passing them the provided payload. The command listeners
   * will be triggered in an implicit {@link LexicalEditor.update}, unless
   * this was invoked from inside an update in which case that update context
   * will be re-used (as if this was a dollar function itself).
   * @param type - the type of command listeners to trigger.
   * @param payload - the data to pass as an argument to the command listeners.
   */
  dispatchCommand(type, payload) {
    return dispatchCommand(this, type, payload);
  }
  /**
   * Gets a map of all decorators in the editor.
   * @returns A mapping of call decorator keys to their decorated content
   */
  getDecorators() {
    return this._decorators;
  }
  /**
   *
   * @returns the current root element of the editor. If you want to register
   * an event listener, do it via {@link LexicalEditor.registerRootListener}, since
   * this reference may not be stable.
   */
  getRootElement() {
    return this._rootElement;
  }
  /**
   * Gets the key of the editor
   * @returns The editor key
   */
  getKey() {
    return this._key;
  }
  /**
   * Imperatively set the root contenteditable element that Lexical listens
   * for events on.
   */
  setRootElement(nextRootElement) {
    const prevRootElement = this._rootElement;
    if (nextRootElement !== prevRootElement) {
      const classNames = getCachedClassNameArray(this._config.theme, "root");
      const pendingEditorState = this._pendingEditorState || this._editorState;
      this._rootElement = nextRootElement;
      resetEditor(this, prevRootElement, nextRootElement, pendingEditorState);
      if (prevRootElement !== null) {
        if (!this._config.disableEvents) {
          removeRootElementEvents(prevRootElement);
        }
        if (classNames != null) {
          prevRootElement.classList.remove(...classNames);
        }
      }
      if (nextRootElement !== null) {
        const windowObj = getDefaultView(nextRootElement);
        const style = nextRootElement.style;
        style.userSelect = "text";
        style.whiteSpace = "pre-wrap";
        style.wordBreak = "break-word";
        nextRootElement.setAttribute("data-lexical-editor", "true");
        this._window = windowObj;
        this._dirtyType = FULL_RECONCILE;
        initMutationObserver(this);
        this._updateTags.add(HISTORY_MERGE_TAG);
        $commitPendingUpdates(this);
        if (!this._config.disableEvents) {
          addRootElementEvents(nextRootElement, this);
        }
        if (classNames != null) {
          nextRootElement.classList.add(...classNames);
        }
        {
          const nextRootElementParent = nextRootElement.parentElement;
          if (nextRootElementParent != null && ["flex", "inline-flex"].includes(getComputedStyle(nextRootElementParent).display)) {
            console.warn(`When using "display: flex" or "display: inline-flex" on an element containing content editable, Chrome may have unwanted focusing behavior when clicking outside of it. Consider wrapping the content editable within a non-flex element.`);
          }
        }
      } else {
        this._window = null;
        this._updateTags.add(HISTORY_MERGE_TAG);
        $commitPendingUpdates(this);
      }
      triggerListeners("root", this, false, nextRootElement, prevRootElement);
    }
  }
  /**
   * Gets the underlying HTMLElement associated with the LexicalNode for the given key.
   * @returns the HTMLElement rendered by the LexicalNode associated with the key.
   * @param key - the key of the LexicalNode.
   */
  getElementByKey(key) {
    return this._keyToDOMMap.get(key) || null;
  }
  /**
   * Gets the active editor state.
   * @returns The editor state
   */
  getEditorState() {
    return this._editorState;
  }
  /**
   * Imperatively set the EditorState. Triggers reconciliation like an update.
   * @param editorState - the state to set the editor
   * @param options - options for the update.
   */
  setEditorState(editorState, options) {
    if (editorState.isEmpty()) {
      {
        formatDevErrorMessage(`setEditorState: the editor state is empty. Ensure the editor state's root node never becomes empty.`);
      }
    }
    let writableEditorState = editorState;
    if (writableEditorState._readOnly) {
      writableEditorState = cloneEditorState(editorState);
      writableEditorState._selection = editorState._selection ? editorState._selection.clone() : null;
    }
    flushRootMutations(this);
    const pendingEditorState = this._pendingEditorState;
    const tags = this._updateTags;
    const tag = options !== void 0 ? options.tag : null;
    if (pendingEditorState !== null && !pendingEditorState.isEmpty()) {
      if (tag != null) {
        tags.add(tag);
      }
      $commitPendingUpdates(this);
    }
    this._pendingEditorState = writableEditorState;
    this._dirtyType = FULL_RECONCILE;
    this._dirtyElements.set("root", false);
    this._compositionKey = null;
    if (tag != null) {
      tags.add(tag);
    }
    if (!this._updating) {
      $commitPendingUpdates(this);
    }
  }
  /**
   * Parses a SerializedEditorState (usually produced by {@link EditorState.toJSON}) and returns
   * and EditorState object that can be, for example, passed to {@link LexicalEditor.setEditorState}. Typically,
   * deserialization from JSON stored in a database uses this method.
   * @param maybeStringifiedEditorState
   * @param updateFn
   * @returns
   */
  parseEditorState(maybeStringifiedEditorState, updateFn) {
    const serializedEditorState = typeof maybeStringifiedEditorState === "string" ? JSON.parse(maybeStringifiedEditorState) : maybeStringifiedEditorState;
    return parseEditorState(serializedEditorState, this, updateFn);
  }
  /**
   * Executes a read of the editor's state, with the
   * editor context available (useful for exporting and read-only DOM
   * operations). Much like update, but prevents any mutation of the
   * editor's state. Any pending updates will be flushed immediately before
   * the read.
   * @param callbackFn - A function that has access to read-only editor state.
   */
  read(callbackFn) {
    $commitPendingUpdates(this);
    return this.getEditorState().read(callbackFn, {
      editor: this
    });
  }
  /**
   * Executes an update to the editor state. The updateFn callback is the ONLY place
   * where Lexical editor state can be safely mutated.
   * @param updateFn - A function that has access to writable editor state.
   * @param options - A bag of options to control the behavior of the update.
   */
  update(updateFn, options) {
    updateEditor(this, updateFn, options);
  }
  /**
   * Focuses the editor by marking the existing selection as dirty, or by
   * creating a new selection at `defaultSelection` if one does not already
   * exist. If you want to force a specific selection, you should call
   * `root.selectStart()` or `root.selectEnd()` in an update.
   *
   * @param callbackFn - A function to run after the editor is focused.
   * @param options - A bag of options
   */
  focus(callbackFn, options = {}) {
    const rootElement = this._rootElement;
    if (rootElement !== null) {
      rootElement.setAttribute("autocapitalize", "off");
      updateEditorSync(this, () => {
        const selection = $getSelection();
        const root = $getRoot();
        if (selection !== null) {
          if (!selection.dirty) {
            $setSelection(selection.clone());
          }
        } else if (root.getChildrenSize() !== 0) {
          if (options.defaultSelection === "rootStart") {
            root.selectStart();
          } else {
            root.selectEnd();
          }
        }
        $addUpdateTag(FOCUS_TAG);
        $onUpdate(() => {
          rootElement.removeAttribute("autocapitalize");
          if (callbackFn) {
            callbackFn();
          }
        });
      });
      if (this._pendingEditorState === null) {
        rootElement.removeAttribute("autocapitalize");
      }
    }
  }
  /**
   * Removes focus from the editor.
   */
  blur() {
    const rootElement = this._rootElement;
    if (rootElement !== null) {
      rootElement.blur();
    }
    const domSelection = getDOMSelection(this._window);
    if (domSelection !== null) {
      domSelection.removeAllRanges();
    }
  }
  /**
   * Returns true if the editor is editable, false otherwise.
   * @returns True if the editor is editable, false otherwise.
   */
  isEditable() {
    return this._editable;
  }
  /**
   * Sets the editable property of the editor. When false, the
   * editor will not listen for user events on the underling contenteditable.
   * @param editable - the value to set the editable mode to.
   */
  setEditable(editable) {
    if (this._editable !== editable) {
      this._editable = editable;
      triggerListeners("editable", this, true, editable);
    }
  }
  /**
   * Returns a JSON-serializable javascript object NOT a JSON string.
   * You still must call JSON.stringify (or something else) to turn the
   * state into a string you can transfer over the wire and store in a database.
   *
   * See {@link LexicalNode.exportJSON}
   *
   * @returns A JSON-serializable javascript object
   */
  toJSON() {
    return {
      editorState: this._editorState.toJSON()
    };
  }
};
/** @internal */
/** The version with build identifiers for this editor (since 0.17.1) */
__publicField(LexicalEditor, "version");
LexicalEditor.version = "0.39.0+dev.esm";
var pendingNodeToClone = null;
function setPendingNodeToClone(pendingNode) {
  pendingNodeToClone = pendingNode;
}
function getPendingNodeToClone() {
  const node = pendingNodeToClone;
  pendingNodeToClone = null;
  return node;
}
var keyCounter = 1;
function resetRandomKey() {
  keyCounter = 1;
}
function generateRandomKey() {
  return "" + keyCounter++;
}
function getRegisteredNodeOrThrow(editor, nodeType) {
  const registeredNode = getRegisteredNode(editor, nodeType);
  if (registeredNode === void 0) {
    {
      formatDevErrorMessage(`registeredNode: Type ${nodeType} not found`);
    }
  }
  return registeredNode;
}
function getRegisteredNode(editor, nodeType) {
  return editor._nodes.get(nodeType);
}
var scheduleMicroTask = typeof queueMicrotask === "function" ? queueMicrotask : (fn) => {
  Promise.resolve().then(fn);
};
function $isSelectionCapturedInDecorator(node) {
  return $isDecoratorNode($getNearestNodeFromDOMNode(node));
}
function isSelectionCapturedInDecoratorInput(anchorDOM) {
  const activeElement = document.activeElement;
  if (!isHTMLElement(activeElement)) {
    return false;
  }
  const nodeName = activeElement.nodeName;
  return $isDecoratorNode($getNearestNodeFromDOMNode(anchorDOM)) && (nodeName === "INPUT" || nodeName === "TEXTAREA" || activeElement.contentEditable === "true" && getEditorPropertyFromDOMNode(activeElement) == null);
}
function isSelectionWithinEditor(editor, anchorDOM, focusDOM) {
  const rootElement = editor.getRootElement();
  try {
    return rootElement !== null && rootElement.contains(anchorDOM) && rootElement.contains(focusDOM) && // Ignore if selection is within nested editor
    anchorDOM !== null && !isSelectionCapturedInDecoratorInput(anchorDOM) && getNearestEditorFromDOMNode(anchorDOM) === editor;
  } catch (_error) {
    return false;
  }
}
function isLexicalEditor(editor) {
  return editor instanceof LexicalEditor;
}
function getNearestEditorFromDOMNode(node) {
  let currentNode = node;
  while (currentNode != null) {
    const editor = getEditorPropertyFromDOMNode(currentNode);
    if (isLexicalEditor(editor)) {
      return editor;
    }
    currentNode = getParentElement(currentNode);
  }
  return null;
}
function getEditorPropertyFromDOMNode(node) {
  return node ? node.__lexicalEditor : null;
}
function getTextDirection(text) {
  if (RTL_REGEX.test(text)) {
    return "rtl";
  }
  if (LTR_REGEX.test(text)) {
    return "ltr";
  }
  return null;
}
function $isTokenOrTab(node) {
  return $isTabNode(node) || node.isToken();
}
function $isTokenOrSegmented(node) {
  return $isTokenOrTab(node) || node.isSegmented();
}
function isDOMTextNode(node) {
  return isDOMNode(node) && node.nodeType === DOM_TEXT_TYPE;
}
function isDOMDocumentNode(node) {
  return isDOMNode(node) && node.nodeType === DOM_DOCUMENT_TYPE;
}
function getDOMTextNode(element) {
  let node = element;
  while (node != null) {
    if (isDOMTextNode(node)) {
      return node;
    }
    node = node.firstChild;
  }
  return null;
}
function toggleTextFormatType(format, type, alignWithFormat) {
  const activeFormat = TEXT_TYPE_TO_FORMAT[type];
  if (alignWithFormat !== null && (format & activeFormat) === (alignWithFormat & activeFormat)) {
    return format;
  }
  let newFormat = format ^ activeFormat;
  if (type === "subscript") {
    newFormat &= ~TEXT_TYPE_TO_FORMAT.superscript;
  } else if (type === "superscript") {
    newFormat &= ~TEXT_TYPE_TO_FORMAT.subscript;
  } else if (type === "lowercase") {
    newFormat &= ~TEXT_TYPE_TO_FORMAT.uppercase;
    newFormat &= ~TEXT_TYPE_TO_FORMAT.capitalize;
  } else if (type === "uppercase") {
    newFormat &= ~TEXT_TYPE_TO_FORMAT.lowercase;
    newFormat &= ~TEXT_TYPE_TO_FORMAT.capitalize;
  } else if (type === "capitalize") {
    newFormat &= ~TEXT_TYPE_TO_FORMAT.lowercase;
    newFormat &= ~TEXT_TYPE_TO_FORMAT.uppercase;
  }
  return newFormat;
}
function $isLeafNode(node) {
  return $isTextNode(node) || $isLineBreakNode(node) || $isDecoratorNode(node);
}
function $setNodeKey(node, existingKey) {
  const pendingNode = getPendingNodeToClone();
  existingKey = existingKey || pendingNode && pendingNode.__key;
  if (existingKey != null) {
    {
      errorOnNodeKeyConstructorMismatch(node, existingKey, pendingNode);
    }
    node.__key = existingKey;
    return;
  }
  errorOnReadOnly();
  errorOnInfiniteTransforms();
  const editor = getActiveEditor();
  const editorState = getActiveEditorState();
  const key = generateRandomKey();
  editorState._nodeMap.set(key, node);
  if ($isElementNode(node)) {
    editor._dirtyElements.set(key, true);
  } else {
    editor._dirtyLeaves.add(key);
  }
  editor._cloneNotNeeded.add(key);
  editor._dirtyType = HAS_DIRTY_NODES;
  node.__key = key;
}
function errorOnNodeKeyConstructorMismatch(node, existingKey, pendingNode) {
  const editorState = internalGetActiveEditorState();
  if (!editorState) {
    return;
  }
  const existingNode = editorState._nodeMap.get(existingKey);
  if (pendingNode) {
    if (!(existingKey === pendingNode.__key)) {
      formatDevErrorMessage(`Lexical node with constructor ${node.constructor.name} (type ${node.getType()}) has an incorrect clone implementation, got ${String(existingKey)} for nodeKey when expecting ${pendingNode.__key}`);
    }
  }
  if (existingNode && existingNode.constructor !== node.constructor) {
    if (node.constructor.name !== existingNode.constructor.name) {
      {
        formatDevErrorMessage(`Lexical node with constructor ${node.constructor.name} attempted to re-use key from node in active editor state with constructor ${existingNode.constructor.name}. Keys must not be re-used when the type is changed.`);
      }
    } else {
      {
        formatDevErrorMessage(`Lexical node with constructor ${node.constructor.name} attempted to re-use key from node in active editor state with different constructor with the same name (possibly due to invalid Hot Module Replacement). Keys must not be re-used when the type is changed.`);
      }
    }
  }
}
function internalMarkParentElementsAsDirty(parentKey, nodeMap, dirtyElements) {
  let nextParentKey = parentKey;
  while (nextParentKey !== null) {
    if (dirtyElements.has(nextParentKey)) {
      return;
    }
    const node = nodeMap.get(nextParentKey);
    if (node === void 0) {
      break;
    }
    dirtyElements.set(nextParentKey, false);
    nextParentKey = node.__parent;
  }
}
function removeFromParent(node) {
  const oldParent = node.getParent();
  if (oldParent !== null) {
    const writableNode = node.getWritable();
    const writableParent = oldParent.getWritable();
    const prevSibling = node.getPreviousSibling();
    const nextSibling = node.getNextSibling();
    const nextSiblingKey = nextSibling !== null ? nextSibling.__key : null;
    const prevSiblingKey = prevSibling !== null ? prevSibling.__key : null;
    const writablePrevSibling = prevSibling !== null ? prevSibling.getWritable() : null;
    const writableNextSibling = nextSibling !== null ? nextSibling.getWritable() : null;
    if (prevSibling === null) {
      writableParent.__first = nextSiblingKey;
    }
    if (nextSibling === null) {
      writableParent.__last = prevSiblingKey;
    }
    if (writablePrevSibling !== null) {
      writablePrevSibling.__next = nextSiblingKey;
    }
    if (writableNextSibling !== null) {
      writableNextSibling.__prev = prevSiblingKey;
    }
    writableNode.__prev = null;
    writableNode.__next = null;
    writableNode.__parent = null;
    writableParent.__size--;
  }
}
function internalMarkNodeAsDirty(node) {
  errorOnInfiniteTransforms();
  if (!!$isEphemeral(node)) {
    formatDevErrorMessage(`internalMarkNodeAsDirty: Ephemeral nodes must not be marked as dirty (key ${node.__key} type ${node.__type})`);
  }
  const latest = node.getLatest();
  const parent = latest.__parent;
  const editorState = getActiveEditorState();
  const editor = getActiveEditor();
  const nodeMap = editorState._nodeMap;
  const dirtyElements = editor._dirtyElements;
  if (parent !== null) {
    internalMarkParentElementsAsDirty(parent, nodeMap, dirtyElements);
  }
  const key = latest.__key;
  editor._dirtyType = HAS_DIRTY_NODES;
  if ($isElementNode(node)) {
    dirtyElements.set(key, true);
  } else {
    editor._dirtyLeaves.add(key);
  }
}
function internalMarkSiblingsAsDirty(node) {
  const previousNode = node.getPreviousSibling();
  const nextNode = node.getNextSibling();
  if (previousNode !== null) {
    internalMarkNodeAsDirty(previousNode);
  }
  if (nextNode !== null) {
    internalMarkNodeAsDirty(nextNode);
  }
}
function $setCompositionKey(compositionKey) {
  errorOnReadOnly();
  const editor = getActiveEditor();
  const previousCompositionKey = editor._compositionKey;
  if (compositionKey !== previousCompositionKey) {
    editor._compositionKey = compositionKey;
    if (previousCompositionKey !== null) {
      const node = $getNodeByKey(previousCompositionKey);
      if (node !== null) {
        node.getWritable();
      }
    }
    if (compositionKey !== null) {
      const node = $getNodeByKey(compositionKey);
      if (node !== null) {
        node.getWritable();
      }
    }
  }
}
function $getCompositionKey() {
  if (isCurrentlyReadOnlyMode()) {
    return null;
  }
  const editor = getActiveEditor();
  return editor._compositionKey;
}
function $getNodeByKey(key, _editorState) {
  const editorState = _editorState || getActiveEditorState();
  const node = editorState._nodeMap.get(key);
  if (node === void 0) {
    return null;
  }
  return node;
}
function $getNodeFromDOMNode(dom, editorState) {
  const editor = getActiveEditor();
  const key = getNodeKeyFromDOMNode(dom, editor);
  if (key !== void 0) {
    return $getNodeByKey(key, editorState);
  }
  return null;
}
function setNodeKeyOnDOMNode(dom, editor, key) {
  const prop = `__lexicalKey_${editor._key}`;
  dom[prop] = key;
}
function getNodeKeyFromDOMNode(dom, editor) {
  const prop = `__lexicalKey_${editor._key}`;
  return dom[prop];
}
function $getNearestNodeFromDOMNode(startingDOM, editorState) {
  let dom = startingDOM;
  while (dom != null) {
    const node = $getNodeFromDOMNode(dom, editorState);
    if (node !== null) {
      return node;
    }
    dom = getParentElement(dom);
  }
  return null;
}
function cloneDecorators(editor) {
  const currentDecorators = editor._decorators;
  const pendingDecorators = Object.assign({}, currentDecorators);
  editor._pendingDecorators = pendingDecorators;
  return pendingDecorators;
}
function getEditorStateTextContent(editorState) {
  return editorState.read(() => $getRoot().getTextContent());
}
function markNodesWithTypesAsDirty(editor, types) {
  const cachedMap = getCachedTypeToNodeMap(editor.getEditorState());
  const dirtyNodeMaps = [];
  for (const type of types) {
    const nodeMap = cachedMap.get(type);
    if (nodeMap) {
      dirtyNodeMaps.push(nodeMap);
    }
  }
  if (dirtyNodeMaps.length === 0) {
    return;
  }
  editor.update(() => {
    for (const nodeMap of dirtyNodeMaps) {
      for (const nodeKey of nodeMap.keys()) {
        const latest = $getNodeByKey(nodeKey);
        if (latest) {
          latest.markDirty();
        }
      }
    }
  }, editor._pendingEditorState === null ? {
    tag: HISTORY_MERGE_TAG
  } : void 0);
}
function $getRoot() {
  return internalGetRoot(getActiveEditorState());
}
function internalGetRoot(editorState) {
  return editorState._nodeMap.get("root");
}
function $setSelection(selection) {
  errorOnReadOnly();
  const editorState = getActiveEditorState();
  if (selection !== null) {
    {
      if (Object.isFrozen(selection)) {
        {
          formatDevErrorMessage(`$setSelection called on frozen selection object. Ensure selection is cloned before passing in.`);
        }
      }
    }
    selection.dirty = true;
    selection.setCachedNodes(null);
  }
  editorState._selection = selection;
}
function $flushMutations() {
  errorOnReadOnly();
  const editor = getActiveEditor();
  flushRootMutations(editor);
}
function $getNodeFromDOM(dom) {
  const editor = getActiveEditor();
  const nodeKey = getNodeKeyFromDOMTree(dom, editor);
  if (nodeKey === null) {
    const rootElement = editor.getRootElement();
    if (dom === rootElement) {
      return $getNodeByKey("root");
    }
    return null;
  }
  return $getNodeByKey(nodeKey);
}
function getNodeKeyFromDOMTree(dom, editor) {
  let node = dom;
  while (node != null) {
    const key = getNodeKeyFromDOMNode(node, editor);
    if (key !== void 0) {
      return key;
    }
    node = getParentElement(node);
  }
  return null;
}
function doesContainSurrogatePair(str) {
  return /[\uD800-\uDBFF][\uDC00-\uDFFF]/g.test(str);
}
function getEditorsToPropagate(editor) {
  const editorsToPropagate = [];
  let currentEditor = editor;
  while (currentEditor !== null) {
    editorsToPropagate.push(currentEditor);
    currentEditor = currentEditor._parentEditor;
  }
  return editorsToPropagate;
}
function createUID() {
  return Math.random().toString(36).replace(/[^a-z]+/g, "").substring(0, 5);
}
function getAnchorTextFromDOM(anchorNode) {
  return isDOMTextNode(anchorNode) ? anchorNode.nodeValue : null;
}
function $updateSelectedTextFromDOM(isCompositionEnd, editor, data) {
  const domSelection = getDOMSelection(getWindow(editor));
  if (domSelection === null) {
    return;
  }
  const anchorNode = domSelection.anchorNode;
  let {
    anchorOffset,
    focusOffset
  } = domSelection;
  if (anchorNode !== null) {
    let textContent = getAnchorTextFromDOM(anchorNode);
    const node = $getNearestNodeFromDOMNode(anchorNode);
    if (textContent !== null && $isTextNode(node)) {
      if (textContent === COMPOSITION_SUFFIX && data) {
        const offset = data.length;
        textContent = data;
        anchorOffset = offset;
        focusOffset = offset;
      }
      if (textContent !== null) {
        $updateTextNodeFromDOMContent(node, textContent, anchorOffset, focusOffset, isCompositionEnd);
      }
    }
  }
}
function $updateTextNodeFromDOMContent(textNode, textContent, anchorOffset, focusOffset, compositionEnd) {
  let node = textNode;
  if (node.isAttached() && (compositionEnd || !node.isDirty())) {
    const isComposing = node.isComposing();
    let normalizedTextContent = textContent;
    if ((isComposing || compositionEnd) && textContent[textContent.length - 1] === COMPOSITION_SUFFIX) {
      normalizedTextContent = textContent.slice(0, -1);
    }
    const prevTextContent = node.getTextContent();
    if (compositionEnd || normalizedTextContent !== prevTextContent) {
      if (normalizedTextContent === "") {
        $setCompositionKey(null);
        if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT) {
          const editor = getActiveEditor();
          setTimeout(() => {
            editor.update(() => {
              if (node.isAttached()) {
                node.remove();
              }
            });
          }, 20);
        } else {
          node.remove();
        }
        return;
      }
      const parent = node.getParent();
      const prevSelection = $getPreviousSelection();
      const prevTextContentSize = node.getTextContentSize();
      const compositionKey = $getCompositionKey();
      const nodeKey = node.getKey();
      if (node.isToken() || compositionKey !== null && nodeKey === compositionKey && !isComposing || // Check if character was added at the start or boundaries when not insertable, and we need
      // to clear this input from occurring as that action wasn't permitted.
      $isRangeSelection(prevSelection) && (parent !== null && !parent.canInsertTextBefore() && prevSelection.anchor.offset === 0 || prevSelection.anchor.key === textNode.__key && prevSelection.anchor.offset === 0 && !node.canInsertTextBefore() && !isComposing || prevSelection.focus.key === textNode.__key && prevSelection.focus.offset === prevTextContentSize && !node.canInsertTextAfter() && !isComposing)) {
        node.markDirty();
        return;
      }
      const selection = $getSelection();
      if (!$isRangeSelection(selection) || anchorOffset === null || focusOffset === null) {
        $setTextContentWithSelection(node, normalizedTextContent, selection);
        return;
      }
      selection.setTextNodeRange(node, anchorOffset, node, focusOffset);
      if (node.isSegmented()) {
        const originalTextContent = node.getTextContent();
        const replacement = $createTextNode(originalTextContent);
        node.replace(replacement);
        node = replacement;
      }
      $setTextContentWithSelection(node, normalizedTextContent, selection);
    }
  }
}
function $setTextContentWithSelection(node, textContent, selection) {
  node.setTextContent(textContent);
  if ($isRangeSelection(selection)) {
    const key = node.getKey();
    for (const k of ["anchor", "focus"]) {
      const pt = selection[k];
      if (pt.type === "text" && pt.key === key) {
        pt.offset = $getTextNodeOffset(node, pt.offset, "clamp");
      }
    }
  }
}
function $previousSiblingDoesNotAcceptText(node) {
  const previousSibling = node.getPreviousSibling();
  return ($isTextNode(previousSibling) || $isElementNode(previousSibling) && previousSibling.isInline()) && !previousSibling.canInsertTextAfter();
}
function $shouldInsertTextAfterOrBeforeTextNode(selection, node) {
  if (node.isSegmented()) {
    return true;
  }
  if (!selection.isCollapsed()) {
    return false;
  }
  const offset = selection.anchor.offset;
  const parent = node.getParentOrThrow();
  const isToken = $isTokenOrTab(node);
  if (offset === 0) {
    return !node.canInsertTextBefore() || !parent.canInsertTextBefore() && !node.isComposing() || isToken || $previousSiblingDoesNotAcceptText(node);
  } else if (offset === node.getTextContentSize()) {
    return !node.canInsertTextAfter() || !parent.canInsertTextAfter() && !node.isComposing() || isToken;
  } else {
    return false;
  }
}
function matchModifier(event, mask, prop) {
  const expected = mask[prop] || false;
  return expected === "any" || expected === event[prop];
}
function isModifierMatch(event, mask) {
  return matchModifier(event, mask, "altKey") && matchModifier(event, mask, "ctrlKey") && matchModifier(event, mask, "shiftKey") && matchModifier(event, mask, "metaKey");
}
function isExactShortcutMatch(event, expectedKey, mask) {
  return isModifierMatch(event, mask) && event.key.toLowerCase() === expectedKey.toLowerCase();
}
var CONTROL_OR_META = {
  ctrlKey: !IS_APPLE,
  metaKey: IS_APPLE
};
var CONTROL_OR_ALT = {
  altKey: IS_APPLE,
  ctrlKey: !IS_APPLE
};
function isTab(event) {
  return isExactShortcutMatch(event, "Tab", {
    shiftKey: "any"
  });
}
function isBold(event) {
  return isExactShortcutMatch(event, "b", CONTROL_OR_META);
}
function isItalic(event) {
  return isExactShortcutMatch(event, "i", CONTROL_OR_META);
}
function isUnderline(event) {
  return isExactShortcutMatch(event, "u", CONTROL_OR_META);
}
function isParagraph(event) {
  return isExactShortcutMatch(event, "Enter", {
    altKey: "any",
    ctrlKey: "any",
    metaKey: "any"
  });
}
function isLineBreak(event) {
  return isExactShortcutMatch(event, "Enter", {
    altKey: "any",
    ctrlKey: "any",
    metaKey: "any",
    shiftKey: true
  });
}
function isOpenLineBreak(event) {
  return IS_APPLE && isExactShortcutMatch(event, "o", {
    ctrlKey: true
  });
}
function isDeleteWordBackward(event) {
  return isExactShortcutMatch(event, "Backspace", CONTROL_OR_ALT);
}
function isDeleteWordForward(event) {
  return isExactShortcutMatch(event, "Delete", CONTROL_OR_ALT);
}
function isDeleteLineBackward(event) {
  return IS_APPLE && isExactShortcutMatch(event, "Backspace", {
    metaKey: true
  });
}
function isDeleteLineForward(event) {
  return IS_APPLE && (isExactShortcutMatch(event, "Delete", {
    metaKey: true
  }) || isExactShortcutMatch(event, "k", {
    ctrlKey: true
  }));
}
function isDeleteBackward(event) {
  return isExactShortcutMatch(event, "Backspace", {
    shiftKey: "any"
  }) || IS_APPLE && isExactShortcutMatch(event, "h", {
    ctrlKey: true
  });
}
function isDeleteForward(event) {
  return isExactShortcutMatch(event, "Delete", {}) || IS_APPLE && isExactShortcutMatch(event, "d", {
    ctrlKey: true
  });
}
function isUndo(event) {
  return isExactShortcutMatch(event, "z", CONTROL_OR_META);
}
function isRedo(event) {
  if (IS_APPLE) {
    return isExactShortcutMatch(event, "z", {
      metaKey: true,
      shiftKey: true
    });
  }
  return isExactShortcutMatch(event, "y", {
    ctrlKey: true
  }) || isExactShortcutMatch(event, "z", {
    ctrlKey: true,
    shiftKey: true
  });
}
function isCopy(event) {
  return isExactShortcutMatch(event, "c", CONTROL_OR_META);
}
function isCut(event) {
  return isExactShortcutMatch(event, "x", CONTROL_OR_META);
}
function isMoveBackward(event) {
  return isExactShortcutMatch(event, "ArrowLeft", {
    shiftKey: "any"
  });
}
function isMoveToStart(event) {
  return isExactShortcutMatch(event, "ArrowLeft", CONTROL_OR_META);
}
function isMoveForward(event) {
  return isExactShortcutMatch(event, "ArrowRight", {
    shiftKey: "any"
  });
}
function isMoveToEnd(event) {
  return isExactShortcutMatch(event, "ArrowRight", CONTROL_OR_META);
}
function isMoveUp(event) {
  return isExactShortcutMatch(event, "ArrowUp", {
    altKey: "any",
    shiftKey: "any"
  });
}
function isMoveDown(event) {
  return isExactShortcutMatch(event, "ArrowDown", {
    altKey: "any",
    shiftKey: "any"
  });
}
function isModifier(event) {
  return event.ctrlKey || event.shiftKey || event.altKey || event.metaKey;
}
function isSpace(event) {
  return event.key === " ";
}
function isBackspace(event) {
  return event.key === "Backspace";
}
function isEscape(event) {
  return event.key === "Escape";
}
function isDelete(event) {
  return event.key === "Delete";
}
function isSelectAll(event) {
  return isExactShortcutMatch(event, "a", CONTROL_OR_META);
}
function $selectAll(selection) {
  const root = $getRoot();
  if ($isRangeSelection(selection)) {
    const anchor = selection.anchor;
    const focus = selection.focus;
    const anchorNode = anchor.getNode();
    const topParent = anchorNode.getTopLevelElementOrThrow();
    const rootNode = topParent.getParentOrThrow();
    anchor.set(rootNode.getKey(), 0, "element");
    focus.set(rootNode.getKey(), rootNode.getChildrenSize(), "element");
    $normalizeSelection(selection);
    return selection;
  } else {
    const newSelection = root.select(0, root.getChildrenSize());
    $setSelection($normalizeSelection(newSelection));
    return newSelection;
  }
}
function getCachedClassNameArray(classNamesTheme, classNameThemeType) {
  if (classNamesTheme.__lexicalClassNameCache === void 0) {
    classNamesTheme.__lexicalClassNameCache = {};
  }
  const classNamesCache = classNamesTheme.__lexicalClassNameCache;
  const cachedClassNames = classNamesCache[classNameThemeType];
  if (cachedClassNames !== void 0) {
    return cachedClassNames;
  }
  const classNames = classNamesTheme[classNameThemeType];
  if (typeof classNames === "string") {
    const classNamesArr = normalizeClassNames(classNames);
    classNamesCache[classNameThemeType] = classNamesArr;
    return classNamesArr;
  }
  return classNames;
}
function setMutatedNode(mutatedNodes2, registeredNodes, mutationListeners, node, mutation) {
  if (mutationListeners.size === 0) {
    return;
  }
  const nodeType = node.__type;
  const nodeKey = node.__key;
  const registeredNode = registeredNodes.get(nodeType);
  if (registeredNode === void 0) {
    {
      formatDevErrorMessage(`Type ${nodeType} not in registeredNodes`);
    }
  }
  const klass = registeredNode.klass;
  let mutatedNodesByType = mutatedNodes2.get(klass);
  if (mutatedNodesByType === void 0) {
    mutatedNodesByType = /* @__PURE__ */ new Map();
    mutatedNodes2.set(klass, mutatedNodesByType);
  }
  const prevMutation = mutatedNodesByType.get(nodeKey);
  const isMove = prevMutation === "destroyed" && mutation === "created";
  if (prevMutation === void 0 || isMove) {
    mutatedNodesByType.set(nodeKey, isMove ? "updated" : mutation);
  }
}
function $nodesOfType(klass) {
  const klassType = klass.getType();
  const editorState = getActiveEditorState();
  if (editorState._readOnly) {
    const nodes2 = getCachedTypeToNodeMap(editorState).get(klassType);
    return nodes2 ? Array.from(nodes2.values()) : [];
  }
  const nodes = editorState._nodeMap;
  const nodesOfType = [];
  for (const [, node] of nodes) {
    if (node instanceof klass && node.__type === klassType && node.isAttached()) {
      nodesOfType.push(node);
    }
  }
  return nodesOfType;
}
function resolveElement(element, isBackward, focusOffset) {
  const parent = element.getParent();
  let offset = focusOffset;
  let block = element;
  if (parent !== null) {
    if (isBackward && focusOffset === 0) {
      offset = block.getIndexWithinParent();
      block = parent;
    } else if (!isBackward && focusOffset === block.getChildrenSize()) {
      offset = block.getIndexWithinParent() + 1;
      block = parent;
    }
  }
  return block.getChildAtIndex(isBackward ? offset - 1 : offset);
}
function $getAdjacentNode(focus, isBackward) {
  const focusOffset = focus.offset;
  if (focus.type === "element") {
    const block = focus.getNode();
    return resolveElement(block, isBackward, focusOffset);
  } else {
    const focusNode = focus.getNode();
    if (isBackward && focusOffset === 0 || !isBackward && focusOffset === focusNode.getTextContentSize()) {
      const possibleNode = isBackward ? focusNode.getPreviousSibling() : focusNode.getNextSibling();
      if (possibleNode === null) {
        return resolveElement(focusNode.getParentOrThrow(), isBackward, focusNode.getIndexWithinParent() + (isBackward ? 0 : 1));
      }
      return possibleNode;
    }
  }
  return null;
}
function isFirefoxClipboardEvents(editor) {
  const event = getWindow(editor).event;
  const inputType = event && event.inputType;
  return inputType === "insertFromPaste" || inputType === "insertFromPasteAsQuotation";
}
function dispatchCommand(editor, command, payload) {
  return triggerCommandListeners(editor, command, payload);
}
function $textContentRequiresDoubleLinebreakAtEnd(node) {
  return !$isRootNode(node) && !node.isLastChild() && !node.isInline();
}
function getElementByKeyOrThrow(editor, key) {
  const element = editor._keyToDOMMap.get(key);
  if (element === void 0) {
    {
      formatDevErrorMessage(`Reconciliation: could not find DOM element for node key ${key}`);
    }
  }
  return element;
}
function getParentElement(node) {
  const parentElement = node.assignedSlot || node.parentElement;
  return isDocumentFragment(parentElement) ? parentElement.host : parentElement;
}
function getDOMOwnerDocument(target) {
  return isDOMDocumentNode(target) ? target : isHTMLElement(target) ? target.ownerDocument : null;
}
function scrollIntoViewIfNeeded(editor, selectionRect, rootElement) {
  const doc = getDOMOwnerDocument(rootElement);
  const defaultView = getDefaultView(doc);
  if (doc === null || defaultView === null) {
    return;
  }
  let {
    top: currentTop,
    bottom: currentBottom
  } = selectionRect;
  let targetTop = 0;
  let targetBottom = 0;
  let element = rootElement;
  while (element !== null) {
    const isBodyElement = element === doc.body;
    if (isBodyElement) {
      targetTop = 0;
      targetBottom = getWindow(editor).innerHeight;
    } else {
      const targetRect = element.getBoundingClientRect();
      targetTop = targetRect.top;
      targetBottom = targetRect.bottom;
    }
    let diff = 0;
    if (currentTop < targetTop) {
      diff = -(targetTop - currentTop);
    } else if (currentBottom > targetBottom) {
      diff = currentBottom - targetBottom;
    }
    if (diff !== 0) {
      if (isBodyElement) {
        defaultView.scrollBy(0, diff);
      } else {
        const scrollTop = element.scrollTop;
        element.scrollTop += diff;
        const yOffset = element.scrollTop - scrollTop;
        currentTop -= yOffset;
        currentBottom -= yOffset;
      }
    }
    if (isBodyElement) {
      break;
    }
    element = getParentElement(element);
  }
}
function $hasUpdateTag(tag) {
  const editor = getActiveEditor();
  return editor._updateTags.has(tag);
}
function $addUpdateTag(tag) {
  errorOnReadOnly();
  const editor = getActiveEditor();
  editor._updateTags.add(tag);
}
function $onUpdate(updateFn) {
  errorOnReadOnly();
  const editor = getActiveEditor();
  editor._deferred.push(updateFn);
}
function $maybeMoveChildrenSelectionToParent(parentNode) {
  const selection = $getSelection();
  if (!$isRangeSelection(selection) || !$isElementNode(parentNode)) {
    return selection;
  }
  const {
    anchor,
    focus
  } = selection;
  const anchorNode = anchor.getNode();
  const focusNode = focus.getNode();
  if ($hasAncestor(anchorNode, parentNode)) {
    anchor.set(parentNode.__key, 0, "element");
  }
  if ($hasAncestor(focusNode, parentNode)) {
    focus.set(parentNode.__key, 0, "element");
  }
  return selection;
}
function $hasAncestor(child, targetNode) {
  let parent = child.getParent();
  while (parent !== null) {
    if (parent.is(targetNode)) {
      return true;
    }
    parent = parent.getParent();
  }
  return false;
}
function getDefaultView(domElem) {
  const ownerDoc = getDOMOwnerDocument(domElem);
  return ownerDoc ? ownerDoc.defaultView : null;
}
function getWindow(editor) {
  const windowObj = editor._window;
  if (windowObj === null) {
    {
      formatDevErrorMessage(`window object not found`);
    }
  }
  return windowObj;
}
function $isInlineElementOrDecoratorNode(node) {
  return $isElementNode(node) && node.isInline() || $isDecoratorNode(node) && node.isInline();
}
function $getNearestRootOrShadowRoot(node) {
  let parent = node.getParentOrThrow();
  while (parent !== null) {
    if ($isRootOrShadowRoot(parent)) {
      return parent;
    }
    parent = parent.getParentOrThrow();
  }
  return parent;
}
function $isRootOrShadowRoot(node) {
  return $isRootNode(node) || $isElementNode(node) && node.isShadowRoot();
}
function $copyNode(node) {
  const copy = node.constructor.clone(node);
  $setNodeKey(copy, null);
  copy.afterCloneFrom(node);
  return copy;
}
function $applyNodeReplacement(node) {
  const editor = getActiveEditor();
  const nodeType = node.getType();
  const registeredNode = getRegisteredNode(editor, nodeType);
  if (!(registeredNode !== void 0)) {
    formatDevErrorMessage(`$applyNodeReplacement node ${node.constructor.name} with type ${nodeType} must be registered to the editor. You can do this by passing the node class via the "nodes" array in the editor config.`);
  }
  const {
    replace,
    replaceWithKlass
  } = registeredNode;
  if (replace !== null) {
    const replacementNode = replace(node);
    const replacementNodeKlass = replacementNode.constructor;
    if (replaceWithKlass !== null) {
      if (!(replacementNode instanceof replaceWithKlass)) {
        formatDevErrorMessage(`$applyNodeReplacement failed. Expected replacement node to be an instance of ${replaceWithKlass.name} with type ${replaceWithKlass.getType()} but returned ${replacementNodeKlass.name} with type ${replacementNodeKlass.getType()} from original node ${node.constructor.name} with type ${nodeType}`);
      }
    } else {
      if (!(replacementNode instanceof node.constructor && replacementNodeKlass !== node.constructor)) {
        formatDevErrorMessage(`$applyNodeReplacement failed. Ensure replacement node ${replacementNodeKlass.name} with type ${replacementNodeKlass.getType()} is a subclass of the original node ${node.constructor.name} with type ${nodeType}.`);
      }
    }
    if (!(replacementNode.__key !== node.__key)) {
      formatDevErrorMessage(`$applyNodeReplacement failed. Ensure that the key argument is *not* used in your replace function (from node ${node.constructor.name} with type ${nodeType} to node ${replacementNodeKlass.name} with type ${replacementNodeKlass.getType()}), Node keys must never be re-used except by the static clone method.`);
    }
    return replacementNode;
  }
  return node;
}
function errorOnInsertTextNodeOnRoot(node, insertNode) {
  const parentNode = node.getParent();
  if ($isRootNode(parentNode) && !$isElementNode(insertNode) && !$isDecoratorNode(insertNode)) {
    {
      formatDevErrorMessage(`Only element or decorator nodes can be inserted in to the root node`);
    }
  }
}
function $getNodeByKeyOrThrow(key) {
  const node = $getNodeByKey(key);
  if (node === null) {
    {
      formatDevErrorMessage(`Expected node with key ${key} to exist but it's not in the nodeMap.`);
    }
  }
  return node;
}
function createBlockCursorElement(editorConfig) {
  const theme2 = editorConfig.theme;
  const element = document.createElement("div");
  element.contentEditable = "false";
  element.setAttribute("data-lexical-cursor", "true");
  let blockCursorTheme = theme2.blockCursor;
  if (blockCursorTheme !== void 0) {
    if (typeof blockCursorTheme === "string") {
      const classNamesArr = normalizeClassNames(blockCursorTheme);
      blockCursorTheme = theme2.blockCursor = classNamesArr;
    }
    if (blockCursorTheme !== void 0) {
      element.classList.add(...blockCursorTheme);
    }
  }
  return element;
}
function needsBlockCursor(node) {
  return ($isDecoratorNode(node) || $isElementNode(node) && !node.canBeEmpty()) && !node.isInline();
}
function removeDOMBlockCursorElement(blockCursorElement, editor, rootElement) {
  rootElement.style.removeProperty("caret-color");
  editor._blockCursorElement = null;
  const parentElement = blockCursorElement.parentElement;
  if (parentElement !== null) {
    parentElement.removeChild(blockCursorElement);
  }
}
function updateDOMBlockCursorElement(editor, rootElement, nextSelection) {
  let blockCursorElement = editor._blockCursorElement;
  if ($isRangeSelection(nextSelection) && nextSelection.isCollapsed() && nextSelection.anchor.type === "element" && rootElement.contains(document.activeElement)) {
    const anchor = nextSelection.anchor;
    const elementNode = anchor.getNode();
    const offset = anchor.offset;
    const elementNodeSize = elementNode.getChildrenSize();
    let isBlockCursor = false;
    let insertBeforeElement = null;
    if (offset === elementNodeSize) {
      const child = elementNode.getChildAtIndex(offset - 1);
      if (needsBlockCursor(child)) {
        isBlockCursor = true;
      }
    } else {
      const child = elementNode.getChildAtIndex(offset);
      if (child !== null && needsBlockCursor(child)) {
        const sibling = child.getPreviousSibling();
        if (sibling === null || needsBlockCursor(sibling)) {
          isBlockCursor = true;
          insertBeforeElement = editor.getElementByKey(child.__key);
        }
      }
    }
    if (isBlockCursor) {
      const elementDOM = editor.getElementByKey(elementNode.__key);
      if (blockCursorElement === null) {
        editor._blockCursorElement = blockCursorElement = createBlockCursorElement(editor._config);
      }
      rootElement.style.caretColor = "transparent";
      if (insertBeforeElement === null) {
        elementDOM.appendChild(blockCursorElement);
      } else {
        elementDOM.insertBefore(blockCursorElement, insertBeforeElement);
      }
      return;
    }
  }
  if (blockCursorElement !== null) {
    removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);
  }
}
function getDOMSelection(targetWindow) {
  return !CAN_USE_DOM ? null : (targetWindow || window).getSelection();
}
function getDOMSelectionFromTarget(eventTarget) {
  const defaultView = getDefaultView(eventTarget);
  return defaultView ? defaultView.getSelection() : null;
}
function $splitNode(node, offset) {
  let startNode = node.getChildAtIndex(offset);
  if (startNode == null) {
    startNode = node;
  }
  if (!!$isRootOrShadowRoot(node)) {
    formatDevErrorMessage(`Can not call $splitNode() on root element`);
  }
  const recurse = (currentNode) => {
    const parent = currentNode.getParentOrThrow();
    const isParentRoot = $isRootOrShadowRoot(parent);
    const nodeToMove = currentNode === startNode && !isParentRoot ? currentNode : $copyNode(currentNode);
    if (isParentRoot) {
      if (!($isElementNode(currentNode) && $isElementNode(nodeToMove))) {
        formatDevErrorMessage(`Children of a root must be ElementNode`);
      }
      currentNode.insertAfter(nodeToMove);
      return [currentNode, nodeToMove, nodeToMove];
    } else {
      const [leftTree2, rightTree2, newParent] = recurse(parent);
      const nextSiblings = currentNode.getNextSiblings();
      newParent.append(nodeToMove, ...nextSiblings);
      return [leftTree2, rightTree2, nodeToMove];
    }
  };
  const [leftTree, rightTree] = recurse(startNode);
  return [leftTree, rightTree];
}
function isHTMLAnchorElement(x) {
  return isHTMLElement(x) && x.tagName === "A";
}
function isHTMLElement(x) {
  return isDOMNode(x) && x.nodeType === DOM_ELEMENT_TYPE;
}
function isDOMNode(x) {
  return typeof x === "object" && x !== null && "nodeType" in x && typeof x.nodeType === "number";
}
function isDocumentFragment(x) {
  return isDOMNode(x) && x.nodeType === DOM_DOCUMENT_FRAGMENT_TYPE;
}
function isInlineDomNode(node) {
  const inlineNodes = new RegExp(/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|mark|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var|#text)$/, "i");
  return node.nodeName.match(inlineNodes) !== null;
}
function isBlockDomNode(node) {
  const blockNodes = new RegExp(/^(address|article|aside|blockquote|canvas|dd|div|dl|dt|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5|h6|header|hr|li|main|nav|noscript|ol|p|pre|section|table|td|tfoot|ul|video)$/, "i");
  return node.nodeName.match(blockNodes) !== null;
}
function INTERNAL_$isBlock(node) {
  if ($isDecoratorNode(node) && !node.isInline()) {
    return true;
  }
  if (!$isElementNode(node) || $isRootOrShadowRoot(node)) {
    return false;
  }
  const firstChild = node.getFirstChild();
  const isLeafElement = firstChild === null || $isLineBreakNode(firstChild) || $isTextNode(firstChild) || firstChild.isInline();
  return !node.isInline() && node.canBeEmpty() !== false && isLeafElement;
}
function $getEditor() {
  return getActiveEditor();
}
var cachedNodeMaps = /* @__PURE__ */ new WeakMap();
var EMPTY_TYPE_TO_NODE_MAP = /* @__PURE__ */ new Map();
function getCachedTypeToNodeMap(editorState) {
  if (!editorState._readOnly && editorState.isEmpty()) {
    return EMPTY_TYPE_TO_NODE_MAP;
  }
  if (!editorState._readOnly) {
    formatDevErrorMessage(`getCachedTypeToNodeMap called with a writable EditorState`);
  }
  let typeToNodeMap = cachedNodeMaps.get(editorState);
  if (!typeToNodeMap) {
    typeToNodeMap = computeTypeToNodeMap(editorState);
    cachedNodeMaps.set(editorState, typeToNodeMap);
  }
  return typeToNodeMap;
}
function computeTypeToNodeMap(editorState) {
  const typeToNodeMap = /* @__PURE__ */ new Map();
  for (const [nodeKey, node] of editorState._nodeMap) {
    const nodeType = node.__type;
    let nodeMap = typeToNodeMap.get(nodeType);
    if (!nodeMap) {
      nodeMap = /* @__PURE__ */ new Map();
      typeToNodeMap.set(nodeType, nodeMap);
    }
    nodeMap.set(nodeKey, node);
  }
  return typeToNodeMap;
}
function $cloneWithProperties(latestNode) {
  const constructor = latestNode.constructor;
  const mutableNode = constructor.clone(latestNode);
  mutableNode.afterCloneFrom(latestNode);
  {
    if (!(mutableNode.__key === latestNode.__key)) {
      formatDevErrorMessage(`$cloneWithProperties: ${constructor.name}.clone(node) (with type '${constructor.getType()}') did not return a node with the same key, make sure to specify node.__key as the last argument to the constructor`);
    }
    if (!(mutableNode.__parent === latestNode.__parent && mutableNode.__next === latestNode.__next && mutableNode.__prev === latestNode.__prev)) {
      formatDevErrorMessage(`$cloneWithProperties: ${constructor.name}.clone(node) (with type '${constructor.getType()}') overrode afterCloneFrom but did not call super.afterCloneFrom(prevNode)`);
    }
  }
  return mutableNode;
}
function $cloneWithPropertiesEphemeral(latestNode) {
  return $markEphemeral($cloneWithProperties(latestNode));
}
function setNodeIndentFromDOM(elementDom, elementNode) {
  const indentSize = parseInt(elementDom.style.paddingInlineStart, 10) || 0;
  const indent = Math.round(indentSize / 40);
  elementNode.setIndent(indent);
}
function setDOMUnmanaged(elementDom) {
  const el = elementDom;
  el.__lexicalUnmanaged = true;
}
function isDOMUnmanaged(elementDom) {
  const el = elementDom;
  return el.__lexicalUnmanaged === true;
}
function hasOwn(o2, k) {
  return Object.prototype.hasOwnProperty.call(o2, k);
}
function hasOwnStaticMethod(klass, k) {
  return hasOwn(klass, k) && klass[k] !== LexicalNode[k];
}
function hasOwnExportDOM(klass) {
  return hasOwn(klass.prototype, "exportDOM");
}
function isAbstractNodeClass(klass) {
  if (!(klass === LexicalNode || klass.prototype instanceof LexicalNode)) {
    let ownNodeType = "<unknown>";
    let version = "<unknown>";
    try {
      ownNodeType = klass.getType();
    } catch (_err) {
    }
    try {
      if (LexicalEditor.version) {
        version = JSON.parse(LexicalEditor.version);
      }
    } catch (_err) {
    }
    {
      formatDevErrorMessage(`${klass.name} (type ${ownNodeType}) does not subclass LexicalNode from the lexical package used by this editor (version ${version}). All lexical and @lexical/* packages used by an editor must have identical versions. If you suspect the version does match, then the problem may be caused by multiple copies of the same lexical module (e.g. both esm and cjs, or included directly in multiple entrypoints).`);
    }
  }
  return klass === DecoratorNode || klass === ElementNode || klass === LexicalNode;
}
function getStaticNodeConfig(klass) {
  const nodeConfigRecord = PROTOTYPE_CONFIG_METHOD in klass.prototype ? klass.prototype[PROTOTYPE_CONFIG_METHOD]() : void 0;
  const isAbstract = isAbstractNodeClass(klass);
  const nodeType = !isAbstract && hasOwnStaticMethod(klass, "getType") ? klass.getType() : void 0;
  let ownNodeConfig;
  let ownNodeType = nodeType;
  if (nodeConfigRecord) {
    if (nodeType) {
      ownNodeConfig = nodeConfigRecord[nodeType];
    } else {
      for (const [k, v2] of Object.entries(nodeConfigRecord)) {
        ownNodeType = k;
        ownNodeConfig = v2;
      }
    }
  }
  if (!isAbstract && ownNodeType) {
    if (!hasOwnStaticMethod(klass, "getType")) {
      klass.getType = () => ownNodeType;
    }
    if (!hasOwnStaticMethod(klass, "clone")) {
      if (TextNode.length === 0) {
        if (!(klass.length === 0)) {
          formatDevErrorMessage(`${klass.name} (type ${ownNodeType}) must implement a static clone method since its constructor has ${String(klass.length)} required arguments (expecting 0). Use an explicit default in the first argument of your constructor(prop: T=X, nodeKey?: NodeKey).`);
        }
      }
      klass.clone = (prevNode) => {
        setPendingNodeToClone(prevNode);
        return new klass();
      };
    }
    if (!hasOwnStaticMethod(klass, "importJSON")) {
      if (TextNode.length === 0) {
        if (!(klass.length === 0)) {
          formatDevErrorMessage(`${klass.name} (type ${ownNodeType}) must implement a static importJSON method since its constructor has ${String(klass.length)} required arguments (expecting 0). Use an explicit default in the first argument of your constructor(prop: T=X, nodeKey?: NodeKey).`);
        }
      }
      klass.importJSON = ownNodeConfig && ownNodeConfig.$importJSON || ((serializedNode) => new klass().updateFromJSON(serializedNode));
    }
    if (!hasOwnStaticMethod(klass, "importDOM") && ownNodeConfig) {
      const {
        importDOM
      } = ownNodeConfig;
      if (importDOM) {
        klass.importDOM = () => importDOM;
      }
    }
  }
  return {
    ownNodeConfig,
    ownNodeType
  };
}
function $create(klass) {
  const editor = $getEditor();
  errorOnReadOnly();
  const registeredNode = editor.resolveRegisteredNodeAfterReplacements(editor.getRegisteredNode(klass));
  return new registeredNode.klass();
}
var $findMatchingParent = (startingNode, findFn) => {
  let curr = startingNode;
  while (curr != null && !$isRootNode(curr)) {
    if (findFn(curr)) {
      return curr;
    }
    curr = curr.getParent();
  }
  return null;
};
var FLIP_DIRECTION = {
  next: "previous",
  previous: "next"
};
var AbstractCaret = class {
  constructor(origin) {
    __publicField(this, "origin");
    this.origin = origin;
  }
  [Symbol.iterator]() {
    return makeStepwiseIterator({
      hasNext: $isSiblingCaret,
      initial: this.getAdjacentCaret(),
      map: (caret) => caret,
      step: (caret) => caret.getAdjacentCaret()
    });
  }
  getAdjacentCaret() {
    return $getSiblingCaret(this.getNodeAtCaret(), this.direction);
  }
  getSiblingCaret() {
    return $getSiblingCaret(this.origin, this.direction);
  }
  remove() {
    const node = this.getNodeAtCaret();
    if (node) {
      node.remove();
    }
    return this;
  }
  replaceOrInsert(node, includeChildren) {
    const target = this.getNodeAtCaret();
    if (node.is(this.origin) || node.is(target)) ;
    else if (target === null) {
      this.insert(node);
    } else {
      target.replace(node, includeChildren);
    }
    return this;
  }
  splice(deleteCount, nodes, nodesDirection = "next") {
    const nodeIter = nodesDirection === this.direction ? nodes : Array.from(nodes).reverse();
    let caret = this;
    const parent = this.getParentAtCaret();
    const nodesToRemove = /* @__PURE__ */ new Map();
    for (let removeCaret = caret.getAdjacentCaret(); removeCaret !== null && nodesToRemove.size < deleteCount; removeCaret = removeCaret.getAdjacentCaret()) {
      const writableNode = removeCaret.origin.getWritable();
      nodesToRemove.set(writableNode.getKey(), writableNode);
    }
    for (const node of nodeIter) {
      if (nodesToRemove.size > 0) {
        const target = caret.getNodeAtCaret();
        if (target) {
          nodesToRemove.delete(target.getKey());
          nodesToRemove.delete(node.getKey());
          if (target.is(node) || caret.origin.is(node)) ;
          else {
            const nodeParent = node.getParent();
            if (nodeParent && nodeParent.is(parent)) {
              node.remove();
            }
            target.replace(node);
          }
        } else {
          if (!(target !== null)) {
            formatDevErrorMessage(`NodeCaret.splice: Underflow of expected nodesToRemove during splice (keys: ${Array.from(nodesToRemove).join(" ")})`);
          }
        }
      } else {
        caret.insert(node);
      }
      caret = $getSiblingCaret(node, this.direction);
    }
    for (const node of nodesToRemove.values()) {
      node.remove();
    }
    return this;
  }
};
var AbstractChildCaret = class _AbstractChildCaret extends AbstractCaret {
  constructor() {
    super(...arguments);
    __publicField(this, "type", "child");
  }
  getLatest() {
    const origin = this.origin.getLatest();
    return origin === this.origin ? this : $getChildCaret(origin, this.direction);
  }
  /**
   * Get the SiblingCaret from this origin in the same direction.
   *
   * @param mode 'root' to return null at the root, 'shadowRoot' to return null at the root or any shadow root
   * @returns A SiblingCaret with this origin, or null if origin is a root according to mode.
   */
  getParentCaret(mode = "root") {
    return $getSiblingCaret($filterByMode(this.getParentAtCaret(), mode), this.direction);
  }
  getFlipped() {
    const dir = flipDirection(this.direction);
    return $getSiblingCaret(this.getNodeAtCaret(), dir) || $getChildCaret(this.origin, dir);
  }
  getParentAtCaret() {
    return this.origin;
  }
  getChildCaret() {
    return this;
  }
  isSameNodeCaret(other) {
    return other instanceof _AbstractChildCaret && this.direction === other.direction && this.origin.is(other.origin);
  }
  isSamePointCaret(other) {
    return this.isSameNodeCaret(other);
  }
};
var ChildCaretFirst = class extends AbstractChildCaret {
  constructor() {
    super(...arguments);
    __publicField(this, "direction", "next");
  }
  getNodeAtCaret() {
    return this.origin.getFirstChild();
  }
  insert(node) {
    this.origin.splice(0, 0, [node]);
    return this;
  }
};
var ChildCaretLast = class extends AbstractChildCaret {
  constructor() {
    super(...arguments);
    __publicField(this, "direction", "previous");
  }
  getNodeAtCaret() {
    return this.origin.getLastChild();
  }
  insert(node) {
    this.origin.splice(this.origin.getChildrenSize(), 0, [node]);
    return this;
  }
};
var MODE_PREDICATE = {
  root: $isRootNode,
  shadowRoot: $isRootOrShadowRoot
};
function flipDirection(direction) {
  return FLIP_DIRECTION[direction];
}
function $filterByMode(node, mode = "root") {
  return MODE_PREDICATE[mode](node) ? null : node;
}
var AbstractSiblingCaret = class _AbstractSiblingCaret extends AbstractCaret {
  constructor() {
    super(...arguments);
    __publicField(this, "type", "sibling");
  }
  getLatest() {
    const origin = this.origin.getLatest();
    return origin === this.origin ? this : $getSiblingCaret(origin, this.direction);
  }
  getSiblingCaret() {
    return this;
  }
  getParentAtCaret() {
    return this.origin.getParent();
  }
  getChildCaret() {
    return $isElementNode(this.origin) ? $getChildCaret(this.origin, this.direction) : null;
  }
  getParentCaret(mode = "root") {
    return $getSiblingCaret($filterByMode(this.getParentAtCaret(), mode), this.direction);
  }
  getFlipped() {
    const dir = flipDirection(this.direction);
    return $getSiblingCaret(this.getNodeAtCaret(), dir) || $getChildCaret(this.origin.getParentOrThrow(), dir);
  }
  isSamePointCaret(other) {
    return other instanceof _AbstractSiblingCaret && this.direction === other.direction && this.origin.is(other.origin);
  }
  isSameNodeCaret(other) {
    return (other instanceof _AbstractSiblingCaret || other instanceof AbstractTextPointCaret) && this.direction === other.direction && this.origin.is(other.origin);
  }
};
var AbstractTextPointCaret = class _AbstractTextPointCaret extends AbstractCaret {
  constructor(origin, offset) {
    super(origin);
    __publicField(this, "type", "text");
    __publicField(this, "offset");
    this.offset = offset;
  }
  getLatest() {
    const origin = this.origin.getLatest();
    return origin === this.origin ? this : $getTextPointCaret(origin, this.direction, this.offset);
  }
  getParentAtCaret() {
    return this.origin.getParent();
  }
  getChildCaret() {
    return null;
  }
  getParentCaret(mode = "root") {
    return $getSiblingCaret($filterByMode(this.getParentAtCaret(), mode), this.direction);
  }
  getFlipped() {
    return $getTextPointCaret(this.origin, flipDirection(this.direction), this.offset);
  }
  isSamePointCaret(other) {
    return other instanceof _AbstractTextPointCaret && this.direction === other.direction && this.origin.is(other.origin) && this.offset === other.offset;
  }
  isSameNodeCaret(other) {
    return (other instanceof AbstractSiblingCaret || other instanceof _AbstractTextPointCaret) && this.direction === other.direction && this.origin.is(other.origin);
  }
  getSiblingCaret() {
    return $getSiblingCaret(this.origin, this.direction);
  }
};
function $isTextPointCaret(caret) {
  return caret instanceof AbstractTextPointCaret;
}
function $isNodeCaret(caret) {
  return caret instanceof AbstractCaret;
}
function $isSiblingCaret(caret) {
  return caret instanceof AbstractSiblingCaret;
}
function $isChildCaret(caret) {
  return caret instanceof AbstractChildCaret;
}
var SiblingCaretNext = class extends AbstractSiblingCaret {
  constructor() {
    super(...arguments);
    __publicField(this, "direction", "next");
  }
  getNodeAtCaret() {
    return this.origin.getNextSibling();
  }
  insert(node) {
    this.origin.insertAfter(node);
    return this;
  }
};
var SiblingCaretPrevious = class extends AbstractSiblingCaret {
  constructor() {
    super(...arguments);
    __publicField(this, "direction", "previous");
  }
  getNodeAtCaret() {
    return this.origin.getPreviousSibling();
  }
  insert(node) {
    this.origin.insertBefore(node);
    return this;
  }
};
var TextPointCaretNext = class extends AbstractTextPointCaret {
  constructor() {
    super(...arguments);
    __publicField(this, "direction", "next");
  }
  getNodeAtCaret() {
    return this.origin.getNextSibling();
  }
  insert(node) {
    this.origin.insertAfter(node);
    return this;
  }
};
var TextPointCaretPrevious = class extends AbstractTextPointCaret {
  constructor() {
    super(...arguments);
    __publicField(this, "direction", "previous");
  }
  getNodeAtCaret() {
    return this.origin.getPreviousSibling();
  }
  insert(node) {
    this.origin.insertBefore(node);
    return this;
  }
};
var TEXT_CTOR = {
  next: TextPointCaretNext,
  previous: TextPointCaretPrevious
};
var SIBLING_CTOR = {
  next: SiblingCaretNext,
  previous: SiblingCaretPrevious
};
var CHILD_CTOR = {
  next: ChildCaretFirst,
  previous: ChildCaretLast
};
function $getSiblingCaret(origin, direction) {
  return origin ? new SIBLING_CTOR[direction](origin) : null;
}
function $getTextPointCaret(origin, direction, offset) {
  return origin ? new TEXT_CTOR[direction](origin, $getTextNodeOffset(origin, offset)) : null;
}
function $getTextNodeOffset(origin, offset, mode = "error") {
  const size = origin.getTextContentSize();
  let numericOffset = offset === "next" ? size : offset === "previous" ? 0 : offset;
  if (numericOffset < 0 || numericOffset > size) {
    if (!(mode === "clamp")) {
      formatDevErrorMessage(`$getTextNodeOffset: invalid offset ${String(offset)} for size ${String(size)} at key ${origin.getKey()}`);
    }
    numericOffset = numericOffset < 0 ? 0 : size;
  }
  return numericOffset;
}
function $getTextPointCaretSlice(caret, distance) {
  return new TextPointCaretSliceImpl(caret, distance);
}
function $getChildCaret(origin, direction) {
  return $isElementNode(origin) ? new CHILD_CTOR[direction](origin) : null;
}
function $getChildCaretOrSelf(caret) {
  return caret && caret.getChildCaret() || caret;
}
function $getAdjacentChildCaret(caret) {
  return caret && $getChildCaretOrSelf(caret.getAdjacentCaret());
}
var CaretRangeImpl = class _CaretRangeImpl {
  constructor(anchor, focus, direction) {
    __publicField(this, "type", "node-caret-range");
    __publicField(this, "direction");
    __publicField(this, "anchor");
    __publicField(this, "focus");
    this.anchor = anchor;
    this.focus = focus;
    this.direction = direction;
  }
  getLatest() {
    const anchor = this.anchor.getLatest();
    const focus = this.focus.getLatest();
    return anchor === this.anchor && focus === this.focus ? this : new _CaretRangeImpl(anchor, focus, this.direction);
  }
  isCollapsed() {
    return this.anchor.isSamePointCaret(this.focus);
  }
  getTextSlices() {
    const getSlice = (k) => {
      const caret = this[k].getLatest();
      return $isTextPointCaret(caret) ? $getSliceFromTextPointCaret(caret, k) : null;
    };
    const anchorSlice = getSlice("anchor");
    const focusSlice = getSlice("focus");
    if (anchorSlice && focusSlice) {
      const {
        caret: anchorCaret
      } = anchorSlice;
      const {
        caret: focusCaret
      } = focusSlice;
      if (anchorCaret.isSameNodeCaret(focusCaret)) {
        return [$getTextPointCaretSlice(anchorCaret, focusCaret.offset - anchorCaret.offset), null];
      }
    }
    return [anchorSlice, focusSlice];
  }
  iterNodeCarets(rootMode = "root") {
    const anchor = $isTextPointCaret(this.anchor) ? this.anchor.getSiblingCaret() : this.anchor.getLatest();
    const focus = this.focus.getLatest();
    const isTextFocus = $isTextPointCaret(focus);
    const step = (state) => state.isSameNodeCaret(focus) ? null : $getAdjacentChildCaret(state) || state.getParentCaret(rootMode);
    return makeStepwiseIterator({
      hasNext: (state) => state !== null && !(isTextFocus && focus.isSameNodeCaret(state)),
      initial: anchor.isSameNodeCaret(focus) ? null : step(anchor),
      map: (state) => state,
      step
    });
  }
  [Symbol.iterator]() {
    return this.iterNodeCarets("root");
  }
};
var TextPointCaretSliceImpl = class {
  constructor(caret, distance) {
    __publicField(this, "type", "slice");
    __publicField(this, "caret");
    __publicField(this, "distance");
    this.caret = caret;
    this.distance = distance;
  }
  getSliceIndices() {
    const {
      distance,
      caret: {
        offset
      }
    } = this;
    const offsetB = offset + distance;
    return offsetB < offset ? [offsetB, offset] : [offset, offsetB];
  }
  getTextContent() {
    const [startIndex, endIndex] = this.getSliceIndices();
    return this.caret.origin.getTextContent().slice(startIndex, endIndex);
  }
  getTextContentSize() {
    return Math.abs(this.distance);
  }
  removeTextSlice() {
    const {
      caret: {
        origin,
        direction
      }
    } = this;
    const [indexStart, indexEnd] = this.getSliceIndices();
    const text = origin.getTextContent();
    return $getTextPointCaret(origin.setTextContent(text.slice(0, indexStart) + text.slice(indexEnd)), direction, indexStart);
  }
};
function $getSliceFromTextPointCaret(caret, anchorOrFocus) {
  const {
    direction,
    origin
  } = caret;
  const offsetB = $getTextNodeOffset(origin, anchorOrFocus === "focus" ? flipDirection(direction) : direction);
  return $getTextPointCaretSlice(caret, offsetB - caret.offset);
}
function $isTextPointCaretSlice(caretOrSlice) {
  return caretOrSlice instanceof TextPointCaretSliceImpl;
}
function $extendCaretToRange(anchor) {
  return $getCaretRange(anchor, $getSiblingCaret($getRoot(), anchor.direction));
}
function $getCollapsedCaretRange(anchor) {
  return $getCaretRange(anchor, anchor);
}
function $getCaretRange(anchor, focus) {
  if (!(anchor.direction === focus.direction)) {
    formatDevErrorMessage(`$getCaretRange: anchor and focus must be in the same direction`);
  }
  return new CaretRangeImpl(anchor, focus, anchor.direction);
}
function makeStepwiseIterator(config) {
  const {
    initial,
    hasNext,
    step,
    map
  } = config;
  let state = initial;
  return {
    [Symbol.iterator]() {
      return this;
    },
    next() {
      if (!hasNext(state)) {
        return {
          done: true,
          value: void 0
        };
      }
      const rval = {
        done: false,
        value: map(state)
      };
      state = step(state);
      return rval;
    }
  };
}
function compareNumber(a2, b2) {
  return Math.sign(a2 - b2);
}
function $comparePointCaretNext(a2, b2) {
  const compare = $getCommonAncestor(a2.origin, b2.origin);
  if (!(compare !== null)) {
    formatDevErrorMessage(`$comparePointCaretNext: a (key ${a2.origin.getKey()}) and b (key ${b2.origin.getKey()}) do not have a common ancestor`);
  }
  switch (compare.type) {
    case "same": {
      const aIsText = a2.type === "text";
      const bIsText = b2.type === "text";
      return aIsText && bIsText ? compareNumber(a2.offset, b2.offset) : a2.type === b2.type ? 0 : aIsText ? -1 : bIsText ? 1 : a2.type === "child" ? -1 : 1;
    }
    case "ancestor": {
      return a2.type === "child" ? -1 : 1;
    }
    case "descendant": {
      return b2.type === "child" ? 1 : -1;
    }
    case "branch": {
      return $getCommonAncestorResultBranchOrder(compare);
    }
  }
}
function $getCommonAncestorResultBranchOrder(compare) {
  const {
    a: a2,
    b: b2
  } = compare;
  const aKey = a2.__key;
  const bKey = b2.__key;
  let na = a2;
  let nb = b2;
  for (; na && nb; na = na.getNextSibling(), nb = nb.getNextSibling()) {
    if (na.__key === bKey) {
      return -1;
    } else if (nb.__key === aKey) {
      return 1;
    }
  }
  return na === null ? 1 : -1;
}
function $isSameNode(reference, other) {
  return other.is(reference);
}
function $initialElementTuple(node) {
  return $isElementNode(node) ? [node.getLatest(), null] : [node.getParent(), node.getLatest()];
}
function $getCommonAncestor(a2, b2) {
  if (a2.is(b2)) {
    return {
      commonAncestor: a2,
      type: "same"
    };
  }
  const aMap = /* @__PURE__ */ new Map();
  for (let [parent, child] = $initialElementTuple(a2); parent; child = parent, parent = parent.getParent()) {
    aMap.set(parent, child);
  }
  for (let [parent, child] = $initialElementTuple(b2); parent; child = parent, parent = parent.getParent()) {
    const aChild = aMap.get(parent);
    if (aChild === void 0) ;
    else if (aChild === null) {
      if (!$isSameNode(a2, parent)) {
        formatDevErrorMessage(`$originComparison: ancestor logic error`);
      }
      return {
        commonAncestor: parent,
        type: "ancestor"
      };
    } else if (child === null) {
      if (!$isSameNode(b2, parent)) {
        formatDevErrorMessage(`$originComparison: descendant logic error`);
      }
      return {
        commonAncestor: parent,
        type: "descendant"
      };
    } else {
      if (!(($isElementNode(aChild) || $isSameNode(a2, aChild)) && ($isElementNode(child) || $isSameNode(b2, child)) && parent.is(aChild.getParent()) && parent.is(child.getParent()))) {
        formatDevErrorMessage(`$originComparison: branch logic error`);
      }
      return {
        a: aChild,
        b: child,
        commonAncestor: parent,
        type: "branch"
      };
    }
  }
  return null;
}
function $caretFromPoint(point, direction) {
  const {
    type,
    key,
    offset
  } = point;
  const node = $getNodeByKeyOrThrow(point.key);
  if (type === "text") {
    if (!$isTextNode(node)) {
      formatDevErrorMessage(`$caretFromPoint: Node with type ${node.getType()} and key ${key} that does not inherit from TextNode encountered for text point`);
    }
    return $getTextPointCaret(node, direction, offset);
  }
  if (!$isElementNode(node)) {
    formatDevErrorMessage(`$caretFromPoint: Node with type ${node.getType()} and key ${key} that does not inherit from ElementNode encountered for element point`);
  }
  return $getChildCaretAtIndex(node, point.offset, direction);
}
function $setPointFromCaret(point, caret) {
  const {
    origin,
    direction
  } = caret;
  const isNext = direction === "next";
  if ($isTextPointCaret(caret)) {
    point.set(origin.getKey(), caret.offset, "text");
  } else if ($isSiblingCaret(caret)) {
    if ($isTextNode(origin)) {
      point.set(origin.getKey(), $getTextNodeOffset(origin, direction), "text");
    } else {
      point.set(origin.getParentOrThrow().getKey(), origin.getIndexWithinParent() + (isNext ? 1 : 0), "element");
    }
  } else {
    if (!($isChildCaret(caret) && $isElementNode(origin))) {
      formatDevErrorMessage(`$setPointFromCaret: exhaustiveness check`);
    }
    point.set(origin.getKey(), isNext ? 0 : origin.getChildrenSize(), "element");
  }
}
function $setSelectionFromCaretRange(caretRange) {
  const currentSelection = $getSelection();
  const selection = $isRangeSelection(currentSelection) ? currentSelection : $createRangeSelection();
  $updateRangeSelectionFromCaretRange(selection, caretRange);
  $setSelection(selection);
  return selection;
}
function $updateRangeSelectionFromCaretRange(selection, caretRange) {
  $setPointFromCaret(selection.anchor, caretRange.anchor);
  $setPointFromCaret(selection.focus, caretRange.focus);
}
function $caretRangeFromSelection(selection) {
  const {
    anchor,
    focus
  } = selection;
  const anchorCaret = $caretFromPoint(anchor, "next");
  const focusCaret = $caretFromPoint(focus, "next");
  const direction = $comparePointCaretNext(anchorCaret, focusCaret) <= 0 ? "next" : "previous";
  return $getCaretRange($getCaretInDirection(anchorCaret, direction), $getCaretInDirection(focusCaret, direction));
}
function $rewindSiblingCaret(caret) {
  const {
    direction,
    origin
  } = caret;
  const rewindOrigin = $getSiblingCaret(origin, flipDirection(direction)).getNodeAtCaret();
  return rewindOrigin ? $getSiblingCaret(rewindOrigin, direction) : $getChildCaret(origin.getParentOrThrow(), direction);
}
function $getAnchorCandidates(anchor, rootMode = "root") {
  const carets = [anchor];
  for (let parent = $isChildCaret(anchor) ? anchor.getParentCaret(rootMode) : anchor.getSiblingCaret(); parent !== null; parent = parent.getParentCaret(rootMode)) {
    carets.push($rewindSiblingCaret(parent));
  }
  return carets;
}
function $isCaretAttached(caret) {
  return !!caret && caret.origin.isAttached();
}
function $removeTextFromCaretRange(initialRange, sliceMode = "removeEmptySlices") {
  if (initialRange.isCollapsed()) {
    return initialRange;
  }
  const rootMode = "root";
  const nextDirection = "next";
  let sliceState = sliceMode;
  const range = $getCaretRangeInDirection(initialRange, nextDirection);
  const anchorCandidates = $getAnchorCandidates(range.anchor, rootMode);
  const focusCandidates = $getAnchorCandidates(range.focus.getFlipped(), rootMode);
  const seenStart = /* @__PURE__ */ new Set();
  const removedNodes = [];
  for (const caret of range.iterNodeCarets(rootMode)) {
    if ($isChildCaret(caret)) {
      seenStart.add(caret.origin.getKey());
    } else if ($isSiblingCaret(caret)) {
      const {
        origin
      } = caret;
      if (!$isElementNode(origin) || seenStart.has(origin.getKey())) {
        removedNodes.push(origin);
      }
    }
  }
  for (const node of removedNodes) {
    node.remove();
  }
  for (const slice of range.getTextSlices()) {
    if (!slice) {
      continue;
    }
    const {
      origin
    } = slice.caret;
    const contentSize = origin.getTextContentSize();
    const caretBefore = $rewindSiblingCaret($getSiblingCaret(origin, nextDirection));
    const mode = origin.getMode();
    if (Math.abs(slice.distance) === contentSize && sliceState === "removeEmptySlices" || mode === "token" && slice.distance !== 0) {
      caretBefore.remove();
    } else if (slice.distance !== 0) {
      sliceState = "removeEmptySlices";
      let nextCaret = slice.removeTextSlice();
      const sliceOrigin = slice.caret.origin;
      if (mode === "segmented") {
        const src = nextCaret.origin;
        const plainTextNode = $createTextNode(src.getTextContent()).setStyle(src.getStyle()).setFormat(src.getFormat());
        caretBefore.replaceOrInsert(plainTextNode);
        nextCaret = $getTextPointCaret(plainTextNode, nextDirection, nextCaret.offset);
      }
      if (sliceOrigin.is(anchorCandidates[0].origin)) {
        anchorCandidates[0] = nextCaret;
      }
      if (sliceOrigin.is(focusCandidates[0].origin)) {
        focusCandidates[0] = nextCaret.getFlipped();
      }
    }
  }
  let anchorCandidate;
  let focusCandidate;
  for (const candidate of anchorCandidates) {
    if ($isCaretAttached(candidate)) {
      anchorCandidate = $normalizeCaret(candidate);
      break;
    }
  }
  for (const candidate of focusCandidates) {
    if ($isCaretAttached(candidate)) {
      focusCandidate = $normalizeCaret(candidate);
      break;
    }
  }
  const mergeTargets = $getBlockMergeTargets(anchorCandidate, focusCandidate, seenStart);
  if (mergeTargets) {
    const [anchorBlock, focusBlock] = mergeTargets;
    $getChildCaret(anchorBlock, "previous").splice(0, focusBlock.getChildren());
    focusBlock.remove();
  }
  const bestCandidate = [anchorCandidate, focusCandidate, ...anchorCandidates, ...focusCandidates].find($isCaretAttached);
  if (bestCandidate) {
    const anchor = $getCaretInDirection($normalizeCaret(bestCandidate), initialRange.direction);
    return $getCollapsedCaretRange(anchor);
  }
  {
    formatDevErrorMessage(`$removeTextFromCaretRange: selection was lost, could not find a new anchor given candidates with keys: ${JSON.stringify(anchorCandidates.map((n2) => n2.origin.__key))}`);
  }
}
function $getBlockMergeTargets(anchor, focus, seenStart) {
  if (!anchor || !focus) {
    return null;
  }
  const anchorParent = anchor.getParentAtCaret();
  const focusParent = focus.getParentAtCaret();
  if (!anchorParent || !focusParent) {
    return null;
  }
  const anchorElements = anchorParent.getParents().reverse();
  anchorElements.push(anchorParent);
  const focusElements = focusParent.getParents().reverse();
  focusElements.push(focusParent);
  const maxLen = Math.min(anchorElements.length, focusElements.length);
  let commonAncestorCount;
  for (commonAncestorCount = 0; commonAncestorCount < maxLen && anchorElements[commonAncestorCount] === focusElements[commonAncestorCount]; commonAncestorCount++) {
  }
  const $getBlock = (arr, predicate) => {
    let block;
    for (let i2 = commonAncestorCount; i2 < arr.length; i2++) {
      const ancestor = arr[i2];
      if ($isRootOrShadowRoot(ancestor)) {
        return;
      } else if (!block && predicate(ancestor)) {
        block = ancestor;
      }
    }
    return block;
  };
  const anchorBlock = $getBlock(anchorElements, INTERNAL_$isBlock);
  const focusBlock = anchorBlock && $getBlock(focusElements, (node) => seenStart.has(node.getKey()) && INTERNAL_$isBlock(node));
  return anchorBlock && focusBlock ? [anchorBlock, focusBlock] : null;
}
function $getDeepestChildOrSelf(initialCaret) {
  let caret = initialCaret;
  while ($isChildCaret(caret)) {
    const adjacent = $getAdjacentChildCaret(caret);
    if (!$isChildCaret(adjacent)) {
      break;
    }
    caret = adjacent;
  }
  return caret;
}
function $normalizeCaret(initialCaret) {
  const caret = $getDeepestChildOrSelf(initialCaret.getLatest());
  const {
    direction
  } = caret;
  if ($isTextNode(caret.origin)) {
    return $isTextPointCaret(caret) ? caret : $getTextPointCaret(caret.origin, direction, direction);
  }
  const adj = caret.getAdjacentCaret();
  return $isSiblingCaret(adj) && $isTextNode(adj.origin) ? $getTextPointCaret(adj.origin, direction, flipDirection(direction)) : caret;
}
function $isExtendableTextPointCaret(caret) {
  return $isTextPointCaret(caret) && caret.offset !== $getTextNodeOffset(caret.origin, caret.direction);
}
function $getCaretInDirection(caret, direction) {
  return caret.direction === direction ? caret : caret.getFlipped();
}
function $getCaretRangeInDirection(range, direction) {
  if (range.direction === direction) {
    return range;
  }
  return $getCaretRange(
    // focus and anchor get flipped here
    $getCaretInDirection(range.focus, direction),
    $getCaretInDirection(range.anchor, direction)
  );
}
function $getChildCaretAtIndex(parent, index, direction) {
  let caret = $getChildCaret(parent, "next");
  for (let i2 = 0; i2 < index; i2++) {
    const nextCaret = caret.getAdjacentCaret();
    if (nextCaret === null) {
      break;
    }
    caret = nextCaret;
  }
  return $getCaretInDirection(caret, direction);
}
function $getAdjacentSiblingOrParentSiblingCaret(startCaret, rootMode = "root") {
  let depthDiff = 0;
  let caret = startCaret;
  let nextCaret = $getAdjacentChildCaret(caret);
  while (nextCaret === null) {
    depthDiff--;
    nextCaret = caret.getParentCaret(rootMode);
    if (!nextCaret) {
      return null;
    }
    caret = nextCaret;
    nextCaret = $getAdjacentChildCaret(caret);
  }
  return nextCaret && [nextCaret, depthDiff];
}
function $getAdjacentNodes(initialCaret) {
  const siblings = [];
  for (let caret = initialCaret.getAdjacentCaret(); caret; caret = caret.getAdjacentCaret()) {
    siblings.push(caret.origin);
  }
  return siblings;
}
function $splitTextPointCaret(textPointCaret) {
  const {
    origin,
    offset,
    direction
  } = textPointCaret;
  if (offset === $getTextNodeOffset(origin, direction)) {
    return textPointCaret.getSiblingCaret();
  } else if (offset === $getTextNodeOffset(origin, flipDirection(direction))) {
    return $rewindSiblingCaret(textPointCaret.getSiblingCaret());
  }
  const [textNode] = origin.splitText(offset);
  if (!$isTextNode(textNode)) {
    formatDevErrorMessage(`$splitTextPointCaret: splitText must return at least one TextNode`);
  }
  return $getCaretInDirection($getSiblingCaret(textNode, "next"), direction);
}
function $alwaysSplit(_node, _edge) {
  return true;
}
function $splitAtPointCaretNext(pointCaret, {
  $copyElementNode = $copyNode,
  $splitTextPointCaretNext = $splitTextPointCaret,
  rootMode = "shadowRoot",
  $shouldSplit = $alwaysSplit
} = {}) {
  if ($isTextPointCaret(pointCaret)) {
    return $splitTextPointCaretNext(pointCaret);
  }
  const parentCaret = pointCaret.getParentCaret(rootMode);
  if (parentCaret) {
    const {
      origin
    } = parentCaret;
    if ($isChildCaret(pointCaret) && !(origin.canBeEmpty() && $shouldSplit(origin, "first"))) {
      return $rewindSiblingCaret(parentCaret);
    }
    const siblings = $getAdjacentNodes(pointCaret);
    if (siblings.length > 0 || origin.canBeEmpty() && $shouldSplit(origin, "last")) {
      parentCaret.insert($copyElementNode(origin).splice(0, 0, siblings));
    }
  }
  return parentCaret;
}
// @__NO_SIDE_EFFECTS__
function defineExtension(extension) {
  return extension;
}
// @__NO_SIDE_EFFECTS__
function configExtension(...args) {
  return args;
}
// @__NO_SIDE_EFFECTS__
function declarePeerDependency(name, config) {
  return [name, config];
}
// @__NO_SIDE_EFFECTS__
function safeCast(value) {
  return value;
}
function shallowMergeConfig(config, overrides) {
  if (!overrides || config === overrides) {
    return config;
  }
  for (const k in overrides) {
    if (config[k] !== overrides[k]) {
      return {
        ...config,
        ...overrides
      };
    }
  }
  return config;
}

// node_modules/lexical/Lexical.mjs
var mod = true ? Lexical_dev_exports : Lexical_prod_exports;
var $addUpdateTag2 = mod.$addUpdateTag;
var $applyNodeReplacement2 = mod.$applyNodeReplacement;
var $caretFromPoint2 = mod.$caretFromPoint;
var $caretRangeFromSelection2 = mod.$caretRangeFromSelection;
var $cloneWithProperties2 = mod.$cloneWithProperties;
var $cloneWithPropertiesEphemeral2 = mod.$cloneWithPropertiesEphemeral;
var $comparePointCaretNext2 = mod.$comparePointCaretNext;
var $copyNode2 = mod.$copyNode;
var $create2 = mod.$create;
var $createLineBreakNode2 = mod.$createLineBreakNode;
var $createNodeSelection2 = mod.$createNodeSelection;
var $createParagraphNode2 = mod.$createParagraphNode;
var $createPoint2 = mod.$createPoint;
var $createRangeSelection2 = mod.$createRangeSelection;
var $createRangeSelectionFromDom2 = mod.$createRangeSelectionFromDom;
var $createTabNode2 = mod.$createTabNode;
var $createTextNode2 = mod.$createTextNode;
var $extendCaretToRange2 = mod.$extendCaretToRange;
var $findMatchingParent2 = mod.$findMatchingParent;
var $getAdjacentChildCaret2 = mod.$getAdjacentChildCaret;
var $getAdjacentNode2 = mod.$getAdjacentNode;
var $getAdjacentSiblingOrParentSiblingCaret2 = mod.$getAdjacentSiblingOrParentSiblingCaret;
var $getCaretInDirection2 = mod.$getCaretInDirection;
var $getCaretRange2 = mod.$getCaretRange;
var $getCaretRangeInDirection2 = mod.$getCaretRangeInDirection;
var $getCharacterOffsets2 = mod.$getCharacterOffsets;
var $getChildCaret2 = mod.$getChildCaret;
var $getChildCaretAtIndex2 = mod.$getChildCaretAtIndex;
var $getChildCaretOrSelf2 = mod.$getChildCaretOrSelf;
var $getCollapsedCaretRange2 = mod.$getCollapsedCaretRange;
var $getCommonAncestor2 = mod.$getCommonAncestor;
var $getCommonAncestorResultBranchOrder2 = mod.$getCommonAncestorResultBranchOrder;
var $getEditor2 = mod.$getEditor;
var $getNearestNodeFromDOMNode2 = mod.$getNearestNodeFromDOMNode;
var $getNearestRootOrShadowRoot2 = mod.$getNearestRootOrShadowRoot;
var $getNodeByKey2 = mod.$getNodeByKey;
var $getNodeByKeyOrThrow2 = mod.$getNodeByKeyOrThrow;
var $getNodeFromDOMNode2 = mod.$getNodeFromDOMNode;
var $getPreviousSelection2 = mod.$getPreviousSelection;
var $getRoot2 = mod.$getRoot;
var $getSelection2 = mod.$getSelection;
var $getSiblingCaret2 = mod.$getSiblingCaret;
var $getState2 = mod.$getState;
var $getStateChange2 = mod.$getStateChange;
var $getTextContent2 = mod.$getTextContent;
var $getTextNodeOffset2 = mod.$getTextNodeOffset;
var $getTextPointCaret2 = mod.$getTextPointCaret;
var $getTextPointCaretSlice2 = mod.$getTextPointCaretSlice;
var $getWritableNodeState2 = mod.$getWritableNodeState;
var $hasAncestor2 = mod.$hasAncestor;
var $hasUpdateTag2 = mod.$hasUpdateTag;
var $insertNodes2 = mod.$insertNodes;
var $isBlockElementNode2 = mod.$isBlockElementNode;
var $isChildCaret2 = mod.$isChildCaret;
var $isDecoratorNode2 = mod.$isDecoratorNode;
var $isEditorState2 = mod.$isEditorState;
var $isElementNode2 = mod.$isElementNode;
var $isExtendableTextPointCaret2 = mod.$isExtendableTextPointCaret;
var $isInlineElementOrDecoratorNode2 = mod.$isInlineElementOrDecoratorNode;
var $isLeafNode2 = mod.$isLeafNode;
var $isLineBreakNode2 = mod.$isLineBreakNode;
var $isNodeCaret2 = mod.$isNodeCaret;
var $isNodeSelection2 = mod.$isNodeSelection;
var $isParagraphNode2 = mod.$isParagraphNode;
var $isRangeSelection2 = mod.$isRangeSelection;
var $isRootNode2 = mod.$isRootNode;
var $isRootOrShadowRoot2 = mod.$isRootOrShadowRoot;
var $isSiblingCaret2 = mod.$isSiblingCaret;
var $isTabNode2 = mod.$isTabNode;
var $isTextNode2 = mod.$isTextNode;
var $isTextPointCaret2 = mod.$isTextPointCaret;
var $isTextPointCaretSlice2 = mod.$isTextPointCaretSlice;
var $isTokenOrSegmented2 = mod.$isTokenOrSegmented;
var $isTokenOrTab2 = mod.$isTokenOrTab;
var $nodesOfType2 = mod.$nodesOfType;
var $normalizeCaret2 = mod.$normalizeCaret;
var $normalizeSelection__EXPERIMENTAL = mod.$normalizeSelection__EXPERIMENTAL;
var $onUpdate2 = mod.$onUpdate;
var $parseSerializedNode2 = mod.$parseSerializedNode;
var $removeTextFromCaretRange2 = mod.$removeTextFromCaretRange;
var $rewindSiblingCaret2 = mod.$rewindSiblingCaret;
var $selectAll2 = mod.$selectAll;
var $setCompositionKey2 = mod.$setCompositionKey;
var $setPointFromCaret2 = mod.$setPointFromCaret;
var $setSelection2 = mod.$setSelection;
var $setSelectionFromCaretRange2 = mod.$setSelectionFromCaretRange;
var $setState2 = mod.$setState;
var $splitAtPointCaretNext2 = mod.$splitAtPointCaretNext;
var $splitNode2 = mod.$splitNode;
var $updateRangeSelectionFromCaretRange2 = mod.$updateRangeSelectionFromCaretRange;
var ArtificialNode__DO_NOT_USE2 = mod.ArtificialNode__DO_NOT_USE;
var BEFORE_INPUT_COMMAND2 = mod.BEFORE_INPUT_COMMAND;
var BLUR_COMMAND2 = mod.BLUR_COMMAND;
var CAN_REDO_COMMAND2 = mod.CAN_REDO_COMMAND;
var CAN_UNDO_COMMAND2 = mod.CAN_UNDO_COMMAND;
var CLEAR_EDITOR_COMMAND2 = mod.CLEAR_EDITOR_COMMAND;
var CLEAR_HISTORY_COMMAND2 = mod.CLEAR_HISTORY_COMMAND;
var CLICK_COMMAND2 = mod.CLICK_COMMAND;
var COLLABORATION_TAG2 = mod.COLLABORATION_TAG;
var COMMAND_PRIORITY_CRITICAL2 = mod.COMMAND_PRIORITY_CRITICAL;
var COMMAND_PRIORITY_EDITOR2 = mod.COMMAND_PRIORITY_EDITOR;
var COMMAND_PRIORITY_HIGH2 = mod.COMMAND_PRIORITY_HIGH;
var COMMAND_PRIORITY_LOW2 = mod.COMMAND_PRIORITY_LOW;
var COMMAND_PRIORITY_NORMAL2 = mod.COMMAND_PRIORITY_NORMAL;
var COMPOSITION_END_COMMAND2 = mod.COMPOSITION_END_COMMAND;
var COMPOSITION_START_COMMAND2 = mod.COMPOSITION_START_COMMAND;
var CONTROLLED_TEXT_INSERTION_COMMAND2 = mod.CONTROLLED_TEXT_INSERTION_COMMAND;
var COPY_COMMAND2 = mod.COPY_COMMAND;
var CUT_COMMAND2 = mod.CUT_COMMAND;
var DELETE_CHARACTER_COMMAND2 = mod.DELETE_CHARACTER_COMMAND;
var DELETE_LINE_COMMAND2 = mod.DELETE_LINE_COMMAND;
var DELETE_WORD_COMMAND2 = mod.DELETE_WORD_COMMAND;
var DRAGEND_COMMAND2 = mod.DRAGEND_COMMAND;
var DRAGOVER_COMMAND2 = mod.DRAGOVER_COMMAND;
var DRAGSTART_COMMAND2 = mod.DRAGSTART_COMMAND;
var DROP_COMMAND2 = mod.DROP_COMMAND;
var DecoratorNode2 = mod.DecoratorNode;
var ElementNode2 = mod.ElementNode;
var FOCUS_COMMAND2 = mod.FOCUS_COMMAND;
var FORMAT_ELEMENT_COMMAND2 = mod.FORMAT_ELEMENT_COMMAND;
var FORMAT_TEXT_COMMAND2 = mod.FORMAT_TEXT_COMMAND;
var HISTORIC_TAG2 = mod.HISTORIC_TAG;
var HISTORY_MERGE_TAG2 = mod.HISTORY_MERGE_TAG;
var HISTORY_PUSH_TAG2 = mod.HISTORY_PUSH_TAG;
var INDENT_CONTENT_COMMAND2 = mod.INDENT_CONTENT_COMMAND;
var INPUT_COMMAND2 = mod.INPUT_COMMAND;
var INSERT_LINE_BREAK_COMMAND2 = mod.INSERT_LINE_BREAK_COMMAND;
var INSERT_PARAGRAPH_COMMAND2 = mod.INSERT_PARAGRAPH_COMMAND;
var INSERT_TAB_COMMAND2 = mod.INSERT_TAB_COMMAND;
var INTERNAL_$isBlock2 = mod.INTERNAL_$isBlock;
var IS_ALL_FORMATTING2 = mod.IS_ALL_FORMATTING;
var IS_BOLD2 = mod.IS_BOLD;
var IS_CODE2 = mod.IS_CODE;
var IS_HIGHLIGHT2 = mod.IS_HIGHLIGHT;
var IS_ITALIC2 = mod.IS_ITALIC;
var IS_STRIKETHROUGH2 = mod.IS_STRIKETHROUGH;
var IS_SUBSCRIPT2 = mod.IS_SUBSCRIPT;
var IS_SUPERSCRIPT2 = mod.IS_SUPERSCRIPT;
var IS_UNDERLINE2 = mod.IS_UNDERLINE;
var KEY_ARROW_DOWN_COMMAND2 = mod.KEY_ARROW_DOWN_COMMAND;
var KEY_ARROW_LEFT_COMMAND2 = mod.KEY_ARROW_LEFT_COMMAND;
var KEY_ARROW_RIGHT_COMMAND2 = mod.KEY_ARROW_RIGHT_COMMAND;
var KEY_ARROW_UP_COMMAND2 = mod.KEY_ARROW_UP_COMMAND;
var KEY_BACKSPACE_COMMAND2 = mod.KEY_BACKSPACE_COMMAND;
var KEY_DELETE_COMMAND2 = mod.KEY_DELETE_COMMAND;
var KEY_DOWN_COMMAND2 = mod.KEY_DOWN_COMMAND;
var KEY_ENTER_COMMAND2 = mod.KEY_ENTER_COMMAND;
var KEY_ESCAPE_COMMAND2 = mod.KEY_ESCAPE_COMMAND;
var KEY_MODIFIER_COMMAND2 = mod.KEY_MODIFIER_COMMAND;
var KEY_SPACE_COMMAND2 = mod.KEY_SPACE_COMMAND;
var KEY_TAB_COMMAND2 = mod.KEY_TAB_COMMAND;
var LineBreakNode2 = mod.LineBreakNode;
var MOVE_TO_END2 = mod.MOVE_TO_END;
var MOVE_TO_START2 = mod.MOVE_TO_START;
var NODE_STATE_KEY2 = mod.NODE_STATE_KEY;
var OUTDENT_CONTENT_COMMAND2 = mod.OUTDENT_CONTENT_COMMAND;
var PASTE_COMMAND2 = mod.PASTE_COMMAND;
var PASTE_TAG2 = mod.PASTE_TAG;
var ParagraphNode2 = mod.ParagraphNode;
var REDO_COMMAND2 = mod.REDO_COMMAND;
var REMOVE_TEXT_COMMAND2 = mod.REMOVE_TEXT_COMMAND;
var RootNode2 = mod.RootNode;
var SELECTION_CHANGE_COMMAND2 = mod.SELECTION_CHANGE_COMMAND;
var SELECTION_INSERT_CLIPBOARD_NODES_COMMAND2 = mod.SELECTION_INSERT_CLIPBOARD_NODES_COMMAND;
var SELECT_ALL_COMMAND2 = mod.SELECT_ALL_COMMAND;
var SKIP_COLLAB_TAG2 = mod.SKIP_COLLAB_TAG;
var SKIP_DOM_SELECTION_TAG2 = mod.SKIP_DOM_SELECTION_TAG;
var SKIP_SCROLL_INTO_VIEW_TAG2 = mod.SKIP_SCROLL_INTO_VIEW_TAG;
var SKIP_SELECTION_FOCUS_TAG2 = mod.SKIP_SELECTION_FOCUS_TAG;
var TEXT_TYPE_TO_FORMAT2 = mod.TEXT_TYPE_TO_FORMAT;
var TabNode2 = mod.TabNode;
var TextNode2 = mod.TextNode;
var UNDO_COMMAND2 = mod.UNDO_COMMAND;
var buildImportMap2 = mod.buildImportMap;
var configExtension2 = mod.configExtension;
var createCommand2 = mod.createCommand;
var createEditor2 = mod.createEditor;
var createSharedNodeState2 = mod.createSharedNodeState;
var createState2 = mod.createState;
var declarePeerDependency2 = mod.declarePeerDependency;
var defineExtension2 = mod.defineExtension;
var flipDirection2 = mod.flipDirection;
var getDOMOwnerDocument2 = mod.getDOMOwnerDocument;
var getDOMSelection2 = mod.getDOMSelection;
var getDOMSelectionFromTarget2 = mod.getDOMSelectionFromTarget;
var getDOMTextNode2 = mod.getDOMTextNode;
var getEditorPropertyFromDOMNode2 = mod.getEditorPropertyFromDOMNode;
var getNearestEditorFromDOMNode2 = mod.getNearestEditorFromDOMNode;
var getRegisteredNode2 = mod.getRegisteredNode;
var getRegisteredNodeOrThrow2 = mod.getRegisteredNodeOrThrow;
var getStaticNodeConfig2 = mod.getStaticNodeConfig;
var getTextDirection2 = mod.getTextDirection;
var getTransformSetFromKlass2 = mod.getTransformSetFromKlass;
var isBlockDomNode2 = mod.isBlockDomNode;
var isCurrentlyReadOnlyMode2 = mod.isCurrentlyReadOnlyMode;
var isDOMDocumentNode2 = mod.isDOMDocumentNode;
var isDOMNode2 = mod.isDOMNode;
var isDOMTextNode2 = mod.isDOMTextNode;
var isDOMUnmanaged2 = mod.isDOMUnmanaged;
var isDocumentFragment2 = mod.isDocumentFragment;
var isExactShortcutMatch2 = mod.isExactShortcutMatch;
var isHTMLAnchorElement2 = mod.isHTMLAnchorElement;
var isHTMLElement2 = mod.isHTMLElement;
var isInlineDomNode2 = mod.isInlineDomNode;
var isLexicalEditor2 = mod.isLexicalEditor;
var isModifierMatch2 = mod.isModifierMatch;
var isSelectionCapturedInDecoratorInput2 = mod.isSelectionCapturedInDecoratorInput;
var isSelectionWithinEditor2 = mod.isSelectionWithinEditor;
var makeStepwiseIterator2 = mod.makeStepwiseIterator;
var removeFromParent2 = mod.removeFromParent;
var resetRandomKey2 = mod.resetRandomKey;
var safeCast2 = mod.safeCast;
var setDOMUnmanaged2 = mod.setDOMUnmanaged;
var setNodeIndentFromDOM2 = mod.setNodeIndentFromDOM;
var shallowMergeConfig2 = mod.shallowMergeConfig;

// node_modules/@lexical/selection/LexicalSelection.dev.mjs
function formatDevErrorMessage2(message) {
  throw new Error(message);
}
var CSS_TO_STYLES = /* @__PURE__ */ new Map();
function getDOMTextNode3(element) {
  let node = element;
  while (node != null) {
    if (node.nodeType === Node.TEXT_NODE) {
      return node;
    }
    node = node.firstChild;
  }
  return null;
}
function getDOMIndexWithinParent(node) {
  const parent = node.parentNode;
  if (parent == null) {
    throw new Error("Should never happen");
  }
  return [parent, Array.from(parent.childNodes).indexOf(node)];
}
function createDOMRange(editor, anchorNode, _anchorOffset, focusNode, _focusOffset) {
  const anchorKey = anchorNode.getKey();
  const focusKey = focusNode.getKey();
  const range = document.createRange();
  let anchorDOM = editor.getElementByKey(anchorKey);
  let focusDOM = editor.getElementByKey(focusKey);
  let anchorOffset = _anchorOffset;
  let focusOffset = _focusOffset;
  if ($isTextNode2(anchorNode)) {
    anchorDOM = getDOMTextNode3(anchorDOM);
  }
  if ($isTextNode2(focusNode)) {
    focusDOM = getDOMTextNode3(focusDOM);
  }
  if (anchorNode === void 0 || focusNode === void 0 || anchorDOM === null || focusDOM === null) {
    return null;
  }
  if (anchorDOM.nodeName === "BR") {
    [anchorDOM, anchorOffset] = getDOMIndexWithinParent(anchorDOM);
  }
  if (focusDOM.nodeName === "BR") {
    [focusDOM, focusOffset] = getDOMIndexWithinParent(focusDOM);
  }
  const firstChild = anchorDOM.firstChild;
  if (anchorDOM === focusDOM && firstChild != null && firstChild.nodeName === "BR" && anchorOffset === 0 && focusOffset === 0) {
    focusOffset = 1;
  }
  try {
    range.setStart(anchorDOM, anchorOffset);
    range.setEnd(focusDOM, focusOffset);
  } catch (_e) {
    return null;
  }
  if (range.collapsed && (anchorOffset !== focusOffset || anchorKey !== focusKey)) {
    range.setStart(focusDOM, focusOffset);
    range.setEnd(anchorDOM, anchorOffset);
  }
  return range;
}
function createRectsFromDOMRange(editor, range) {
  const rootElement = editor.getRootElement();
  if (rootElement === null) {
    return [];
  }
  const rootRect = rootElement.getBoundingClientRect();
  const computedStyle = getComputedStyle(rootElement);
  const rootPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);
  const selectionRects = Array.from(range.getClientRects());
  let selectionRectsLength = selectionRects.length;
  selectionRects.sort((a2, b2) => {
    const top = a2.top - b2.top;
    if (Math.abs(top) <= 3) {
      return a2.left - b2.left;
    }
    return top;
  });
  let prevRect;
  for (let i2 = 0; i2 < selectionRectsLength; i2++) {
    const selectionRect = selectionRects[i2];
    const isOverlappingRect = prevRect && prevRect.top <= selectionRect.top && prevRect.top + prevRect.height > selectionRect.top && prevRect.left + prevRect.width > selectionRect.left;
    const selectionSpansElement = selectionRect.width + rootPadding === rootRect.width;
    if (isOverlappingRect || selectionSpansElement) {
      selectionRects.splice(i2--, 1);
      selectionRectsLength--;
      continue;
    }
    prevRect = selectionRect;
  }
  return selectionRects;
}
function getStyleObjectFromRawCSS(css) {
  const styleObject = {};
  if (!css) {
    return styleObject;
  }
  const styles = css.split(";");
  for (const style of styles) {
    if (style !== "") {
      const [key, value] = style.split(/:([^]+)/);
      if (key && value) {
        styleObject[key.trim()] = value.trim();
      }
    }
  }
  return styleObject;
}
function getStyleObjectFromCSS(css) {
  let value = CSS_TO_STYLES.get(css);
  if (value === void 0) {
    value = getStyleObjectFromRawCSS(css);
    CSS_TO_STYLES.set(css, value);
  }
  {
    Object.freeze(value);
  }
  return value;
}
function getCSSFromStyleObject(styles) {
  let css = "";
  for (const style in styles) {
    if (style) {
      css += `${style}: ${styles[style]};`;
    }
  }
  return css;
}
function $getComputedStyleForElement(element) {
  const editor = $getEditor2();
  const domElement = editor.getElementByKey(element.getKey());
  if (domElement === null) {
    return null;
  }
  const view = domElement.ownerDocument.defaultView;
  if (view === null) {
    return null;
  }
  return view.getComputedStyle(domElement);
}
function $getComputedStyleForParent(node) {
  const parent = $isRootNode2(node) ? node : node.getParentOrThrow();
  return $getComputedStyleForElement(parent);
}
function $isParentRTL(node) {
  const styles = $getComputedStyleForParent(node);
  return styles !== null && styles.direction === "rtl";
}
function $sliceSelectedTextNodeContent(selection, textNode, mutates = "self") {
  const anchorAndFocus = selection.getStartEndPoints();
  if (textNode.isSelected(selection) && !$isTokenOrSegmented2(textNode) && anchorAndFocus !== null) {
    const [anchor, focus] = anchorAndFocus;
    const isBackward = selection.isBackward();
    const anchorNode = anchor.getNode();
    const focusNode = focus.getNode();
    const isAnchor = textNode.is(anchorNode);
    const isFocus = textNode.is(focusNode);
    if (isAnchor || isFocus) {
      const [anchorOffset, focusOffset] = $getCharacterOffsets2(selection);
      const isSame = anchorNode.is(focusNode);
      const isFirst = textNode.is(isBackward ? focusNode : anchorNode);
      const isLast = textNode.is(isBackward ? anchorNode : focusNode);
      let startOffset = 0;
      let endOffset = void 0;
      if (isSame) {
        startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;
        endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;
      } else if (isFirst) {
        const offset = isBackward ? focusOffset : anchorOffset;
        startOffset = offset;
        endOffset = void 0;
      } else if (isLast) {
        const offset = isBackward ? anchorOffset : focusOffset;
        startOffset = 0;
        endOffset = offset;
      }
      const text = textNode.__text.slice(startOffset, endOffset);
      if (text !== textNode.__text) {
        if (mutates === "clone") {
          textNode = $cloneWithPropertiesEphemeral2(textNode);
        }
        textNode.__text = text;
      }
    }
  }
  return textNode;
}
function $isAtNodeEnd(point) {
  if (point.type === "text") {
    return point.offset === point.getNode().getTextContentSize();
  }
  const node = point.getNode();
  if (!$isElementNode2(node)) {
    formatDevErrorMessage2(`isAtNodeEnd: node must be a TextNode or ElementNode`);
  }
  return point.offset === node.getChildrenSize();
}
function $trimTextContentFromAnchor(editor, anchor, delCount) {
  let currentNode = anchor.getNode();
  let remaining = delCount;
  if ($isElementNode2(currentNode)) {
    const descendantNode = currentNode.getDescendantByIndex(anchor.offset);
    if (descendantNode !== null) {
      currentNode = descendantNode;
    }
  }
  while (remaining > 0 && currentNode !== null) {
    if ($isElementNode2(currentNode)) {
      const lastDescendant = currentNode.getLastDescendant();
      if (lastDescendant !== null) {
        currentNode = lastDescendant;
      }
    }
    let nextNode = currentNode.getPreviousSibling();
    let additionalElementWhitespace = 0;
    if (nextNode === null) {
      let parent = currentNode.getParentOrThrow();
      let parentSibling = parent.getPreviousSibling();
      while (parentSibling === null) {
        parent = parent.getParent();
        if (parent === null) {
          nextNode = null;
          break;
        }
        parentSibling = parent.getPreviousSibling();
      }
      if (parent !== null) {
        additionalElementWhitespace = parent.isInline() ? 0 : 2;
        nextNode = parentSibling;
      }
    }
    let text = currentNode.getTextContent();
    if (text === "" && $isElementNode2(currentNode) && !currentNode.isInline()) {
      text = "\n\n";
    }
    const currentNodeSize = text.length;
    if (!$isTextNode2(currentNode) || remaining >= currentNodeSize) {
      const parent = currentNode.getParent();
      currentNode.remove();
      if (parent != null && parent.getChildrenSize() === 0 && !$isRootNode2(parent)) {
        parent.remove();
      }
      remaining -= currentNodeSize + additionalElementWhitespace;
      currentNode = nextNode;
    } else {
      const key = currentNode.getKey();
      const prevTextContent = editor.getEditorState().read(() => {
        const prevNode = $getNodeByKey2(key);
        if ($isTextNode2(prevNode) && prevNode.isSimpleText()) {
          return prevNode.getTextContent();
        }
        return null;
      });
      const offset = currentNodeSize - remaining;
      const slicedText = text.slice(0, offset);
      if (prevTextContent !== null && prevTextContent !== text) {
        const prevSelection = $getPreviousSelection2();
        let target = currentNode;
        if (!currentNode.isSimpleText()) {
          const textNode = $createTextNode2(prevTextContent);
          currentNode.replace(textNode);
          target = textNode;
        } else {
          currentNode.setTextContent(prevTextContent);
        }
        if ($isRangeSelection2(prevSelection) && prevSelection.isCollapsed()) {
          const prevOffset = prevSelection.anchor.offset;
          target.select(prevOffset, prevOffset);
        }
      } else if (currentNode.isSimpleText()) {
        const isSelected = anchor.key === key;
        let anchorOffset = anchor.offset;
        if (anchorOffset < remaining) {
          anchorOffset = currentNodeSize;
        }
        const splitStart = isSelected ? anchorOffset - remaining : 0;
        const splitEnd = isSelected ? anchorOffset : offset;
        if (isSelected && splitStart === 0) {
          const [excessNode] = currentNode.splitText(splitStart, splitEnd);
          excessNode.remove();
        } else {
          const [, excessNode] = currentNode.splitText(splitStart, splitEnd);
          excessNode.remove();
        }
      } else {
        const textNode = $createTextNode2(slicedText);
        currentNode.replace(textNode);
      }
      remaining = 0;
    }
  }
}
function $addNodeStyle(node) {
  const CSSText = node.getStyle();
  const styles = getStyleObjectFromRawCSS(CSSText);
  CSS_TO_STYLES.set(CSSText, styles);
}
function $patchStyle(target, patch) {
  if (!($isRangeSelection2(target) ? target.isCollapsed() : $isTextNode2(target) || $isElementNode2(target))) {
    formatDevErrorMessage2(`$patchStyle must only be called with a TextNode, ElementNode, or collapsed RangeSelection`);
  }
  const prevStyles = getStyleObjectFromCSS($isRangeSelection2(target) ? target.style : $isTextNode2(target) ? target.getStyle() : target.getTextStyle());
  const newStyles = Object.entries(patch).reduce((styles, [key, value]) => {
    if (typeof value === "function") {
      styles[key] = value(prevStyles[key], target);
    } else if (value === null) {
      delete styles[key];
    } else {
      styles[key] = value;
    }
    return styles;
  }, {
    ...prevStyles
  });
  const newCSSText = getCSSFromStyleObject(newStyles);
  if ($isRangeSelection2(target) || $isTextNode2(target)) {
    target.setStyle(newCSSText);
  } else {
    target.setTextStyle(newCSSText);
  }
  CSS_TO_STYLES.set(newCSSText, newStyles);
}
function $patchStyleText(selection, patch) {
  if ($isRangeSelection2(selection) && selection.isCollapsed()) {
    $patchStyle(selection, patch);
    const emptyNode = selection.anchor.getNode();
    if ($isElementNode2(emptyNode) && emptyNode.isEmpty()) {
      $patchStyle(emptyNode, patch);
    }
  }
  $forEachSelectedTextNode((textNode) => {
    $patchStyle(textNode, patch);
  });
  const nodes = selection.getNodes();
  if (nodes.length > 0) {
    const patchedElementKeys = /* @__PURE__ */ new Set();
    for (const node of nodes) {
      if (!$isElementNode2(node) || !node.canBeEmpty() || node.getChildrenSize() !== 0) {
        continue;
      }
      const key = node.getKey();
      if (patchedElementKeys.has(key)) {
        continue;
      }
      patchedElementKeys.add(key);
      $patchStyle(node, patch);
    }
  }
}
function $forEachSelectedTextNode(fn) {
  const selection = $getSelection2();
  if (!selection) {
    return;
  }
  const slicedTextNodes = /* @__PURE__ */ new Map();
  const getSliceIndices = (node) => slicedTextNodes.get(node.getKey()) || [0, node.getTextContentSize()];
  if ($isRangeSelection2(selection)) {
    for (const slice of $caretRangeFromSelection2(selection).getTextSlices()) {
      if (slice) {
        slicedTextNodes.set(slice.caret.origin.getKey(), slice.getSliceIndices());
      }
    }
  }
  const selectedNodes = selection.getNodes();
  for (const selectedNode of selectedNodes) {
    if (!($isTextNode2(selectedNode) && selectedNode.canHaveFormat())) {
      continue;
    }
    const [startOffset, endOffset] = getSliceIndices(selectedNode);
    if (endOffset === startOffset) {
      continue;
    }
    if ($isTokenOrSegmented2(selectedNode) || startOffset === 0 && endOffset === selectedNode.getTextContentSize()) {
      fn(selectedNode);
    } else {
      const splitNodes = selectedNode.splitText(startOffset, endOffset);
      const replacement = splitNodes[startOffset === 0 ? 0 : 1];
      fn(replacement);
    }
  }
  if ($isRangeSelection2(selection) && selection.anchor.type === "text" && selection.focus.type === "text" && selection.anchor.key === selection.focus.key) {
    $ensureForwardRangeSelection(selection);
  }
}
function $ensureForwardRangeSelection(selection) {
  if (selection.isBackward()) {
    const {
      anchor,
      focus
    } = selection;
    const {
      key,
      offset,
      type
    } = anchor;
    anchor.set(focus.key, focus.offset, focus.type);
    focus.set(key, offset, type);
  }
}
function $copyBlockFormatIndent(srcNode, destNode) {
  const format = srcNode.getFormatType();
  const indent = srcNode.getIndent();
  if (format !== destNode.getFormatType()) {
    destNode.setFormat(format);
  }
  if (indent !== destNode.getIndent()) {
    destNode.setIndent(indent);
  }
}
function $setBlocksType(selection, $createElement, $afterCreateElement = $copyBlockFormatIndent) {
  if (selection === null) {
    return;
  }
  const anchorAndFocus = selection.getStartEndPoints();
  const blockMap = /* @__PURE__ */ new Map();
  let newSelection = null;
  if (anchorAndFocus) {
    const [anchor, focus] = anchorAndFocus;
    newSelection = $createRangeSelection2();
    newSelection.anchor.set(anchor.key, anchor.offset, anchor.type);
    newSelection.focus.set(focus.key, focus.offset, focus.type);
    const anchorBlock = $findMatchingParent2(anchor.getNode(), INTERNAL_$isBlock2);
    const focusBlock = $findMatchingParent2(focus.getNode(), INTERNAL_$isBlock2);
    if ($isElementNode2(anchorBlock)) {
      blockMap.set(anchorBlock.getKey(), anchorBlock);
    }
    if ($isElementNode2(focusBlock)) {
      blockMap.set(focusBlock.getKey(), focusBlock);
    }
  }
  for (const node of selection.getNodes()) {
    if ($isElementNode2(node) && INTERNAL_$isBlock2(node)) {
      blockMap.set(node.getKey(), node);
    } else if (anchorAndFocus === null) {
      const ancestorBlock = $findMatchingParent2(node, INTERNAL_$isBlock2);
      if ($isElementNode2(ancestorBlock)) {
        blockMap.set(ancestorBlock.getKey(), ancestorBlock);
      }
    }
  }
  for (const [key, prevNode] of blockMap) {
    const element = $createElement();
    $afterCreateElement(prevNode, element);
    prevNode.replace(element, true);
    if (newSelection) {
      if (key === newSelection.anchor.key) {
        newSelection.anchor.set(element.getKey(), newSelection.anchor.offset, newSelection.anchor.type);
      }
      if (key === newSelection.focus.key) {
        newSelection.focus.set(element.getKey(), newSelection.focus.offset, newSelection.focus.type);
      }
    }
  }
  if (newSelection && selection.is($getSelection2())) {
    $setSelection2(newSelection);
  }
}
function isPointAttached(point) {
  return point.getNode().isAttached();
}
function $removeParentEmptyElements(startingNode) {
  let node = startingNode;
  while (node !== null && !$isRootOrShadowRoot2(node)) {
    const latest = node.getLatest();
    const parentNode = node.getParent();
    if (latest.getChildrenSize() === 0) {
      node.remove(true);
    }
    node = parentNode;
  }
}
function $wrapNodes(selection, createElement, wrappingElement = null) {
  const anchorAndFocus = selection.getStartEndPoints();
  const anchor = anchorAndFocus ? anchorAndFocus[0] : null;
  const nodes = selection.getNodes();
  const nodesLength = nodes.length;
  if (anchor !== null && (nodesLength === 0 || nodesLength === 1 && anchor.type === "element" && anchor.getNode().getChildrenSize() === 0)) {
    const target = anchor.type === "text" ? anchor.getNode().getParentOrThrow() : anchor.getNode();
    const children = target.getChildren();
    let element = createElement();
    element.setFormat(target.getFormatType());
    element.setIndent(target.getIndent());
    children.forEach((child) => element.append(child));
    if (wrappingElement) {
      element = wrappingElement.append(element);
    }
    target.replace(element);
    return;
  }
  let topLevelNode = null;
  let descendants = [];
  for (let i2 = 0; i2 < nodesLength; i2++) {
    const node = nodes[i2];
    if ($isRootOrShadowRoot2(node)) {
      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);
      descendants = [];
      topLevelNode = node;
    } else if (topLevelNode === null || topLevelNode !== null && $hasAncestor2(node, topLevelNode)) {
      descendants.push(node);
    } else {
      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);
      descendants = [node];
    }
  }
  $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);
}
function $wrapNodesImpl(selection, nodes, nodesLength, createElement, wrappingElement = null) {
  if (nodes.length === 0) {
    return;
  }
  const firstNode = nodes[0];
  const elementMapping = /* @__PURE__ */ new Map();
  const elements = [];
  let target = $isElementNode2(firstNode) ? firstNode : firstNode.getParentOrThrow();
  if (target.isInline()) {
    target = target.getParentOrThrow();
  }
  let targetIsPrevSibling = false;
  while (target !== null) {
    const prevSibling = target.getPreviousSibling();
    if (prevSibling !== null) {
      target = prevSibling;
      targetIsPrevSibling = true;
      break;
    }
    target = target.getParentOrThrow();
    if ($isRootOrShadowRoot2(target)) {
      break;
    }
  }
  const emptyElements = /* @__PURE__ */ new Set();
  for (let i2 = 0; i2 < nodesLength; i2++) {
    const node = nodes[i2];
    if ($isElementNode2(node) && node.getChildrenSize() === 0) {
      emptyElements.add(node.getKey());
    }
  }
  const movedNodes = /* @__PURE__ */ new Set();
  for (let i2 = 0; i2 < nodesLength; i2++) {
    const node = nodes[i2];
    let parent = node.getParent();
    if (parent !== null && parent.isInline()) {
      parent = parent.getParent();
    }
    if (parent !== null && $isLeafNode2(node) && !movedNodes.has(node.getKey())) {
      const parentKey = parent.getKey();
      if (elementMapping.get(parentKey) === void 0) {
        const targetElement = createElement();
        targetElement.setFormat(parent.getFormatType());
        targetElement.setIndent(parent.getIndent());
        elements.push(targetElement);
        elementMapping.set(parentKey, targetElement);
        parent.getChildren().forEach((child) => {
          targetElement.append(child);
          movedNodes.add(child.getKey());
          if ($isElementNode2(child)) {
            child.getChildrenKeys().forEach((key) => movedNodes.add(key));
          }
        });
        $removeParentEmptyElements(parent);
      }
    } else if (emptyElements.has(node.getKey())) {
      if (!$isElementNode2(node)) {
        formatDevErrorMessage2(`Expected node in emptyElements to be an ElementNode`);
      }
      const targetElement = createElement();
      targetElement.setFormat(node.getFormatType());
      targetElement.setIndent(node.getIndent());
      elements.push(targetElement);
      node.remove(true);
    }
  }
  if (wrappingElement !== null) {
    for (let i2 = 0; i2 < elements.length; i2++) {
      const element = elements[i2];
      wrappingElement.append(element);
    }
  }
  let lastElement = null;
  if ($isRootOrShadowRoot2(target)) {
    if (targetIsPrevSibling) {
      if (wrappingElement !== null) {
        target.insertAfter(wrappingElement);
      } else {
        for (let i2 = elements.length - 1; i2 >= 0; i2--) {
          const element = elements[i2];
          target.insertAfter(element);
        }
      }
    } else {
      const firstChild = target.getFirstChild();
      if ($isElementNode2(firstChild)) {
        target = firstChild;
      }
      if (firstChild === null) {
        if (wrappingElement) {
          target.append(wrappingElement);
        } else {
          for (let i2 = 0; i2 < elements.length; i2++) {
            const element = elements[i2];
            target.append(element);
            lastElement = element;
          }
        }
      } else {
        if (wrappingElement !== null) {
          firstChild.insertBefore(wrappingElement);
        } else {
          for (let i2 = 0; i2 < elements.length; i2++) {
            const element = elements[i2];
            firstChild.insertBefore(element);
            lastElement = element;
          }
        }
      }
    }
  } else {
    if (wrappingElement) {
      target.insertAfter(wrappingElement);
    } else {
      for (let i2 = elements.length - 1; i2 >= 0; i2--) {
        const element = elements[i2];
        target.insertAfter(element);
        lastElement = element;
      }
    }
  }
  const prevSelection = $getPreviousSelection2();
  if ($isRangeSelection2(prevSelection) && isPointAttached(prevSelection.anchor) && isPointAttached(prevSelection.focus)) {
    $setSelection2(prevSelection.clone());
  } else if (lastElement !== null) {
    lastElement.selectEnd();
  } else {
    selection.dirty = true;
  }
}
function $isEditorVerticalOrientation(selection) {
  const computedStyle = $getComputedStyle(selection);
  return computedStyle !== null && computedStyle.writingMode === "vertical-rl";
}
function $getComputedStyle(selection) {
  const anchorNode = selection.anchor.getNode();
  if ($isElementNode2(anchorNode)) {
    return $getComputedStyleForElement(anchorNode);
  }
  return $getComputedStyleForParent(anchorNode);
}
function $shouldOverrideDefaultCharacterSelection(selection, isBackward) {
  const isVertical = $isEditorVerticalOrientation(selection);
  let adjustedIsBackward = isVertical ? !isBackward : isBackward;
  if ($isParentElementRTL(selection)) {
    adjustedIsBackward = !adjustedIsBackward;
  }
  const focusCaret = $caretFromPoint2(selection.focus, adjustedIsBackward ? "previous" : "next");
  if ($isExtendableTextPointCaret2(focusCaret)) {
    return false;
  }
  for (const nextCaret of $extendCaretToRange2(focusCaret)) {
    if ($isChildCaret2(nextCaret)) {
      return !nextCaret.origin.isInline();
    } else if ($isElementNode2(nextCaret.origin)) {
      continue;
    } else if ($isDecoratorNode2(nextCaret.origin)) {
      return true;
    }
    break;
  }
  return false;
}
function $moveCaretSelection(selection, isHoldingShift, isBackward, granularity) {
  selection.modify(isHoldingShift ? "extend" : "move", isBackward, granularity);
}
function $isParentElementRTL(selection) {
  const computedStyle = $getComputedStyle(selection);
  return computedStyle !== null && computedStyle.direction === "rtl";
}
function $moveCharacter(selection, isHoldingShift, isBackward) {
  const isRTL = $isParentElementRTL(selection);
  const isVertical = $isEditorVerticalOrientation(selection);
  let adjustedIsBackward;
  if (isVertical) {
    adjustedIsBackward = !isBackward;
  } else if (isRTL) {
    adjustedIsBackward = !isBackward;
  } else {
    adjustedIsBackward = isBackward;
  }
  $moveCaretSelection(selection, isHoldingShift, adjustedIsBackward, "character");
}
function $getNodeStyleValueForProperty(node, styleProperty, defaultValue) {
  const css = node.getStyle();
  const styleObject = getStyleObjectFromCSS(css);
  if (styleObject !== null) {
    return styleObject[styleProperty] || defaultValue;
  }
  return defaultValue;
}
function $getSelectionStyleValueForProperty(selection, styleProperty, defaultValue = "") {
  let styleValue = null;
  const nodes = selection.getNodes();
  const anchor = selection.anchor;
  const focus = selection.focus;
  const isBackward = selection.isBackward();
  const endOffset = isBackward ? focus.offset : anchor.offset;
  const endNode = isBackward ? focus.getNode() : anchor.getNode();
  if ($isRangeSelection2(selection) && selection.isCollapsed() && selection.style !== "") {
    const css = selection.style;
    const styleObject = getStyleObjectFromCSS(css);
    if (styleObject !== null && styleProperty in styleObject) {
      return styleObject[styleProperty];
    }
  }
  for (let i2 = 0; i2 < nodes.length; i2++) {
    const node = nodes[i2];
    if (i2 !== 0 && endOffset === 0 && node.is(endNode)) {
      continue;
    }
    if ($isTextNode2(node)) {
      const nodeStyleValue = $getNodeStyleValueForProperty(node, styleProperty, defaultValue);
      if (styleValue === null) {
        styleValue = nodeStyleValue;
      } else if (styleValue !== nodeStyleValue) {
        styleValue = "";
        break;
      }
    }
  }
  return styleValue === null ? defaultValue : styleValue;
}
var trimTextContentFromAnchor = $trimTextContentFromAnchor;

// node_modules/@lexical/selection/LexicalSelection.mjs
var mod2 = true ? LexicalSelection_dev_exports : LexicalSelection_prod_exports;
var $addNodeStyle2 = mod2.$addNodeStyle;
var $cloneWithProperties3 = mod2.$cloneWithProperties;
var $copyBlockFormatIndent2 = mod2.$copyBlockFormatIndent;
var $ensureForwardRangeSelection2 = mod2.$ensureForwardRangeSelection;
var $forEachSelectedTextNode2 = mod2.$forEachSelectedTextNode;
var $getComputedStyleForElement2 = mod2.$getComputedStyleForElement;
var $getComputedStyleForParent2 = mod2.$getComputedStyleForParent;
var $getSelectionStyleValueForProperty2 = mod2.$getSelectionStyleValueForProperty;
var $isAtNodeEnd2 = mod2.$isAtNodeEnd;
var $isParentElementRTL2 = mod2.$isParentElementRTL;
var $isParentRTL2 = mod2.$isParentRTL;
var $moveCaretSelection2 = mod2.$moveCaretSelection;
var $moveCharacter2 = mod2.$moveCharacter;
var $patchStyleText2 = mod2.$patchStyleText;
var $selectAll3 = mod2.$selectAll;
var $setBlocksType2 = mod2.$setBlocksType;
var $shouldOverrideDefaultCharacterSelection2 = mod2.$shouldOverrideDefaultCharacterSelection;
var $sliceSelectedTextNodeContent2 = mod2.$sliceSelectedTextNodeContent;
var $trimTextContentFromAnchor2 = mod2.$trimTextContentFromAnchor;
var $wrapNodes2 = mod2.$wrapNodes;
var createDOMRange2 = mod2.createDOMRange;
var createRectsFromDOMRange2 = mod2.createRectsFromDOMRange;
var getCSSFromStyleObject2 = mod2.getCSSFromStyleObject;
var getStyleObjectFromCSS2 = mod2.getStyleObjectFromCSS;
var trimTextContentFromAnchor2 = mod2.trimTextContentFromAnchor;

// node_modules/@lexical/utils/LexicalUtils.dev.mjs
var LexicalUtils_dev_exports = {};
__export(LexicalUtils_dev_exports, {
  $descendantsMatching: () => $descendantsMatching,
  $dfs: () => $dfs,
  $dfsIterator: () => $dfsIterator,
  $filter: () => $filter,
  $findMatchingParent: () => $findMatchingParent2,
  $firstToLastIterator: () => $firstToLastIterator,
  $getAdjacentCaret: () => $getAdjacentCaret,
  $getAdjacentSiblingOrParentSiblingCaret: () => $getAdjacentSiblingOrParentSiblingCaret2,
  $getDepth: () => $getDepth,
  $getNearestBlockElementAncestorOrThrow: () => $getNearestBlockElementAncestorOrThrow,
  $getNearestNodeOfType: () => $getNearestNodeOfType,
  $getNextRightPreorderNode: () => $getNextRightPreorderNode,
  $getNextSiblingOrParentSibling: () => $getNextSiblingOrParentSibling,
  $insertFirst: () => $insertFirst,
  $insertNodeToNearestRoot: () => $insertNodeToNearestRoot,
  $insertNodeToNearestRootAtCaret: () => $insertNodeToNearestRootAtCaret,
  $isEditorIsNestedEditor: () => $isEditorIsNestedEditor,
  $lastToFirstIterator: () => $lastToFirstIterator,
  $restoreEditorState: () => $restoreEditorState,
  $reverseDfs: () => $reverseDfs,
  $reverseDfsIterator: () => $reverseDfsIterator,
  $splitNode: () => $splitNode2,
  $unwrapAndFilterDescendants: () => $unwrapAndFilterDescendants,
  $unwrapNode: () => $unwrapNode,
  $wrapNodeInElement: () => $wrapNodeInElement,
  CAN_USE_BEFORE_INPUT: () => CAN_USE_BEFORE_INPUT2,
  CAN_USE_DOM: () => CAN_USE_DOM2,
  IS_ANDROID: () => IS_ANDROID2,
  IS_ANDROID_CHROME: () => IS_ANDROID_CHROME2,
  IS_APPLE: () => IS_APPLE2,
  IS_APPLE_WEBKIT: () => IS_APPLE_WEBKIT2,
  IS_CHROME: () => IS_CHROME2,
  IS_FIREFOX: () => IS_FIREFOX2,
  IS_IOS: () => IS_IOS2,
  IS_SAFARI: () => IS_SAFARI2,
  addClassNamesToElement: () => addClassNamesToElement,
  calculateZoomLevel: () => calculateZoomLevel,
  isBlockDomNode: () => isBlockDomNode2,
  isHTMLAnchorElement: () => isHTMLAnchorElement2,
  isHTMLElement: () => isHTMLElement2,
  isInlineDomNode: () => isInlineDomNode2,
  isMimeType: () => isMimeType,
  makeStateWrapper: () => makeStateWrapper,
  markSelection: () => markSelection,
  mediaFileReader: () => mediaFileReader,
  mergeRegister: () => mergeRegister,
  objectKlassEquals: () => objectKlassEquals,
  positionNodeOnRange: () => mlcPositionNodeOnRange,
  registerNestedElementResolver: () => registerNestedElementResolver,
  removeClassNamesFromElement: () => removeClassNamesFromElement,
  selectionAlwaysOnDisplay: () => selectionAlwaysOnDisplay
});
function formatDevErrorMessage3(message) {
  throw new Error(message);
}
var CAN_USE_DOM$1 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
var documentMode2 = CAN_USE_DOM$1 && "documentMode" in document ? document.documentMode : null;
var IS_APPLE$1 = CAN_USE_DOM$1 && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
var IS_FIREFOX$1 = CAN_USE_DOM$1 && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
var CAN_USE_BEFORE_INPUT$1 = CAN_USE_DOM$1 && "InputEvent" in window && !documentMode2 ? "getTargetRanges" in new window.InputEvent("input") : false;
var IS_SAFARI$1 = CAN_USE_DOM$1 && /Version\/[\d.]+.*Safari/.test(navigator.userAgent);
var IS_IOS$1 = CAN_USE_DOM$1 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
var IS_ANDROID$1 = CAN_USE_DOM$1 && /Android/.test(navigator.userAgent);
var IS_CHROME$1 = CAN_USE_DOM$1 && /^(?=.*Chrome).*/i.test(navigator.userAgent);
var IS_ANDROID_CHROME$1 = CAN_USE_DOM$1 && IS_ANDROID$1 && IS_CHROME$1;
var IS_APPLE_WEBKIT$1 = CAN_USE_DOM$1 && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && IS_APPLE$1 && !IS_CHROME$1;
function normalizeClassNames2(...classNames) {
  const rval = [];
  for (const className of classNames) {
    if (className && typeof className === "string") {
      for (const [s2] of className.matchAll(/\S+/g)) {
        rval.push(s2);
      }
    }
  }
  return rval;
}
function mergeRegister(...func) {
  return () => {
    for (let i2 = func.length - 1; i2 >= 0; i2--) {
      func[i2]();
    }
    func.length = 0;
  };
}
function px(value) {
  return `${value}px`;
}
var mutationObserverConfig = {
  attributes: true,
  characterData: true,
  childList: true,
  subtree: true
};
function prependDOMNode(parent, node) {
  parent.insertBefore(node, parent.firstChild);
}
function mlcPositionNodeOnRange(editor, range, onReposition) {
  let rootDOMNode = null;
  let parentDOMNode = null;
  let observer = null;
  let lastNodes = [];
  const wrapperNode = document.createElement("div");
  wrapperNode.style.position = "relative";
  function position() {
    if (!(rootDOMNode !== null)) {
      formatDevErrorMessage3(`Unexpected null rootDOMNode`);
    }
    if (!(parentDOMNode !== null)) {
      formatDevErrorMessage3(`Unexpected null parentDOMNode`);
    }
    const {
      left: parentLeft,
      top: parentTop
    } = parentDOMNode.getBoundingClientRect();
    const rects = createRectsFromDOMRange2(editor, range);
    if (!wrapperNode.isConnected) {
      prependDOMNode(parentDOMNode, wrapperNode);
    }
    let hasRepositioned = false;
    for (let i2 = 0; i2 < rects.length; i2++) {
      const rect = rects[i2];
      const rectNode = lastNodes[i2] || document.createElement("div");
      const rectNodeStyle = rectNode.style;
      if (rectNodeStyle.position !== "absolute") {
        rectNodeStyle.position = "absolute";
        hasRepositioned = true;
      }
      const left = px(rect.left - parentLeft);
      if (rectNodeStyle.left !== left) {
        rectNodeStyle.left = left;
        hasRepositioned = true;
      }
      const top = px(rect.top - parentTop);
      if (rectNodeStyle.top !== top) {
        rectNode.style.top = top;
        hasRepositioned = true;
      }
      const width = px(rect.width);
      if (rectNodeStyle.width !== width) {
        rectNode.style.width = width;
        hasRepositioned = true;
      }
      const height = px(rect.height);
      if (rectNodeStyle.height !== height) {
        rectNode.style.height = height;
        hasRepositioned = true;
      }
      if (rectNode.parentNode !== wrapperNode) {
        wrapperNode.append(rectNode);
        hasRepositioned = true;
      }
      lastNodes[i2] = rectNode;
    }
    while (lastNodes.length > rects.length) {
      lastNodes.pop();
    }
    if (hasRepositioned) {
      onReposition(lastNodes);
    }
  }
  function stop() {
    parentDOMNode = null;
    rootDOMNode = null;
    if (observer !== null) {
      observer.disconnect();
    }
    observer = null;
    wrapperNode.remove();
    for (const node of lastNodes) {
      node.remove();
    }
    lastNodes = [];
  }
  function restart() {
    const currentRootDOMNode = editor.getRootElement();
    if (currentRootDOMNode === null) {
      return stop();
    }
    const currentParentDOMNode = currentRootDOMNode.parentElement;
    if (!isHTMLElement2(currentParentDOMNode)) {
      return stop();
    }
    stop();
    rootDOMNode = currentRootDOMNode;
    parentDOMNode = currentParentDOMNode;
    observer = new MutationObserver((mutations) => {
      const nextRootDOMNode = editor.getRootElement();
      const nextParentDOMNode = nextRootDOMNode && nextRootDOMNode.parentElement;
      if (nextRootDOMNode !== rootDOMNode || nextParentDOMNode !== parentDOMNode) {
        return restart();
      }
      for (const mutation of mutations) {
        if (!wrapperNode.contains(mutation.target)) {
          return position();
        }
      }
    });
    observer.observe(currentParentDOMNode, mutationObserverConfig);
    position();
  }
  const removeRootListener = editor.registerRootListener(restart);
  return () => {
    removeRootListener();
    stop();
  };
}
function $getOrderedSelectionPoints(selection) {
  const points = selection.getStartEndPoints();
  return selection.isBackward() ? [points[1], points[0]] : points;
}
function rangeTargetFromPoint(point, node, dom) {
  if (point.type === "text" || !$isElementNode2(node)) {
    const textDOM = getDOMTextNode2(dom) || dom;
    return [textDOM, point.offset];
  } else {
    const slot = node.getDOMSlot(dom);
    return [slot.element, slot.getFirstChildOffset() + point.offset];
  }
}
function rangeFromPoints(editor, start, startNode, startDOM, end, endNode, endDOM) {
  const editorDocument = editor._window ? editor._window.document : document;
  const range = editorDocument.createRange();
  range.setStart(...rangeTargetFromPoint(start, startNode, startDOM));
  range.setEnd(...rangeTargetFromPoint(end, endNode, endDOM));
  return range;
}
function markSelection(editor, onReposition) {
  let previousAnchorNode = null;
  let previousAnchorNodeDOM = null;
  let previousAnchorOffset = null;
  let previousFocusNode = null;
  let previousFocusNodeDOM = null;
  let previousFocusOffset = null;
  let removeRangeListener = () => {
  };
  function compute(editorState) {
    editorState.read(() => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection)) {
        previousAnchorNode = null;
        previousAnchorOffset = null;
        previousFocusNode = null;
        previousFocusOffset = null;
        removeRangeListener();
        removeRangeListener = () => {
        };
        return;
      }
      const [start, end] = $getOrderedSelectionPoints(selection);
      const currentStartNode = start.getNode();
      const currentStartNodeKey = currentStartNode.getKey();
      const currentStartOffset = start.offset;
      const currentEndNode = end.getNode();
      const currentEndNodeKey = currentEndNode.getKey();
      const currentEndOffset = end.offset;
      const currentStartNodeDOM = editor.getElementByKey(currentStartNodeKey);
      const currentEndNodeDOM = editor.getElementByKey(currentEndNodeKey);
      const differentStartDOM = previousAnchorNode === null || currentStartNodeDOM !== previousAnchorNodeDOM || currentStartOffset !== previousAnchorOffset || currentStartNodeKey !== previousAnchorNode.getKey();
      const differentEndDOM = previousFocusNode === null || currentEndNodeDOM !== previousFocusNodeDOM || currentEndOffset !== previousFocusOffset || currentEndNodeKey !== previousFocusNode.getKey();
      if ((differentStartDOM || differentEndDOM) && currentStartNodeDOM !== null && currentEndNodeDOM !== null) {
        const range = rangeFromPoints(editor, start, currentStartNode, currentStartNodeDOM, end, currentEndNode, currentEndNodeDOM);
        removeRangeListener();
        removeRangeListener = mlcPositionNodeOnRange(editor, range, (domNodes) => {
          if (onReposition === void 0) {
            for (const domNode of domNodes) {
              const domNodeStyle = domNode.style;
              if (domNodeStyle.background !== "Highlight") {
                domNodeStyle.background = "Highlight";
              }
              if (domNodeStyle.color !== "HighlightText") {
                domNodeStyle.color = "HighlightText";
              }
              if (domNodeStyle.marginTop !== px(-1.5)) {
                domNodeStyle.marginTop = px(-1.5);
              }
              if (domNodeStyle.paddingTop !== px(4)) {
                domNodeStyle.paddingTop = px(4);
              }
              if (domNodeStyle.paddingBottom !== px(0)) {
                domNodeStyle.paddingBottom = px(0);
              }
            }
          } else {
            onReposition(domNodes);
          }
        });
      }
      previousAnchorNode = currentStartNode;
      previousAnchorNodeDOM = currentStartNodeDOM;
      previousAnchorOffset = currentStartOffset;
      previousFocusNode = currentEndNode;
      previousFocusNodeDOM = currentEndNodeDOM;
      previousFocusOffset = currentEndOffset;
    });
  }
  compute(editor.getEditorState());
  return mergeRegister(editor.registerUpdateListener(({
    editorState
  }) => compute(editorState)), () => {
    removeRangeListener();
  });
}
function selectionAlwaysOnDisplay(editor) {
  let removeSelectionMark = null;
  const onSelectionChange2 = () => {
    const domSelection = getSelection();
    const domAnchorNode = domSelection && domSelection.anchorNode;
    const editorRootElement = editor.getRootElement();
    const isSelectionInsideEditor = domAnchorNode !== null && editorRootElement !== null && editorRootElement.contains(domAnchorNode);
    if (isSelectionInsideEditor) {
      if (removeSelectionMark !== null) {
        removeSelectionMark();
        removeSelectionMark = null;
      }
    } else {
      if (removeSelectionMark === null) {
        removeSelectionMark = markSelection(editor);
      }
    }
  };
  document.addEventListener("selectionchange", onSelectionChange2);
  return () => {
    if (removeSelectionMark !== null) {
      removeSelectionMark();
    }
    document.removeEventListener("selectionchange", onSelectionChange2);
  };
}
var CAN_USE_BEFORE_INPUT2 = CAN_USE_BEFORE_INPUT$1;
var CAN_USE_DOM2 = CAN_USE_DOM$1;
var IS_ANDROID2 = IS_ANDROID$1;
var IS_ANDROID_CHROME2 = IS_ANDROID_CHROME$1;
var IS_APPLE2 = IS_APPLE$1;
var IS_APPLE_WEBKIT2 = IS_APPLE_WEBKIT$1;
var IS_CHROME2 = IS_CHROME$1;
var IS_FIREFOX2 = IS_FIREFOX$1;
var IS_IOS2 = IS_IOS$1;
var IS_SAFARI2 = IS_SAFARI$1;
function addClassNamesToElement(element, ...classNames) {
  const classesToAdd = normalizeClassNames2(...classNames);
  if (classesToAdd.length > 0) {
    element.classList.add(...classesToAdd);
  }
}
function removeClassNamesFromElement(element, ...classNames) {
  const classesToRemove = normalizeClassNames2(...classNames);
  if (classesToRemove.length > 0) {
    element.classList.remove(...classesToRemove);
  }
}
function isMimeType(file, acceptableMimeTypes) {
  for (const acceptableType of acceptableMimeTypes) {
    if (file.type.startsWith(acceptableType)) {
      return true;
    }
  }
  return false;
}
function mediaFileReader(files, acceptableMimeTypes) {
  const filesIterator = files[Symbol.iterator]();
  return new Promise((resolve, reject) => {
    const processed = [];
    const handleNextFile = () => {
      const {
        done,
        value: file
      } = filesIterator.next();
      if (done) {
        return resolve(processed);
      }
      const fileReader = new FileReader();
      fileReader.addEventListener("error", reject);
      fileReader.addEventListener("load", () => {
        const result = fileReader.result;
        if (typeof result === "string") {
          processed.push({
            file,
            result
          });
        }
        handleNextFile();
      });
      if (isMimeType(file, acceptableMimeTypes)) {
        fileReader.readAsDataURL(file);
      } else {
        handleNextFile();
      }
    };
    handleNextFile();
  });
}
function $dfs(startNode, endNode) {
  return Array.from($dfsIterator(startNode, endNode));
}
function $getAdjacentCaret(caret) {
  return caret ? caret.getAdjacentCaret() : null;
}
function $reverseDfs(startNode, endNode) {
  return Array.from($reverseDfsIterator(startNode, endNode));
}
function $dfsIterator(startNode, endNode) {
  return $dfsCaretIterator("next", startNode, endNode);
}
function $getEndCaret(startNode, direction) {
  const rval = $getAdjacentSiblingOrParentSiblingCaret2($getSiblingCaret2(startNode, direction));
  return rval && rval[0];
}
function $dfsCaretIterator(direction, startNode, endNode) {
  const root = $getRoot2();
  const start = startNode || root;
  const startCaret = $isElementNode2(start) ? $getChildCaret2(start, direction) : $getSiblingCaret2(start, direction);
  const startDepth = $getDepth(start);
  const endCaret = endNode ? $getAdjacentChildCaret2($getChildCaretOrSelf2($getSiblingCaret2(endNode, direction))) || $getEndCaret(endNode, direction) : $getEndCaret(start, direction);
  let depth = startDepth;
  return makeStepwiseIterator2({
    hasNext: (state) => state !== null,
    initial: startCaret,
    map: (state) => ({
      depth,
      node: state.origin
    }),
    step: (state) => {
      if (state.isSameNodeCaret(endCaret)) {
        return null;
      }
      if ($isChildCaret2(state)) {
        depth++;
      }
      const rval = $getAdjacentSiblingOrParentSiblingCaret2(state);
      if (!rval || rval[0].isSameNodeCaret(endCaret)) {
        return null;
      }
      depth += rval[1];
      return rval[0];
    }
  });
}
function $getNextSiblingOrParentSibling(node) {
  const rval = $getAdjacentSiblingOrParentSiblingCaret2($getSiblingCaret2(node, "next"));
  return rval && [rval[0].origin, rval[1]];
}
function $getDepth(node) {
  let depth = -1;
  for (let innerNode = node; innerNode !== null; innerNode = innerNode.getParent()) {
    depth++;
  }
  return depth;
}
function $getNextRightPreorderNode(startingNode) {
  const startCaret = $getChildCaretOrSelf2($getSiblingCaret2(startingNode, "previous"));
  const next = $getAdjacentSiblingOrParentSiblingCaret2(startCaret, "root");
  return next && next[0].origin;
}
function $reverseDfsIterator(startNode, endNode) {
  return $dfsCaretIterator("previous", startNode, endNode);
}
function $getNearestNodeOfType(node, klass) {
  let parent = node;
  while (parent != null) {
    if (parent instanceof klass) {
      return parent;
    }
    parent = parent.getParent();
  }
  return null;
}
function $getNearestBlockElementAncestorOrThrow(startNode) {
  const blockNode = $findMatchingParent2(startNode, (node) => $isElementNode2(node) && !node.isInline());
  if (!$isElementNode2(blockNode)) {
    {
      formatDevErrorMessage3(`Expected node ${startNode.__key} to have closest block element node.`);
    }
  }
  return blockNode;
}
function registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {
  const $isTargetNode = (node) => {
    return node instanceof targetNode;
  };
  const $findMatch = (node) => {
    const children = node.getChildren();
    for (let i2 = 0; i2 < children.length; i2++) {
      const child = children[i2];
      if ($isTargetNode(child)) {
        return null;
      }
    }
    let parentNode = node;
    let childNode = node;
    while (parentNode !== null) {
      childNode = parentNode;
      parentNode = parentNode.getParent();
      if ($isTargetNode(parentNode)) {
        return {
          child: childNode,
          parent: parentNode
        };
      }
    }
    return null;
  };
  const $elementNodeTransform = (node) => {
    const match = $findMatch(node);
    if (match !== null) {
      const {
        child,
        parent
      } = match;
      if (child.is(node)) {
        handleOverlap(parent, node);
        const nextSiblings = child.getNextSiblings();
        const nextSiblingsLength = nextSiblings.length;
        parent.insertAfter(child);
        if (nextSiblingsLength !== 0) {
          const newParent = cloneNode(parent);
          child.insertAfter(newParent);
          for (let i2 = 0; i2 < nextSiblingsLength; i2++) {
            newParent.append(nextSiblings[i2]);
          }
        }
        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {
          parent.remove();
        }
      }
    }
  };
  return editor.registerNodeTransform(targetNode, $elementNodeTransform);
}
function $restoreEditorState(editor, editorState) {
  const FULL_RECONCILE2 = 2;
  const nodeMap = /* @__PURE__ */ new Map();
  const activeEditorState2 = editor._pendingEditorState;
  for (const [key, node] of editorState._nodeMap) {
    nodeMap.set(key, $cloneWithProperties2(node));
  }
  if (activeEditorState2) {
    activeEditorState2._nodeMap = nodeMap;
  }
  editor._dirtyType = FULL_RECONCILE2;
  const selection = editorState._selection;
  $setSelection2(selection === null ? null : selection.clone());
}
function $insertNodeToNearestRoot(node) {
  const selection = $getSelection2() || $getPreviousSelection2();
  let initialCaret;
  if ($isRangeSelection2(selection)) {
    initialCaret = $caretFromPoint2(selection.focus, "next");
  } else {
    if (selection != null) {
      const nodes = selection.getNodes();
      const lastNode = nodes[nodes.length - 1];
      if (lastNode) {
        initialCaret = $getSiblingCaret2(lastNode, "next");
      }
    }
    initialCaret = initialCaret || $getChildCaret2($getRoot2(), "previous").getFlipped().insert($createParagraphNode2());
  }
  const insertCaret = $insertNodeToNearestRootAtCaret(node, initialCaret);
  const adjacent = $getAdjacentChildCaret2(insertCaret);
  const selectionCaret = $isChildCaret2(adjacent) ? $normalizeCaret2(adjacent) : insertCaret;
  $setSelectionFromCaretRange2($getCollapsedCaretRange2(selectionCaret));
  return node.getLatest();
}
function $insertNodeToNearestRootAtCaret(node, caret, options) {
  let insertCaret = $getCaretInDirection2(caret, "next");
  for (let nextCaret = insertCaret; nextCaret; nextCaret = $splitAtPointCaretNext2(nextCaret, options)) {
    insertCaret = nextCaret;
  }
  if (!!$isTextPointCaret2(insertCaret)) {
    formatDevErrorMessage3(`$insertNodeToNearestRootAtCaret: An unattached TextNode can not be split`);
  }
  insertCaret.insert(node.isInline() ? $createParagraphNode2().append(node) : node);
  return $getCaretInDirection2($getSiblingCaret2(node.getLatest(), "next"), caret.direction);
}
function $wrapNodeInElement(node, createElementNode) {
  const elementNode = createElementNode();
  node.replace(elementNode);
  elementNode.append(node);
  return elementNode;
}
function objectKlassEquals(object, objectClass) {
  return object !== null ? Object.getPrototypeOf(object).constructor.name === objectClass.name : false;
}
function $filter(nodes, filterFn) {
  const result = [];
  for (let i2 = 0; i2 < nodes.length; i2++) {
    const node = filterFn(nodes[i2]);
    if (node !== null) {
      result.push(node);
    }
  }
  return result;
}
function $insertFirst(parent, node) {
  $getChildCaret2(parent, "next").insert(node);
}
var NEEDS_MANUAL_ZOOM = IS_FIREFOX2 || !CAN_USE_DOM2 ? false : void 0;
function needsManualZoom() {
  if (NEEDS_MANUAL_ZOOM === void 0) {
    const div = document.createElement("div");
    div.style.cssText = "position: absolute; opacity: 0; width: 100px; left: -1000px;";
    document.body.appendChild(div);
    const noZoom = div.getBoundingClientRect();
    div.style.setProperty("zoom", "2");
    NEEDS_MANUAL_ZOOM = div.getBoundingClientRect().width === noZoom.width;
    document.body.removeChild(div);
  }
  return NEEDS_MANUAL_ZOOM;
}
function calculateZoomLevel(element) {
  let zoom = 1;
  if (needsManualZoom()) {
    while (element) {
      zoom *= Number(window.getComputedStyle(element).getPropertyValue("zoom"));
      element = element.parentElement;
    }
  }
  return zoom;
}
function $isEditorIsNestedEditor(editor) {
  return editor._parentEditor !== null;
}
function $unwrapAndFilterDescendants(root, $predicate) {
  return $unwrapAndFilterDescendantsImpl(root, $predicate, null);
}
function $unwrapAndFilterDescendantsImpl(root, $predicate, $onSuccess) {
  let didMutate = false;
  for (const node of $lastToFirstIterator(root)) {
    if ($predicate(node)) {
      if ($onSuccess !== null) {
        $onSuccess(node);
      }
      continue;
    }
    didMutate = true;
    if ($isElementNode2(node)) {
      $unwrapAndFilterDescendantsImpl(node, $predicate, $onSuccess || ((child) => node.insertAfter(child)));
    }
    node.remove();
  }
  return didMutate;
}
function $descendantsMatching(children, $predicate) {
  const result = [];
  const stack = Array.from(children).reverse();
  for (let child = stack.pop(); child !== void 0; child = stack.pop()) {
    if ($predicate(child)) {
      result.push(child);
    } else if ($isElementNode2(child)) {
      for (const grandchild of $lastToFirstIterator(child)) {
        stack.push(grandchild);
      }
    }
  }
  return result;
}
function $firstToLastIterator(node) {
  return $childIterator($getChildCaret2(node, "next"));
}
function $lastToFirstIterator(node) {
  return $childIterator($getChildCaret2(node, "previous"));
}
function $childIterator(startCaret) {
  const seen = /* @__PURE__ */ new Set();
  return makeStepwiseIterator2({
    hasNext: $isSiblingCaret2,
    initial: startCaret.getAdjacentCaret(),
    map: (caret) => {
      const origin = caret.origin.getLatest();
      if (seen !== null) {
        const key = origin.getKey();
        if (!!seen.has(key)) {
          formatDevErrorMessage3(`$childIterator: Cycle detected, node with key ${String(key)} has already been traversed`);
        }
        seen.add(key);
      }
      return origin;
    },
    step: (caret) => caret.getAdjacentCaret()
  });
}
function $unwrapNode(node) {
  $rewindSiblingCaret2($getSiblingCaret2(node, "next")).splice(1, node.getChildren());
}
function makeStateWrapper(stateConfig) {
  const $get = (node) => $getState2(node, stateConfig);
  const $set = (node, valueOrUpdater) => $setState2(node, stateConfig, valueOrUpdater);
  return {
    $get,
    $set,
    accessors: [$get, $set],
    makeGetterMethod: () => function $getter() {
      return $get(this);
    },
    makeSetterMethod: () => function $setter(valueOrUpdater) {
      return $set(this, valueOrUpdater);
    },
    stateConfig
  };
}

// node_modules/@lexical/utils/LexicalUtils.mjs
var mod3 = true ? LexicalUtils_dev_exports : LexicalUtils_prod_exports;
var $descendantsMatching2 = mod3.$descendantsMatching;
var $dfs2 = mod3.$dfs;
var $dfsIterator2 = mod3.$dfsIterator;
var $filter2 = mod3.$filter;
var $findMatchingParent3 = mod3.$findMatchingParent;
var $firstToLastIterator2 = mod3.$firstToLastIterator;
var $getAdjacentCaret2 = mod3.$getAdjacentCaret;
var $getAdjacentSiblingOrParentSiblingCaret3 = mod3.$getAdjacentSiblingOrParentSiblingCaret;
var $getDepth2 = mod3.$getDepth;
var $getNearestBlockElementAncestorOrThrow2 = mod3.$getNearestBlockElementAncestorOrThrow;
var $getNearestNodeOfType2 = mod3.$getNearestNodeOfType;
var $getNextRightPreorderNode2 = mod3.$getNextRightPreorderNode;
var $getNextSiblingOrParentSibling2 = mod3.$getNextSiblingOrParentSibling;
var $insertFirst2 = mod3.$insertFirst;
var $insertNodeToNearestRoot2 = mod3.$insertNodeToNearestRoot;
var $insertNodeToNearestRootAtCaret2 = mod3.$insertNodeToNearestRootAtCaret;
var $isEditorIsNestedEditor2 = mod3.$isEditorIsNestedEditor;
var $lastToFirstIterator2 = mod3.$lastToFirstIterator;
var $restoreEditorState2 = mod3.$restoreEditorState;
var $reverseDfs2 = mod3.$reverseDfs;
var $reverseDfsIterator2 = mod3.$reverseDfsIterator;
var $splitNode3 = mod3.$splitNode;
var $unwrapAndFilterDescendants2 = mod3.$unwrapAndFilterDescendants;
var $unwrapNode2 = mod3.$unwrapNode;
var $wrapNodeInElement2 = mod3.$wrapNodeInElement;
var CAN_USE_BEFORE_INPUT3 = mod3.CAN_USE_BEFORE_INPUT;
var CAN_USE_DOM3 = mod3.CAN_USE_DOM;
var IS_ANDROID3 = mod3.IS_ANDROID;
var IS_ANDROID_CHROME3 = mod3.IS_ANDROID_CHROME;
var IS_APPLE3 = mod3.IS_APPLE;
var IS_APPLE_WEBKIT3 = mod3.IS_APPLE_WEBKIT;
var IS_CHROME3 = mod3.IS_CHROME;
var IS_FIREFOX3 = mod3.IS_FIREFOX;
var IS_IOS3 = mod3.IS_IOS;
var IS_SAFARI3 = mod3.IS_SAFARI;
var addClassNamesToElement2 = mod3.addClassNamesToElement;
var calculateZoomLevel2 = mod3.calculateZoomLevel;
var isBlockDomNode3 = mod3.isBlockDomNode;
var isHTMLAnchorElement3 = mod3.isHTMLAnchorElement;
var isHTMLElement3 = mod3.isHTMLElement;
var isInlineDomNode3 = mod3.isInlineDomNode;
var isMimeType2 = mod3.isMimeType;
var makeStateWrapper2 = mod3.makeStateWrapper;
var markSelection2 = mod3.markSelection;
var mediaFileReader2 = mod3.mediaFileReader;
var mergeRegister2 = mod3.mergeRegister;
var objectKlassEquals2 = mod3.objectKlassEquals;
var positionNodeOnRange = mod3.positionNodeOnRange;
var registerNestedElementResolver2 = mod3.registerNestedElementResolver;
var removeClassNamesFromElement2 = mod3.removeClassNamesFromElement;
var selectionAlwaysOnDisplay2 = mod3.selectionAlwaysOnDisplay;

// node_modules/@lexical/html/LexicalHtml.dev.mjs
function $generateNodesFromDOM(editor, dom) {
  const elements = isDOMDocumentNode2(dom) ? dom.body.childNodes : dom.childNodes;
  let lexicalNodes = [];
  const allArtificialNodes = [];
  for (const element of elements) {
    if (!IGNORE_TAGS.has(element.nodeName)) {
      const lexicalNode = $createNodesFromDOM(element, editor, allArtificialNodes, false);
      if (lexicalNode !== null) {
        lexicalNodes = lexicalNodes.concat(lexicalNode);
      }
    }
  }
  $unwrapArtificialNodes(allArtificialNodes);
  return lexicalNodes;
}
function $generateHtmlFromNodes(editor, selection) {
  if (typeof document === "undefined" || typeof window === "undefined" && typeof global.window === "undefined") {
    throw new Error("To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.");
  }
  const container = document.createElement("div");
  const root = $getRoot2();
  const topLevelChildren = root.getChildren();
  for (let i2 = 0; i2 < topLevelChildren.length; i2++) {
    const topLevelNode = topLevelChildren[i2];
    $appendNodesToHTML(editor, topLevelNode, container, selection);
  }
  return container.innerHTML;
}
function $appendNodesToHTML(editor, currentNode, parentElement, selection = null) {
  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;
  const shouldExclude = $isElementNode2(currentNode) && currentNode.excludeFromCopy("html");
  let target = currentNode;
  if (selection !== null && $isTextNode2(currentNode)) {
    target = $sliceSelectedTextNodeContent2(selection, currentNode, "clone");
  }
  const children = $isElementNode2(target) ? target.getChildren() : [];
  const registeredNode = getRegisteredNode2(editor, target.getType());
  let exportOutput;
  if (registeredNode && registeredNode.exportDOM !== void 0) {
    exportOutput = registeredNode.exportDOM(editor, target);
  } else {
    exportOutput = target.exportDOM(editor);
  }
  const {
    element,
    after
  } = exportOutput;
  if (!element) {
    return false;
  }
  const fragment = document.createDocumentFragment();
  for (let i2 = 0; i2 < children.length; i2++) {
    const childNode = children[i2];
    const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection);
    if (!shouldInclude && $isElementNode2(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, "html")) {
      shouldInclude = true;
    }
  }
  if (shouldInclude && !shouldExclude) {
    if (isHTMLElement3(element) || isDocumentFragment2(element)) {
      element.append(fragment);
    }
    parentElement.append(element);
    if (after) {
      const newElement = after.call(target, element);
      if (newElement) {
        if (isDocumentFragment2(element)) {
          element.replaceChildren(newElement);
        } else {
          element.replaceWith(newElement);
        }
      }
    }
  } else {
    parentElement.append(fragment);
  }
  return shouldInclude;
}
function getConversionFunction(domNode, editor) {
  const {
    nodeName
  } = domNode;
  const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());
  let currentConversion = null;
  if (cachedConversions !== void 0) {
    for (const cachedConversion of cachedConversions) {
      const domConversion = cachedConversion(domNode);
      if (domConversion !== null && (currentConversion === null || // Given equal priority, prefer the last registered importer
      // which is typically an application custom node or HTMLConfig['import']
      (currentConversion.priority || 0) <= (domConversion.priority || 0))) {
        currentConversion = domConversion;
      }
    }
  }
  return currentConversion !== null ? currentConversion.conversion : null;
}
var IGNORE_TAGS = /* @__PURE__ */ new Set(["STYLE", "SCRIPT"]);
function $createNodesFromDOM(node, editor, allArtificialNodes, hasBlockAncestorLexicalNode, forChildMap = /* @__PURE__ */ new Map(), parentLexicalNode) {
  let lexicalNodes = [];
  if (IGNORE_TAGS.has(node.nodeName)) {
    return lexicalNodes;
  }
  let currentLexicalNode = null;
  const transformFunction = getConversionFunction(node, editor);
  const transformOutput = transformFunction ? transformFunction(node) : null;
  let postTransform = null;
  if (transformOutput !== null) {
    postTransform = transformOutput.after;
    const transformNodes = transformOutput.node;
    currentLexicalNode = Array.isArray(transformNodes) ? transformNodes[transformNodes.length - 1] : transformNodes;
    if (currentLexicalNode !== null) {
      for (const [, forChildFunction] of forChildMap) {
        currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);
        if (!currentLexicalNode) {
          break;
        }
      }
      if (currentLexicalNode) {
        lexicalNodes.push(...Array.isArray(transformNodes) ? transformNodes : [currentLexicalNode]);
      }
    }
    if (transformOutput.forChild != null) {
      forChildMap.set(node.nodeName, transformOutput.forChild);
    }
  }
  const children = node.childNodes;
  let childLexicalNodes = [];
  const hasBlockAncestorLexicalNodeForChildren = currentLexicalNode != null && $isRootOrShadowRoot2(currentLexicalNode) ? false : currentLexicalNode != null && $isBlockElementNode2(currentLexicalNode) || hasBlockAncestorLexicalNode;
  for (let i2 = 0; i2 < children.length; i2++) {
    childLexicalNodes.push(...$createNodesFromDOM(children[i2], editor, allArtificialNodes, hasBlockAncestorLexicalNodeForChildren, new Map(forChildMap), currentLexicalNode));
  }
  if (postTransform != null) {
    childLexicalNodes = postTransform(childLexicalNodes);
  }
  if (isBlockDomNode3(node)) {
    if (!hasBlockAncestorLexicalNodeForChildren) {
      childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, $createParagraphNode2);
    } else {
      childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, () => {
        const artificialNode = new ArtificialNode__DO_NOT_USE2();
        allArtificialNodes.push(artificialNode);
        return artificialNode;
      });
    }
  }
  if (currentLexicalNode == null) {
    if (childLexicalNodes.length > 0) {
      lexicalNodes = lexicalNodes.concat(childLexicalNodes);
    } else {
      if (isBlockDomNode3(node) && isDomNodeBetweenTwoInlineNodes(node)) {
        lexicalNodes = lexicalNodes.concat($createLineBreakNode2());
      }
    }
  } else {
    if ($isElementNode2(currentLexicalNode)) {
      currentLexicalNode.append(...childLexicalNodes);
    }
  }
  return lexicalNodes;
}
function wrapContinuousInlines(domNode, nodes, createWrapperFn) {
  const textAlign = domNode.style.textAlign;
  const out = [];
  let continuousInlines = [];
  for (let i2 = 0; i2 < nodes.length; i2++) {
    const node = nodes[i2];
    if ($isBlockElementNode2(node)) {
      if (textAlign && !node.getFormat()) {
        node.setFormat(textAlign);
      }
      out.push(node);
    } else {
      continuousInlines.push(node);
      if (i2 === nodes.length - 1 || i2 < nodes.length - 1 && $isBlockElementNode2(nodes[i2 + 1])) {
        const wrapper = createWrapperFn();
        wrapper.setFormat(textAlign);
        wrapper.append(...continuousInlines);
        out.push(wrapper);
        continuousInlines = [];
      }
    }
  }
  return out;
}
function $unwrapArtificialNodes(allArtificialNodes) {
  for (const node of allArtificialNodes) {
    if (node.getNextSibling() instanceof ArtificialNode__DO_NOT_USE2) {
      node.insertAfter($createLineBreakNode2());
    }
  }
  for (const node of allArtificialNodes) {
    const children = node.getChildren();
    for (const child of children) {
      node.insertBefore(child);
    }
    node.remove();
  }
}
function isDomNodeBetweenTwoInlineNodes(node) {
  if (node.nextSibling == null || node.previousSibling == null) {
    return false;
  }
  return isInlineDomNode2(node.nextSibling) && isInlineDomNode2(node.previousSibling);
}

// node_modules/@lexical/html/LexicalHtml.mjs
var mod4 = true ? LexicalHtml_dev_exports : LexicalHtml_prod_exports;
var $generateHtmlFromNodes2 = mod4.$generateHtmlFromNodes;
var $generateNodesFromDOM2 = mod4.$generateNodesFromDOM;

// node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs
function formatDevErrorMessage4(message) {
  throw new Error(message);
}
function $getHtmlContent(editor, selection = $getSelection2()) {
  if (selection == null) {
    {
      formatDevErrorMessage4(`Expected valid LexicalSelection`);
    }
  }
  if ($isRangeSelection2(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {
    return "";
  }
  return $generateHtmlFromNodes2(editor, selection);
}
function $getLexicalContent(editor, selection = $getSelection2()) {
  if (selection == null) {
    {
      formatDevErrorMessage4(`Expected valid LexicalSelection`);
    }
  }
  if ($isRangeSelection2(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {
    return null;
  }
  return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));
}
function $insertDataTransferForPlainText(dataTransfer, selection) {
  const text = dataTransfer.getData("text/plain") || dataTransfer.getData("text/uri-list");
  if (text != null) {
    selection.insertRawText(text);
  }
}
function $insertDataTransferForRichText(dataTransfer, selection, editor) {
  const lexicalString = dataTransfer.getData("application/x-lexical-editor");
  if (lexicalString) {
    try {
      const payload = JSON.parse(lexicalString);
      if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {
        const nodes = $generateNodesFromSerializedNodes(payload.nodes);
        return $insertGeneratedNodes(editor, nodes, selection);
      }
    } catch (error) {
      console.error(error);
    }
  }
  const htmlString = dataTransfer.getData("text/html");
  const plainString = dataTransfer.getData("text/plain");
  if (htmlString && plainString !== htmlString) {
    try {
      const parser = new DOMParser();
      const dom = parser.parseFromString(trustHTML(htmlString), "text/html");
      const nodes = $generateNodesFromDOM2(editor, dom);
      return $insertGeneratedNodes(editor, nodes, selection);
    } catch (error) {
      console.error(error);
    }
  }
  const text = plainString || dataTransfer.getData("text/uri-list");
  if (text != null) {
    if ($isRangeSelection2(selection)) {
      const parts = text.split(/(\r?\n|\t)/);
      if (parts[parts.length - 1] === "") {
        parts.pop();
      }
      for (let i2 = 0; i2 < parts.length; i2++) {
        const currentSelection = $getSelection2();
        if ($isRangeSelection2(currentSelection)) {
          const part = parts[i2];
          if (part === "\n" || part === "\r\n") {
            currentSelection.insertParagraph();
          } else if (part === "	") {
            currentSelection.insertNodes([$createTabNode2()]);
          } else {
            currentSelection.insertText(part);
          }
        }
      }
    } else {
      selection.insertRawText(text);
    }
  }
}
function trustHTML(html) {
  if (window.trustedTypes && window.trustedTypes.createPolicy) {
    const policy = window.trustedTypes.createPolicy("lexical", {
      createHTML: (input) => input
    });
    return policy.createHTML(html);
  }
  return html;
}
function $insertGeneratedNodes(editor, nodes, selection) {
  if (!editor.dispatchCommand(SELECTION_INSERT_CLIPBOARD_NODES_COMMAND2, {
    nodes,
    selection
  })) {
    selection.insertNodes(nodes);
    $updateSelectionOnInsert(selection);
  }
  return;
}
function $updateSelectionOnInsert(selection) {
  if ($isRangeSelection2(selection) && selection.isCollapsed()) {
    const anchor = selection.anchor;
    let nodeToInspect = null;
    const anchorCaret = $caretFromPoint2(anchor, "previous");
    if (anchorCaret) {
      if ($isTextPointCaret2(anchorCaret)) {
        nodeToInspect = anchorCaret.origin;
      } else {
        const range = $getCaretRange2(anchorCaret, $getChildCaret2($getRoot2(), "next").getFlipped());
        for (const caret of range) {
          if ($isTextNode2(caret.origin)) {
            nodeToInspect = caret.origin;
            break;
          } else if ($isElementNode2(caret.origin) && !caret.origin.isInline()) {
            break;
          }
        }
      }
    }
    if (nodeToInspect && $isTextNode2(nodeToInspect)) {
      const newFormat = nodeToInspect.getFormat();
      const newStyle = nodeToInspect.getStyle();
      if (selection.format !== newFormat || selection.style !== newStyle) {
        selection.format = newFormat;
        selection.style = newStyle;
        selection.dirty = true;
      }
    }
  }
}
function exportNodeToJSON2(node) {
  const serializedNode = node.exportJSON();
  const nodeClass = node.constructor;
  if (serializedNode.type !== nodeClass.getType()) {
    {
      formatDevErrorMessage4(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);
    }
  }
  if ($isElementNode2(node)) {
    const serializedChildren = serializedNode.children;
    if (!Array.isArray(serializedChildren)) {
      {
        formatDevErrorMessage4(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);
      }
    }
  }
  return serializedNode;
}
function $appendNodesToJSON(editor, selection, currentNode, targetArray = []) {
  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;
  const shouldExclude = $isElementNode2(currentNode) && currentNode.excludeFromCopy("html");
  let target = currentNode;
  if (selection !== null && $isTextNode2(target)) {
    target = $sliceSelectedTextNodeContent2(selection, target, "clone");
  }
  const children = $isElementNode2(target) ? target.getChildren() : [];
  const serializedNode = exportNodeToJSON2(target);
  if ($isTextNode2(target) && target.getTextContentSize() === 0) {
    shouldInclude = false;
  }
  for (let i2 = 0; i2 < children.length; i2++) {
    const childNode = children[i2];
    const shouldIncludeChild = $appendNodesToJSON(editor, selection, childNode, serializedNode.children);
    if (!shouldInclude && $isElementNode2(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, "clone")) {
      shouldInclude = true;
    }
  }
  if (shouldInclude && !shouldExclude) {
    targetArray.push(serializedNode);
  } else if (Array.isArray(serializedNode.children)) {
    for (let i2 = 0; i2 < serializedNode.children.length; i2++) {
      const serializedChildNode = serializedNode.children[i2];
      targetArray.push(serializedChildNode);
    }
  }
  return shouldInclude;
}
function $generateJSONFromSelectedNodes(editor, selection) {
  const nodes = [];
  const root = $getRoot2();
  const topLevelChildren = root.getChildren();
  for (let i2 = 0; i2 < topLevelChildren.length; i2++) {
    const topLevelNode = topLevelChildren[i2];
    $appendNodesToJSON(editor, selection, topLevelNode, nodes);
  }
  return {
    namespace: editor._config.namespace,
    nodes
  };
}
function $generateNodesFromSerializedNodes(serializedNodes) {
  const nodes = [];
  for (let i2 = 0; i2 < serializedNodes.length; i2++) {
    const serializedNode = serializedNodes[i2];
    const node = $parseSerializedNode2(serializedNode);
    if ($isTextNode2(node)) {
      $addNodeStyle2(node);
    }
    nodes.push(node);
  }
  return nodes;
}
var EVENT_LATENCY = 50;
var clipboardEventTimeout = null;
async function copyToClipboard(editor, event, data) {
  if (clipboardEventTimeout !== null) {
    return false;
  }
  if (event !== null) {
    return new Promise((resolve, reject) => {
      editor.update(() => {
        resolve($copyToClipboardEvent(editor, event, data));
      });
    });
  }
  const rootElement = editor.getRootElement();
  const editorWindow = editor._window || window;
  const windowDocument = editorWindow.document;
  const domSelection = getDOMSelection2(editorWindow);
  if (rootElement === null || domSelection === null) {
    return false;
  }
  const element = windowDocument.createElement("span");
  element.style.cssText = "position: fixed; top: -1000px;";
  element.append(windowDocument.createTextNode("#"));
  rootElement.append(element);
  const range = new Range();
  range.setStart(element, 0);
  range.setEnd(element, 1);
  domSelection.removeAllRanges();
  domSelection.addRange(range);
  return new Promise((resolve, reject) => {
    const removeListener = editor.registerCommand(COPY_COMMAND2, (secondEvent) => {
      if (objectKlassEquals2(secondEvent, ClipboardEvent)) {
        removeListener();
        if (clipboardEventTimeout !== null) {
          editorWindow.clearTimeout(clipboardEventTimeout);
          clipboardEventTimeout = null;
        }
        resolve($copyToClipboardEvent(editor, secondEvent, data));
      }
      return true;
    }, COMMAND_PRIORITY_CRITICAL2);
    clipboardEventTimeout = editorWindow.setTimeout(() => {
      removeListener();
      clipboardEventTimeout = null;
      resolve(false);
    }, EVENT_LATENCY);
    windowDocument.execCommand("copy");
    element.remove();
  });
}
function $copyToClipboardEvent(editor, event, data) {
  if (data === void 0) {
    const domSelection = getDOMSelection2(editor._window);
    const selection = $getSelection2();
    if (!selection || selection.isCollapsed()) {
      return false;
    }
    if (!domSelection) {
      return false;
    }
    const anchorDOM = domSelection.anchorNode;
    const focusDOM = domSelection.focusNode;
    if (anchorDOM !== null && focusDOM !== null && !isSelectionWithinEditor2(editor, anchorDOM, focusDOM)) {
      return false;
    }
    data = $getClipboardDataFromSelection(selection);
  }
  event.preventDefault();
  const clipboardData = event.clipboardData;
  if (clipboardData === null) {
    return false;
  }
  setLexicalClipboardDataTransfer(clipboardData, data);
  return true;
}
var clipboardDataFunctions = [["text/html", $getHtmlContent], ["application/x-lexical-editor", $getLexicalContent]];
function $getClipboardDataFromSelection(selection = $getSelection2()) {
  const clipboardData = {
    "text/plain": selection ? selection.getTextContent() : ""
  };
  if (selection) {
    const editor = $getEditor2();
    for (const [mimeType, $editorFn] of clipboardDataFunctions) {
      const v2 = $editorFn(editor, selection);
      if (v2 !== null) {
        clipboardData[mimeType] = v2;
      }
    }
  }
  return clipboardData;
}
function setLexicalClipboardDataTransfer(clipboardData, data) {
  for (const [k] of clipboardDataFunctions) {
    if (data[k] === void 0) {
      clipboardData.setData(k, "");
    }
  }
  for (const k in data) {
    const v2 = data[k];
    if (v2 !== void 0) {
      clipboardData.setData(k, v2);
    }
  }
}

// node_modules/@lexical/clipboard/LexicalClipboard.mjs
var mod5 = true ? LexicalClipboard_dev_exports : LexicalClipboard_prod_exports;
var $generateJSONFromSelectedNodes2 = mod5.$generateJSONFromSelectedNodes;
var $generateNodesFromSerializedNodes2 = mod5.$generateNodesFromSerializedNodes;
var $getClipboardDataFromSelection2 = mod5.$getClipboardDataFromSelection;
var $getHtmlContent2 = mod5.$getHtmlContent;
var $getLexicalContent2 = mod5.$getLexicalContent;
var $insertDataTransferForPlainText2 = mod5.$insertDataTransferForPlainText;
var $insertDataTransferForRichText2 = mod5.$insertDataTransferForRichText;
var $insertGeneratedNodes2 = mod5.$insertGeneratedNodes;
var copyToClipboard2 = mod5.copyToClipboard;
var setLexicalClipboardDataTransfer2 = mod5.setLexicalClipboardDataTransfer;

// node_modules/@lexical/dragon/LexicalDragon.dev.mjs
var LexicalDragon_dev_exports = {};
__export(LexicalDragon_dev_exports, {
  DragonExtension: () => DragonExtension,
  registerDragonSupport: () => registerDragonSupport
});

// node_modules/@lexical/extension/LexicalExtension.dev.mjs
var LexicalExtension_dev_exports = {};
__export(LexicalExtension_dev_exports, {
  $createHorizontalRuleNode: () => $createHorizontalRuleNode,
  $isHorizontalRuleNode: () => $isHorizontalRuleNode,
  AutoFocusExtension: () => AutoFocusExtension,
  ClearEditorExtension: () => ClearEditorExtension,
  EditorStateExtension: () => EditorStateExtension,
  HorizontalRuleExtension: () => HorizontalRuleExtension,
  HorizontalRuleNode: () => HorizontalRuleNode,
  INSERT_HORIZONTAL_RULE_COMMAND: () => INSERT_HORIZONTAL_RULE_COMMAND,
  InitialStateExtension: () => InitialStateExtension,
  LexicalBuilder: () => LexicalBuilder,
  NodeSelectionExtension: () => NodeSelectionExtension,
  TabIndentationExtension: () => TabIndentationExtension,
  batch: () => o,
  buildEditorFromExtensions: () => buildEditorFromExtensions,
  computed: () => w,
  configExtension: () => configExtension2,
  declarePeerDependency: () => declarePeerDependency2,
  defineExtension: () => defineExtension2,
  effect: () => E,
  getExtensionDependencyFromEditor: () => getExtensionDependencyFromEditor,
  getKnownTypesAndNodes: () => getKnownTypesAndNodes,
  getPeerDependencyFromEditor: () => getPeerDependencyFromEditor,
  getPeerDependencyFromEditorOrThrow: () => getPeerDependencyFromEditorOrThrow,
  namedSignals: () => namedSignals,
  registerClearEditor: () => registerClearEditor,
  registerTabIndentation: () => registerTabIndentation,
  safeCast: () => safeCast2,
  shallowMergeConfig: () => shallowMergeConfig2,
  signal: () => d,
  untracked: () => h,
  watchedSignal: () => watchedSignal
});
var i = Symbol.for("preact-signals");
function t() {
  if (r > 1) {
    r--;
    return;
  }
  let i2, t2 = false;
  while (void 0 !== s) {
    let o2 = s;
    s = void 0;
    f++;
    while (void 0 !== o2) {
      const n2 = o2.o;
      o2.o = void 0;
      o2.f &= -3;
      if (!(8 & o2.f) && v(o2)) try {
        o2.c();
      } catch (o3) {
        if (!t2) {
          i2 = o3;
          t2 = true;
        }
      }
      o2 = n2;
    }
  }
  f = 0;
  r--;
  if (t2) throw i2;
}
function o(i2) {
  if (r > 0) return i2();
  r++;
  try {
    return i2();
  } finally {
    t();
  }
}
var n;
var s;
function h(i2) {
  const t2 = n;
  n = void 0;
  try {
    return i2();
  } finally {
    n = t2;
  }
}
var r = 0;
var f = 0;
var e = 0;
function u(i2) {
  if (void 0 === n) return;
  let t2 = i2.n;
  if (void 0 === t2 || t2.t !== n) {
    t2 = { i: 0, S: i2, p: n.s, n: void 0, t: n, e: void 0, x: void 0, r: t2 };
    if (void 0 !== n.s) n.s.n = t2;
    n.s = t2;
    i2.n = t2;
    if (32 & n.f) i2.S(t2);
    return t2;
  } else if (-1 === t2.i) {
    t2.i = 0;
    if (void 0 !== t2.n) {
      t2.n.p = t2.p;
      if (void 0 !== t2.p) t2.p.n = t2.n;
      t2.p = n.s;
      t2.n = void 0;
      n.s.n = t2;
      n.s = t2;
    }
    return t2;
  }
}
function c(i2, t2) {
  this.v = i2;
  this.i = 0;
  this.n = void 0;
  this.t = void 0;
  this.W = null == t2 ? void 0 : t2.watched;
  this.Z = null == t2 ? void 0 : t2.unwatched;
  this.name = null == t2 ? void 0 : t2.name;
}
c.prototype.brand = i;
c.prototype.h = function() {
  return true;
};
c.prototype.S = function(i2) {
  const t2 = this.t;
  if (t2 !== i2 && void 0 === i2.e) {
    i2.x = t2;
    this.t = i2;
    if (void 0 !== t2) t2.e = i2;
    else h(() => {
      var i3;
      null == (i3 = this.W) || i3.call(this);
    });
  }
};
c.prototype.U = function(i2) {
  if (void 0 !== this.t) {
    const t2 = i2.e, o2 = i2.x;
    if (void 0 !== t2) {
      t2.x = o2;
      i2.e = void 0;
    }
    if (void 0 !== o2) {
      o2.e = t2;
      i2.x = void 0;
    }
    if (i2 === this.t) {
      this.t = o2;
      if (void 0 === o2) h(() => {
        var i3;
        null == (i3 = this.Z) || i3.call(this);
      });
    }
  }
};
c.prototype.subscribe = function(i2) {
  return E(() => {
    const t2 = this.value, o2 = n;
    n = void 0;
    try {
      i2(t2);
    } finally {
      n = o2;
    }
  }, { name: "sub" });
};
c.prototype.valueOf = function() {
  return this.value;
};
c.prototype.toString = function() {
  return this.value + "";
};
c.prototype.toJSON = function() {
  return this.value;
};
c.prototype.peek = function() {
  const i2 = n;
  n = void 0;
  try {
    return this.value;
  } finally {
    n = i2;
  }
};
Object.defineProperty(c.prototype, "value", { get() {
  const i2 = u(this);
  if (void 0 !== i2) i2.i = this.i;
  return this.v;
}, set(i2) {
  if (i2 !== this.v) {
    if (f > 100) throw new Error("Cycle detected");
    this.v = i2;
    this.i++;
    e++;
    r++;
    try {
      for (let i3 = this.t; void 0 !== i3; i3 = i3.x) i3.t.N();
    } finally {
      t();
    }
  }
} });
function d(i2, t2) {
  return new c(i2, t2);
}
function v(i2) {
  for (let t2 = i2.s; void 0 !== t2; t2 = t2.n) if (t2.S.i !== t2.i || !t2.S.h() || t2.S.i !== t2.i) return true;
  return false;
}
function l(i2) {
  for (let t2 = i2.s; void 0 !== t2; t2 = t2.n) {
    const o2 = t2.S.n;
    if (void 0 !== o2) t2.r = o2;
    t2.S.n = t2;
    t2.i = -1;
    if (void 0 === t2.n) {
      i2.s = t2;
      break;
    }
  }
}
function y(i2) {
  let t2, o2 = i2.s;
  while (void 0 !== o2) {
    const i3 = o2.p;
    if (-1 === o2.i) {
      o2.S.U(o2);
      if (void 0 !== i3) i3.n = o2.n;
      if (void 0 !== o2.n) o2.n.p = i3;
    } else t2 = o2;
    o2.S.n = o2.r;
    if (void 0 !== o2.r) o2.r = void 0;
    o2 = i3;
  }
  i2.s = t2;
}
function a(i2, t2) {
  c.call(this, void 0);
  this.x = i2;
  this.s = void 0;
  this.g = e - 1;
  this.f = 4;
  this.W = null == t2 ? void 0 : t2.watched;
  this.Z = null == t2 ? void 0 : t2.unwatched;
  this.name = null == t2 ? void 0 : t2.name;
}
a.prototype = new c();
a.prototype.h = function() {
  this.f &= -3;
  if (1 & this.f) return false;
  if (32 == (36 & this.f)) return true;
  this.f &= -5;
  if (this.g === e) return true;
  this.g = e;
  this.f |= 1;
  if (this.i > 0 && !v(this)) {
    this.f &= -2;
    return true;
  }
  const i2 = n;
  try {
    l(this);
    n = this;
    const i3 = this.x();
    if (16 & this.f || this.v !== i3 || 0 === this.i) {
      this.v = i3;
      this.f &= -17;
      this.i++;
    }
  } catch (i3) {
    this.v = i3;
    this.f |= 16;
    this.i++;
  }
  n = i2;
  y(this);
  this.f &= -2;
  return true;
};
a.prototype.S = function(i2) {
  if (void 0 === this.t) {
    this.f |= 36;
    for (let i3 = this.s; void 0 !== i3; i3 = i3.n) i3.S.S(i3);
  }
  c.prototype.S.call(this, i2);
};
a.prototype.U = function(i2) {
  if (void 0 !== this.t) {
    c.prototype.U.call(this, i2);
    if (void 0 === this.t) {
      this.f &= -33;
      for (let i3 = this.s; void 0 !== i3; i3 = i3.n) i3.S.U(i3);
    }
  }
};
a.prototype.N = function() {
  if (!(2 & this.f)) {
    this.f |= 6;
    for (let i2 = this.t; void 0 !== i2; i2 = i2.x) i2.t.N();
  }
};
Object.defineProperty(a.prototype, "value", { get() {
  if (1 & this.f) throw new Error("Cycle detected");
  const i2 = u(this);
  this.h();
  if (void 0 !== i2) i2.i = this.i;
  if (16 & this.f) throw this.v;
  return this.v;
} });
function w(i2, t2) {
  return new a(i2, t2);
}
function _(i2) {
  const o2 = i2.u;
  i2.u = void 0;
  if ("function" == typeof o2) {
    r++;
    const s2 = n;
    n = void 0;
    try {
      o2();
    } catch (t2) {
      i2.f &= -2;
      i2.f |= 8;
      b(i2);
      throw t2;
    } finally {
      n = s2;
      t();
    }
  }
}
function b(i2) {
  for (let t2 = i2.s; void 0 !== t2; t2 = t2.n) t2.S.U(t2);
  i2.x = void 0;
  i2.s = void 0;
  _(i2);
}
function g(i2) {
  if (n !== this) throw new Error("Out-of-order effect");
  y(this);
  n = i2;
  this.f &= -2;
  if (8 & this.f) b(this);
  t();
}
function p(i2, t2) {
  this.x = i2;
  this.u = void 0;
  this.s = void 0;
  this.o = void 0;
  this.f = 32;
  this.name = null == t2 ? void 0 : t2.name;
}
p.prototype.c = function() {
  const i2 = this.S();
  try {
    if (8 & this.f) return;
    if (void 0 === this.x) return;
    const t2 = this.x();
    if ("function" == typeof t2) this.u = t2;
  } finally {
    i2();
  }
};
p.prototype.S = function() {
  if (1 & this.f) throw new Error("Cycle detected");
  this.f |= 1;
  this.f &= -9;
  _(this);
  l(this);
  r++;
  const i2 = n;
  n = this;
  return g.bind(this, i2);
};
p.prototype.N = function() {
  if (!(2 & this.f)) {
    this.f |= 2;
    this.o = s;
    s = this;
  }
};
p.prototype.d = function() {
  this.f |= 8;
  if (!(1 & this.f)) b(this);
};
p.prototype.dispose = function() {
  this.d();
};
function E(i2, t2) {
  const o2 = new p(i2, t2);
  try {
    o2.c();
  } catch (i3) {
    o2.d();
    throw i3;
  }
  const n2 = o2.d.bind(o2);
  n2[Symbol.dispose] = n2;
  return n2;
}
function namedSignals(defaults, opts = {}) {
  const initial = {};
  for (const k in defaults) {
    const v2 = opts[k];
    const store = d(v2 === void 0 ? defaults[k] : v2);
    initial[k] = store;
  }
  return initial;
}
var AutoFocusExtension = defineExtension2({
  build: (editor, config, state) => {
    return namedSignals(config);
  },
  config: safeCast2({
    defaultSelection: "rootEnd",
    disabled: false
  }),
  name: "@lexical/extension/AutoFocus",
  register(editor, config, state) {
    const stores = state.getOutput();
    return E(() => stores.disabled.value ? void 0 : editor.registerRootListener((rootElement) => {
      editor.focus(() => {
        const activeElement = document.activeElement;
        if (rootElement !== null && (activeElement === null || !rootElement.contains(activeElement))) {
          rootElement.focus({
            preventScroll: true
          });
        }
      }, {
        defaultSelection: stores.defaultSelection.peek()
      });
    }));
  }
});
function $defaultOnClear() {
  const root = $getRoot2();
  const selection = $getSelection2();
  const paragraph = $createParagraphNode2();
  root.clear();
  root.append(paragraph);
  if (selection !== null) {
    paragraph.select();
  }
  if ($isRangeSelection2(selection)) {
    selection.format = 0;
  }
}
function registerClearEditor(editor, $onClear = $defaultOnClear) {
  return editor.registerCommand(CLEAR_EDITOR_COMMAND2, (payload) => {
    editor.update($onClear);
    return true;
  }, COMMAND_PRIORITY_EDITOR2);
}
var ClearEditorExtension = defineExtension2({
  build(editor, config, state) {
    return namedSignals(config);
  },
  config: safeCast2({
    $onClear: $defaultOnClear
  }),
  name: "@lexical/extension/ClearEditor",
  register(editor, config, state) {
    const {
      $onClear
    } = state.getOutput();
    return E(() => registerClearEditor(editor, $onClear.value));
  }
});
function getKnownTypesAndNodes(config) {
  const types = /* @__PURE__ */ new Set();
  const nodes = /* @__PURE__ */ new Set();
  for (const klassOrReplacement of getNodeConfig(config)) {
    const klass = typeof klassOrReplacement === "function" ? klassOrReplacement : klassOrReplacement.replace;
    types.add(klass.getType());
    nodes.add(klass);
  }
  return {
    nodes,
    types
  };
}
function getNodeConfig(config) {
  return (typeof config.nodes === "function" ? config.nodes() : config.nodes) || [];
}
function watchedSignal(getSnapshot, register) {
  let dispose;
  return d(getSnapshot(), {
    unwatched() {
      if (dispose) {
        dispose();
        dispose = void 0;
      }
    },
    watched() {
      this.value = getSnapshot();
      dispose = register(this);
    }
  });
}
var EditorStateExtension = defineExtension2({
  build(editor) {
    return watchedSignal(() => editor.getEditorState(), (editorStateSignal) => editor.registerUpdateListener((payload) => {
      editorStateSignal.value = payload.editorState;
    }));
  },
  name: "@lexical/extension/EditorState"
});
function formatDevErrorMessage5(message) {
  throw new Error(message);
}
function deepThemeMergeInPlace(a2, b2) {
  if (a2 && b2 && !Array.isArray(b2) && typeof a2 === "object" && typeof b2 === "object") {
    const aObj = a2;
    const bObj = b2;
    for (const k in bObj) {
      aObj[k] = deepThemeMergeInPlace(aObj[k], bObj[k]);
    }
    return a2;
  }
  return b2;
}
var ExtensionRepStateIds = {
  /* eslint-disable sort-keys-fix/sort-keys-fix */
  unmarked: 0,
  temporary: 1,
  permanent: 2,
  configured: 3,
  initialized: 4,
  built: 5,
  registered: 6,
  afterRegistration: 7
  /* eslint-enable sort-keys-fix/sort-keys-fix */
};
function isExactlyUnmarkedExtensionRepState(state) {
  return state.id === ExtensionRepStateIds.unmarked;
}
function isExactlyTemporaryExtensionRepState(state) {
  return state.id === ExtensionRepStateIds.temporary;
}
function isExactlyPermanentExtensionRepState(state) {
  return state.id === ExtensionRepStateIds.permanent;
}
function isConfiguredExtensionRepState(state) {
  return state.id >= ExtensionRepStateIds.configured;
}
function isInitializedExtensionRepState(state) {
  return state.id >= ExtensionRepStateIds.initialized;
}
function isBuiltExtensionRepState(state) {
  return state.id >= ExtensionRepStateIds.built;
}
function isAfterRegistrationState(state) {
  return state.id >= ExtensionRepStateIds.afterRegistration;
}
function applyTemporaryMark(state) {
  if (!isExactlyUnmarkedExtensionRepState(state)) {
    formatDevErrorMessage5(`LexicalBuilder: Can not apply a temporary mark from state id ${String(state.id)} (expected ${String(ExtensionRepStateIds.unmarked)} unmarked)`);
  }
  return Object.assign(state, {
    id: ExtensionRepStateIds.temporary
  });
}
function applyPermanentMark(state) {
  if (!isExactlyTemporaryExtensionRepState(state)) {
    formatDevErrorMessage5(`LexicalBuilder: Can not apply a permanent mark from state id ${String(state.id)} (expected ${String(ExtensionRepStateIds.temporary)} temporary)`);
  }
  return Object.assign(state, {
    id: ExtensionRepStateIds.permanent
  });
}
function applyConfiguredState(state, config, registerState) {
  return Object.assign(state, {
    config,
    id: ExtensionRepStateIds.configured,
    registerState
  });
}
function applyInitializedState(state, initResult, registerState) {
  return Object.assign(state, {
    id: ExtensionRepStateIds.initialized,
    initResult,
    registerState
  });
}
function applyBuiltState(state, output, registerState) {
  return Object.assign(state, {
    id: ExtensionRepStateIds.built,
    output,
    registerState
  });
}
function applyRegisteredState(state) {
  return Object.assign(state, {
    id: ExtensionRepStateIds.registered
  });
}
function applyAfterRegistrationState(state) {
  return Object.assign(state, {
    id: ExtensionRepStateIds.afterRegistration
  });
}
function rollbackToBuiltState(state) {
  return Object.assign(state, {
    id: ExtensionRepStateIds.built
  });
}
var emptySet = /* @__PURE__ */ new Set();
var ExtensionRep = class {
  constructor(builder, extension) {
    __publicField(this, "builder");
    __publicField(this, "configs");
    __publicField(this, "_dependency");
    __publicField(this, "_peerNameSet");
    __publicField(this, "extension");
    __publicField(this, "state");
    __publicField(this, "_signal");
    this.builder = builder;
    this.extension = extension;
    this.configs = /* @__PURE__ */ new Set();
    this.state = {
      id: ExtensionRepStateIds.unmarked
    };
  }
  mergeConfigs() {
    let config = this.extension.config || {};
    const mergeConfig = this.extension.mergeConfig ? this.extension.mergeConfig.bind(this.extension) : shallowMergeConfig2;
    for (const cfg of this.configs) {
      config = mergeConfig(config, cfg);
    }
    return config;
  }
  init(editorConfig) {
    const initialState = this.state;
    if (!isExactlyPermanentExtensionRepState(initialState)) {
      formatDevErrorMessage5(`ExtensionRep: Can not configure from state id ${String(initialState.id)}`);
    }
    const initState = {
      getDependency: this.getInitDependency.bind(this),
      getDirectDependentNames: this.getDirectDependentNames.bind(this),
      getPeer: this.getInitPeer.bind(this),
      getPeerNameSet: this.getPeerNameSet.bind(this)
    };
    const buildState = {
      ...initState,
      getDependency: this.getDependency.bind(this),
      getInitResult: this.getInitResult.bind(this),
      getPeer: this.getPeer.bind(this)
    };
    const state = applyConfiguredState(initialState, this.mergeConfigs(), initState);
    this.state = state;
    let initResult;
    if (this.extension.init) {
      initResult = this.extension.init(editorConfig, state.config, initState);
    }
    this.state = applyInitializedState(state, initResult, buildState);
  }
  build(editor) {
    const state = this.state;
    if (!(state.id === ExtensionRepStateIds.initialized)) {
      formatDevErrorMessage5(`ExtensionRep: register called in state id ${String(state.id)} (expected ${String(ExtensionRepStateIds.built)} initialized)`);
    }
    let output;
    if (this.extension.build) {
      output = this.extension.build(editor, state.config, state.registerState);
    }
    const registerState = {
      ...state.registerState,
      getOutput: () => output,
      getSignal: this.getSignal.bind(this)
    };
    this.state = applyBuiltState(state, output, registerState);
  }
  register(editor, signal2) {
    this._signal = signal2;
    const state = this.state;
    if (!(state.id === ExtensionRepStateIds.built)) {
      formatDevErrorMessage5(`ExtensionRep: register called in state id ${String(state.id)} (expected ${String(ExtensionRepStateIds.built)} built)`);
    }
    const cleanup = this.extension.register && this.extension.register(editor, state.config, state.registerState);
    this.state = applyRegisteredState(state);
    return () => {
      const afterRegistrationState = this.state;
      if (!(afterRegistrationState.id === ExtensionRepStateIds.afterRegistration)) {
        formatDevErrorMessage5(`ExtensionRep: rollbackToBuiltState called in state id ${String(state.id)} (expected ${String(ExtensionRepStateIds.afterRegistration)} afterRegistration)`);
      }
      this.state = rollbackToBuiltState(afterRegistrationState);
      if (cleanup) {
        cleanup();
      }
    };
  }
  afterRegistration(editor) {
    const state = this.state;
    if (!(state.id === ExtensionRepStateIds.registered)) {
      formatDevErrorMessage5(`ExtensionRep: afterRegistration called in state id ${String(state.id)} (expected ${String(ExtensionRepStateIds.registered)} registered)`);
    }
    let rval;
    if (this.extension.afterRegistration) {
      rval = this.extension.afterRegistration(editor, state.config, state.registerState);
    }
    this.state = applyAfterRegistrationState(state);
    return rval;
  }
  getSignal() {
    if (!(this._signal !== void 0)) {
      formatDevErrorMessage5(`ExtensionRep.getSignal() called before register`);
    }
    return this._signal;
  }
  getInitResult() {
    if (!(this.extension.init !== void 0)) {
      formatDevErrorMessage5(`ExtensionRep: getInitResult() called for Extension ${this.extension.name} that does not define init`);
    }
    const state = this.state;
    if (!isInitializedExtensionRepState(state)) {
      formatDevErrorMessage5(`ExtensionRep: getInitResult() called for ExtensionRep in state id ${String(state.id)} < ${String(ExtensionRepStateIds.initialized)} (initialized)`);
    }
    return state.initResult;
  }
  getInitPeer(name) {
    const rep = this.builder.extensionNameMap.get(name);
    return rep ? rep.getExtensionInitDependency() : void 0;
  }
  getExtensionInitDependency() {
    const state = this.state;
    if (!isConfiguredExtensionRepState(state)) {
      formatDevErrorMessage5(`ExtensionRep: getExtensionInitDependency called in state id ${String(state.id)} (expected >= ${String(ExtensionRepStateIds.configured)} configured)`);
    }
    return {
      config: state.config
    };
  }
  getPeer(name) {
    const rep = this.builder.extensionNameMap.get(name);
    return rep ? rep.getExtensionDependency() : void 0;
  }
  getInitDependency(dep) {
    const rep = this.builder.getExtensionRep(dep);
    if (!(rep !== void 0)) {
      formatDevErrorMessage5(`LexicalExtensionBuilder: Extension ${this.extension.name} missing dependency extension ${dep.name} to be in registry`);
    }
    return rep.getExtensionInitDependency();
  }
  getDependency(dep) {
    const rep = this.builder.getExtensionRep(dep);
    if (!(rep !== void 0)) {
      formatDevErrorMessage5(`LexicalExtensionBuilder: Extension ${this.extension.name} missing dependency extension ${dep.name} to be in registry`);
    }
    return rep.getExtensionDependency();
  }
  getState() {
    const state = this.state;
    if (!isAfterRegistrationState(state)) {
      formatDevErrorMessage5(`ExtensionRep getState called in state id ${String(state.id)} (expected ${String(ExtensionRepStateIds.afterRegistration)} afterRegistration)`);
    }
    return state;
  }
  getDirectDependentNames() {
    return this.builder.incomingEdges.get(this.extension.name) || emptySet;
  }
  getPeerNameSet() {
    let s2 = this._peerNameSet;
    if (!s2) {
      s2 = new Set((this.extension.peerDependencies || []).map(([name]) => name));
      this._peerNameSet = s2;
    }
    return s2;
  }
  getExtensionDependency() {
    if (!this._dependency) {
      const state = this.state;
      if (!isBuiltExtensionRepState(state)) {
        formatDevErrorMessage5(`Extension ${this.extension.name} used as a dependency before build`);
      }
      this._dependency = {
        config: state.config,
        init: state.initResult,
        output: state.output
      };
    }
    return this._dependency;
  }
};
var HISTORY_MERGE_OPTIONS = {
  tag: HISTORY_MERGE_TAG2
};
function $defaultInitializer() {
  const root = $getRoot2();
  if (root.isEmpty()) {
    root.append($createParagraphNode2());
  }
}
var InitialStateExtension = defineExtension2({
  config: safeCast2({
    setOptions: HISTORY_MERGE_OPTIONS,
    updateOptions: HISTORY_MERGE_OPTIONS
  }),
  init({
    $initialEditorState = $defaultInitializer
  }) {
    return {
      $initialEditorState,
      initialized: false
    };
  },
  // eslint-disable-next-line sort-keys-fix/sort-keys-fix -- typescript inference is order dependent here for some reason
  afterRegistration(editor, {
    updateOptions,
    setOptions
  }, state) {
    const initResult = state.getInitResult();
    if (!initResult.initialized) {
      initResult.initialized = true;
      const {
        $initialEditorState
      } = initResult;
      if ($isEditorState2($initialEditorState)) {
        editor.setEditorState($initialEditorState, setOptions);
      } else if (typeof $initialEditorState === "function") {
        editor.update(() => {
          $initialEditorState(editor);
        }, updateOptions);
      } else if ($initialEditorState && (typeof $initialEditorState === "string" || typeof $initialEditorState === "object")) {
        const parsedEditorState = editor.parseEditorState($initialEditorState);
        editor.setEditorState(parsedEditorState, setOptions);
      }
    }
    return () => {
    };
  },
  name: "@lexical/extension/InitialState",
  // These are automatically added by createEditor, we add them here so they are
  // visible during extensionRep.init so extensions can see all known types before the
  // editor is created.
  // (excluding ArtificialNode__DO_NOT_USE because it isn't really public API
  // and shouldn't change anything)
  nodes: [RootNode2, TextNode2, LineBreakNode2, TabNode2, ParagraphNode2]
});
var builderSymbol = Symbol.for("@lexical/extension/LexicalBuilder");
function buildEditorFromExtensions(...extensions) {
  return LexicalBuilder.fromExtensions(extensions).buildEditor();
}
function noop() {
}
function defaultOnError(err) {
  throw err;
}
function maybeWithBuilder(editor) {
  return editor;
}
function normalizeExtensionArgument(arg) {
  return Array.isArray(arg) ? arg : [arg];
}
var PACKAGE_VERSION = "0.39.0+dev.esm";
var LexicalBuilder = class _LexicalBuilder {
  constructor(roots) {
    __publicField(this, "roots");
    __publicField(this, "extensionNameMap");
    __publicField(this, "outgoingConfigEdges");
    __publicField(this, "incomingEdges");
    __publicField(this, "conflicts");
    __publicField(this, "_sortedExtensionReps");
    __publicField(this, "PACKAGE_VERSION");
    this.outgoingConfigEdges = /* @__PURE__ */ new Map();
    this.incomingEdges = /* @__PURE__ */ new Map();
    this.extensionNameMap = /* @__PURE__ */ new Map();
    this.conflicts = /* @__PURE__ */ new Map();
    this.PACKAGE_VERSION = PACKAGE_VERSION;
    this.roots = roots;
    for (const extension of roots) {
      this.addExtension(extension);
    }
  }
  static fromExtensions(extensions) {
    const roots = [normalizeExtensionArgument(InitialStateExtension)];
    for (const extension of extensions) {
      roots.push(normalizeExtensionArgument(extension));
    }
    return new _LexicalBuilder(roots);
  }
  static maybeFromEditor(editor) {
    const builder = maybeWithBuilder(editor)[builderSymbol];
    if (builder) {
      if (!(builder.PACKAGE_VERSION === PACKAGE_VERSION)) {
        formatDevErrorMessage5(`LexicalBuilder.fromEditor: The given editor was created with LexicalBuilder ${builder.PACKAGE_VERSION} but this version is ${PACKAGE_VERSION}. A project should have exactly one copy of LexicalBuilder`);
      }
      if (!(builder instanceof _LexicalBuilder)) {
        formatDevErrorMessage5(`LexicalBuilder.fromEditor: There are multiple copies of the same version of LexicalBuilder in your project, and this editor was created with another one. Your project, or one of its dependencies, has its package.json and/or bundler configured incorrectly.`);
      }
    }
    return builder;
  }
  /** Look up the editor that was created by this LexicalBuilder or throw */
  static fromEditor(editor) {
    const builder = _LexicalBuilder.maybeFromEditor(editor);
    if (!(builder !== void 0)) {
      formatDevErrorMessage5(`LexicalBuilder.fromEditor: The given editor was not created with LexicalBuilder`);
    }
    return builder;
  }
  constructEditor() {
    const {
      $initialEditorState: _$initialEditorState,
      onError,
      ...editorConfig
    } = this.buildCreateEditorArgs();
    const editor = Object.assign(createEditor2({
      ...editorConfig,
      ...onError ? {
        onError: (err) => {
          onError(err, editor);
        }
      } : {}
    }), {
      [builderSymbol]: this
    });
    for (const extensionRep of this.sortedExtensionReps()) {
      extensionRep.build(editor);
    }
    return editor;
  }
  buildEditor() {
    let disposeOnce = noop;
    function dispose() {
      try {
        disposeOnce();
      } finally {
        disposeOnce = noop;
      }
    }
    const editor = Object.assign(this.constructEditor(), {
      dispose,
      [Symbol.dispose]: dispose
    });
    disposeOnce = mergeRegister2(this.registerEditor(editor), () => editor.setRootElement(null));
    return editor;
  }
  hasExtensionByName(name) {
    return this.extensionNameMap.has(name);
  }
  getExtensionRep(extension) {
    const rep = this.extensionNameMap.get(extension.name);
    if (rep) {
      if (!(rep.extension === extension)) {
        formatDevErrorMessage5(`LexicalBuilder: A registered extension with name ${extension.name} exists but does not match the given extension`);
      }
      return rep;
    }
  }
  addEdge(fromExtensionName, toExtensionName, configs) {
    const outgoing = this.outgoingConfigEdges.get(fromExtensionName);
    if (outgoing) {
      outgoing.set(toExtensionName, configs);
    } else {
      this.outgoingConfigEdges.set(fromExtensionName, /* @__PURE__ */ new Map([[toExtensionName, configs]]));
    }
    const incoming = this.incomingEdges.get(toExtensionName);
    if (incoming) {
      incoming.add(fromExtensionName);
    } else {
      this.incomingEdges.set(toExtensionName, /* @__PURE__ */ new Set([fromExtensionName]));
    }
  }
  addExtension(arg) {
    if (!(this._sortedExtensionReps === void 0)) {
      formatDevErrorMessage5(`LexicalBuilder: addExtension called after finalization`);
    }
    const normalized = normalizeExtensionArgument(arg);
    const [extension] = normalized;
    if (!(typeof extension.name === "string")) {
      formatDevErrorMessage5(`LexicalBuilder: extension name must be string, not ${typeof extension.name}`);
    }
    let extensionRep = this.extensionNameMap.get(extension.name);
    if (!(extensionRep === void 0 || extensionRep.extension === extension)) {
      formatDevErrorMessage5(`LexicalBuilder: Multiple extensions registered with name ${extension.name}, names must be unique`);
    }
    if (!extensionRep) {
      extensionRep = new ExtensionRep(this, extension);
      this.extensionNameMap.set(extension.name, extensionRep);
      const hasConflict = this.conflicts.get(extension.name);
      if (typeof hasConflict === "string") {
        {
          formatDevErrorMessage5(`LexicalBuilder: extension ${extension.name} conflicts with ${hasConflict}`);
        }
      }
      for (const name of extension.conflictsWith || []) {
        if (!!this.extensionNameMap.has(name)) {
          formatDevErrorMessage5(`LexicalBuilder: extension ${extension.name} conflicts with ${name}`);
        }
        this.conflicts.set(name, extension.name);
      }
      for (const dep of extension.dependencies || []) {
        const normDep = normalizeExtensionArgument(dep);
        this.addEdge(extension.name, normDep[0].name, normDep.slice(1));
        this.addExtension(normDep);
      }
      for (const [depName, config] of extension.peerDependencies || []) {
        this.addEdge(extension.name, depName, config ? [config] : []);
      }
    }
  }
  sortedExtensionReps() {
    if (this._sortedExtensionReps) {
      return this._sortedExtensionReps;
    }
    const sortedExtensionReps = [];
    const visit = (rep, fromExtensionName) => {
      let mark = rep.state;
      if (isExactlyPermanentExtensionRepState(mark)) {
        return;
      }
      const extensionName = rep.extension.name;
      if (!isExactlyUnmarkedExtensionRepState(mark)) {
        formatDevErrorMessage5(`LexicalBuilder: Circular dependency detected for Extension ${extensionName} from ${fromExtensionName || "[unknown]"}`);
      }
      mark = applyTemporaryMark(mark);
      rep.state = mark;
      const outgoingConfigEdges = this.outgoingConfigEdges.get(extensionName);
      if (outgoingConfigEdges) {
        for (const toExtensionName of outgoingConfigEdges.keys()) {
          const toRep = this.extensionNameMap.get(toExtensionName);
          if (toRep) {
            visit(toRep, extensionName);
          }
        }
      }
      mark = applyPermanentMark(mark);
      rep.state = mark;
      sortedExtensionReps.push(rep);
    };
    for (const rep of this.extensionNameMap.values()) {
      if (isExactlyUnmarkedExtensionRepState(rep.state)) {
        visit(rep);
      }
    }
    for (const rep of sortedExtensionReps) {
      for (const [toExtensionName, configs] of this.outgoingConfigEdges.get(rep.extension.name) || []) {
        if (configs.length > 0) {
          const toRep = this.extensionNameMap.get(toExtensionName);
          if (toRep) {
            for (const config of configs) {
              toRep.configs.add(config);
            }
          }
        }
      }
    }
    for (const [extension, ...configs] of this.roots) {
      if (configs.length > 0) {
        const toRep = this.extensionNameMap.get(extension.name);
        if (!(toRep !== void 0)) {
          formatDevErrorMessage5(`LexicalBuilder: Expecting existing ExtensionRep for ${extension.name}`);
        }
        for (const config of configs) {
          toRep.configs.add(config);
        }
      }
    }
    this._sortedExtensionReps = sortedExtensionReps;
    return this._sortedExtensionReps;
  }
  registerEditor(editor) {
    const extensionReps = this.sortedExtensionReps();
    const controller = new AbortController();
    const cleanups = [() => controller.abort()];
    const signal2 = controller.signal;
    for (const extensionRep of extensionReps) {
      const cleanup = extensionRep.register(editor, signal2);
      if (cleanup) {
        cleanups.push(cleanup);
      }
    }
    for (const extensionRep of extensionReps) {
      const cleanup = extensionRep.afterRegistration(editor);
      if (cleanup) {
        cleanups.push(cleanup);
      }
    }
    return mergeRegister2(...cleanups);
  }
  buildCreateEditorArgs() {
    const config = {};
    const nodes = /* @__PURE__ */ new Set();
    const replacedNodes = /* @__PURE__ */ new Map();
    const htmlExport = /* @__PURE__ */ new Map();
    const htmlImport = {};
    const theme2 = {};
    const extensionReps = this.sortedExtensionReps();
    for (const extensionRep of extensionReps) {
      const {
        extension
      } = extensionRep;
      if (extension.onError !== void 0) {
        config.onError = extension.onError;
      }
      if (extension.disableEvents !== void 0) {
        config.disableEvents = extension.disableEvents;
      }
      if (extension.parentEditor !== void 0) {
        config.parentEditor = extension.parentEditor;
      }
      if (extension.editable !== void 0) {
        config.editable = extension.editable;
      }
      if (extension.namespace !== void 0) {
        config.namespace = extension.namespace;
      }
      if (extension.$initialEditorState !== void 0) {
        config.$initialEditorState = extension.$initialEditorState;
      }
      if (extension.nodes) {
        for (const node of getNodeConfig(extension)) {
          if (typeof node !== "function") {
            const conflictExtension = replacedNodes.get(node.replace);
            if (conflictExtension) {
              {
                formatDevErrorMessage5(`LexicalBuilder: Extension ${extension.name} can not register replacement for node ${node.replace.name} because ${conflictExtension.extension.name} already did`);
              }
            }
            replacedNodes.set(node.replace, extensionRep);
          }
          nodes.add(node);
        }
      }
      if (extension.html) {
        if (extension.html.export) {
          for (const [k, v2] of extension.html.export.entries()) {
            htmlExport.set(k, v2);
          }
        }
        if (extension.html.import) {
          Object.assign(htmlImport, extension.html.import);
        }
      }
      if (extension.theme) {
        deepThemeMergeInPlace(theme2, extension.theme);
      }
    }
    if (Object.keys(theme2).length > 0) {
      config.theme = theme2;
    }
    if (nodes.size) {
      config.nodes = [...nodes];
    }
    const hasImport = Object.keys(htmlImport).length > 0;
    const hasExport = htmlExport.size > 0;
    if (hasImport || hasExport) {
      config.html = {};
      if (hasImport) {
        config.html.import = htmlImport;
      }
      if (hasExport) {
        config.html.export = htmlExport;
      }
    }
    for (const extensionRep of extensionReps) {
      extensionRep.init(config);
    }
    if (!config.onError) {
      config.onError = defaultOnError;
    }
    return config;
  }
};
function getExtensionDependencyFromEditor(editor, extension) {
  const builder = LexicalBuilder.fromEditor(editor);
  const rep = builder.getExtensionRep(extension);
  if (!(rep !== void 0)) {
    formatDevErrorMessage5(`getExtensionDependencyFromEditor: Extension ${extension.name} was not built when creating this editor`);
  }
  return rep.getExtensionDependency();
}
function getPeerDependencyFromEditor(editor, extensionName) {
  const builder = LexicalBuilder.fromEditor(editor);
  const peer = builder.extensionNameMap.get(extensionName);
  return peer ? peer.getExtensionDependency() : void 0;
}
function getPeerDependencyFromEditorOrThrow(editor, extensionName) {
  const dep = getPeerDependencyFromEditor(editor, extensionName);
  if (!(dep !== void 0)) {
    formatDevErrorMessage5(`getPeerDependencyFromEditorOrThrow: Editor was not built with Extension ${extensionName}`);
  }
  return dep;
}
var EMPTY_SET = /* @__PURE__ */ new Set();
var NodeSelectionExtension = defineExtension2({
  build(editor, config, state) {
    const editorStateStore = state.getDependency(EditorStateExtension).output;
    const watchedNodeStore = d({
      watchedNodeKeys: /* @__PURE__ */ new Map()
    });
    const selectedNodeKeys = watchedSignal(() => void 0, () => E(() => {
      const prevSelectedNodeKeys = selectedNodeKeys.peek();
      const {
        watchedNodeKeys
      } = watchedNodeStore.value;
      let nextSelectedNodeKeys;
      let didChange = false;
      editorStateStore.value.read(() => {
        const selection = $getSelection2();
        if (selection) {
          for (const [key, listeners] of watchedNodeKeys.entries()) {
            if (listeners.size === 0) {
              watchedNodeKeys.delete(key);
              continue;
            }
            const node = $getNodeByKey2(key);
            const isSelected = node && node.isSelected() || false;
            didChange = didChange || isSelected !== (prevSelectedNodeKeys ? prevSelectedNodeKeys.has(key) : false);
            if (isSelected) {
              nextSelectedNodeKeys = nextSelectedNodeKeys || /* @__PURE__ */ new Set();
              nextSelectedNodeKeys.add(key);
            }
          }
        }
      });
      if (!(!didChange && nextSelectedNodeKeys && prevSelectedNodeKeys && nextSelectedNodeKeys.size === prevSelectedNodeKeys.size)) {
        selectedNodeKeys.value = nextSelectedNodeKeys;
      }
    }));
    function watchNodeKey(key) {
      const watcher = w(() => (selectedNodeKeys.value || EMPTY_SET).has(key));
      const {
        watchedNodeKeys
      } = watchedNodeStore.peek();
      let listeners = watchedNodeKeys.get(key);
      const hadListener = listeners !== void 0;
      listeners = listeners || /* @__PURE__ */ new Set();
      listeners.add(watcher);
      if (!hadListener) {
        watchedNodeKeys.set(key, listeners);
        watchedNodeStore.value = {
          watchedNodeKeys
        };
      }
      return watcher;
    }
    return {
      watchNodeKey
    };
  },
  dependencies: [EditorStateExtension],
  name: "@lexical/extension/NodeSelection"
});
var INSERT_HORIZONTAL_RULE_COMMAND = createCommand2("INSERT_HORIZONTAL_RULE_COMMAND");
var HorizontalRuleNode = class _HorizontalRuleNode extends DecoratorNode2 {
  static getType() {
    return "horizontalrule";
  }
  static clone(node) {
    return new _HorizontalRuleNode(node.__key);
  }
  static importJSON(serializedNode) {
    return $createHorizontalRuleNode().updateFromJSON(serializedNode);
  }
  static importDOM() {
    return {
      hr: () => ({
        conversion: $convertHorizontalRuleElement,
        priority: 0
      })
    };
  }
  exportDOM() {
    return {
      element: document.createElement("hr")
    };
  }
  createDOM(config) {
    const element = document.createElement("hr");
    addClassNamesToElement2(element, config.theme.hr);
    return element;
  }
  getTextContent() {
    return "\n";
  }
  isInline() {
    return false;
  }
  updateDOM() {
    return false;
  }
};
function $convertHorizontalRuleElement() {
  return {
    node: $createHorizontalRuleNode()
  };
}
function $createHorizontalRuleNode() {
  return $create2(HorizontalRuleNode);
}
function $isHorizontalRuleNode(node) {
  return node instanceof HorizontalRuleNode;
}
function $toggleNodeSelection(node, shiftKey = false) {
  const selection = $getSelection2();
  const wasSelected = node.isSelected();
  const key = node.getKey();
  let nodeSelection;
  if (shiftKey && $isNodeSelection2(selection)) {
    nodeSelection = selection;
  } else {
    nodeSelection = $createNodeSelection2();
    $setSelection2(nodeSelection);
  }
  if (wasSelected) {
    nodeSelection.delete(key);
  } else {
    nodeSelection.add(key);
  }
}
var HorizontalRuleExtension = defineExtension2({
  dependencies: [EditorStateExtension, NodeSelectionExtension],
  name: "@lexical/extension/HorizontalRule",
  nodes: () => [HorizontalRuleNode],
  register(editor, config, state) {
    const {
      watchNodeKey
    } = state.getDependency(NodeSelectionExtension).output;
    const nodeSelectionStore = d({
      nodeSelections: /* @__PURE__ */ new Map()
    });
    const isSelectedClassName = editor._config.theme.hrSelected ?? "selected";
    return mergeRegister2(editor.registerCommand(CLICK_COMMAND2, (event) => {
      if (isDOMNode2(event.target)) {
        const node = $getNodeFromDOMNode2(event.target);
        if ($isHorizontalRuleNode(node)) {
          $toggleNodeSelection(node, event.shiftKey);
          return true;
        }
      }
      return false;
    }, COMMAND_PRIORITY_LOW2), editor.registerMutationListener(HorizontalRuleNode, (nodes, payload) => {
      o(() => {
        let didChange = false;
        const {
          nodeSelections
        } = nodeSelectionStore.peek();
        for (const [k, v2] of nodes.entries()) {
          if (v2 === "destroyed") {
            nodeSelections.delete(k);
            didChange = true;
          } else {
            const prev = nodeSelections.get(k);
            const dom = editor.getElementByKey(k);
            if (prev) {
              prev.domNode.value = dom;
            } else {
              didChange = true;
              nodeSelections.set(k, {
                domNode: d(dom),
                selectedSignal: watchNodeKey(k)
              });
            }
          }
        }
        if (didChange) {
          nodeSelectionStore.value = {
            nodeSelections
          };
        }
      });
    }), E(() => {
      const effects = [];
      for (const {
        domNode,
        selectedSignal
      } of nodeSelectionStore.value.nodeSelections.values()) {
        effects.push(E(() => {
          const dom = domNode.value;
          if (dom) {
            const isSelected = selectedSignal.value;
            if (isSelected) {
              addClassNamesToElement2(dom, isSelectedClassName);
            } else {
              removeClassNamesFromElement2(dom, isSelectedClassName);
            }
          }
        }));
      }
      return mergeRegister2(...effects);
    }));
  }
});
function $indentOverTab(selection) {
  const nodes = selection.getNodes();
  const canIndentBlockNodes = $filter2(nodes, (node) => {
    if ($isBlockElementNode2(node) && node.canIndent()) {
      return node;
    }
    return null;
  });
  if (canIndentBlockNodes.length > 0) {
    return true;
  }
  const anchor = selection.anchor;
  const focus = selection.focus;
  const first = focus.isBefore(anchor) ? focus : anchor;
  const firstNode = first.getNode();
  const firstBlock = $getNearestBlockElementAncestorOrThrow2(firstNode);
  if (firstBlock.canIndent()) {
    const firstBlockKey = firstBlock.getKey();
    let selectionAtStart = $createRangeSelection2();
    selectionAtStart.anchor.set(firstBlockKey, 0, "element");
    selectionAtStart.focus.set(firstBlockKey, 0, "element");
    selectionAtStart = $normalizeSelection__EXPERIMENTAL(selectionAtStart);
    if (selectionAtStart.anchor.is(first)) {
      return true;
    }
  }
  return false;
}
function registerTabIndentation(editor, maxIndent) {
  return mergeRegister2(editor.registerCommand(KEY_TAB_COMMAND2, (event) => {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    event.preventDefault();
    const command = $indentOverTab(selection) ? event.shiftKey ? OUTDENT_CONTENT_COMMAND2 : INDENT_CONTENT_COMMAND2 : INSERT_TAB_COMMAND2;
    return editor.dispatchCommand(command, void 0);
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(INDENT_CONTENT_COMMAND2, () => {
    const currentMaxIndent = typeof maxIndent === "number" ? maxIndent : maxIndent ? maxIndent.peek() : null;
    if (currentMaxIndent == null) {
      return false;
    }
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    const indents = selection.getNodes().map((node) => $getNearestBlockElementAncestorOrThrow2(node).getIndent());
    return Math.max(...indents) + 1 >= currentMaxIndent;
  }, COMMAND_PRIORITY_CRITICAL2));
}
var TabIndentationExtension = defineExtension2({
  build(editor, config, state) {
    return namedSignals(config);
  },
  config: safeCast2({
    disabled: false,
    maxIndent: null
  }),
  name: "@lexical/extension/TabIndentation",
  register(editor, config, state) {
    const {
      disabled,
      maxIndent
    } = state.getOutput();
    return E(() => {
      if (!disabled.value) {
        return registerTabIndentation(editor, maxIndent);
      }
    });
  }
});

// node_modules/@lexical/extension/LexicalExtension.mjs
var mod6 = true ? LexicalExtension_dev_exports : LexicalExtension_prod_exports;
var $createHorizontalRuleNode2 = mod6.$createHorizontalRuleNode;
var $isHorizontalRuleNode2 = mod6.$isHorizontalRuleNode;
var AutoFocusExtension2 = mod6.AutoFocusExtension;
var ClearEditorExtension2 = mod6.ClearEditorExtension;
var EditorStateExtension2 = mod6.EditorStateExtension;
var HorizontalRuleExtension2 = mod6.HorizontalRuleExtension;
var HorizontalRuleNode2 = mod6.HorizontalRuleNode;
var INSERT_HORIZONTAL_RULE_COMMAND2 = mod6.INSERT_HORIZONTAL_RULE_COMMAND;
var InitialStateExtension2 = mod6.InitialStateExtension;
var LexicalBuilder2 = mod6.LexicalBuilder;
var NodeSelectionExtension2 = mod6.NodeSelectionExtension;
var TabIndentationExtension2 = mod6.TabIndentationExtension;
var batch = mod6.batch;
var buildEditorFromExtensions2 = mod6.buildEditorFromExtensions;
var computed = mod6.computed;
var configExtension3 = mod6.configExtension;
var declarePeerDependency3 = mod6.declarePeerDependency;
var defineExtension3 = mod6.defineExtension;
var effect = mod6.effect;
var getExtensionDependencyFromEditor2 = mod6.getExtensionDependencyFromEditor;
var getKnownTypesAndNodes2 = mod6.getKnownTypesAndNodes;
var getPeerDependencyFromEditor2 = mod6.getPeerDependencyFromEditor;
var getPeerDependencyFromEditorOrThrow2 = mod6.getPeerDependencyFromEditorOrThrow;
var namedSignals2 = mod6.namedSignals;
var registerClearEditor2 = mod6.registerClearEditor;
var registerTabIndentation2 = mod6.registerTabIndentation;
var safeCast3 = mod6.safeCast;
var shallowMergeConfig3 = mod6.shallowMergeConfig;
var signal = mod6.signal;
var untracked = mod6.untracked;
var watchedSignal2 = mod6.watchedSignal;

// node_modules/@lexical/dragon/LexicalDragon.dev.mjs
function registerDragonSupport(editor) {
  const origin = window.location.origin;
  const handler = (event) => {
    if (event.origin !== origin) {
      return;
    }
    const rootElement = editor.getRootElement();
    if (document.activeElement !== rootElement) {
      return;
    }
    const data = event.data;
    if (typeof data === "string") {
      let parsedData;
      try {
        parsedData = JSON.parse(data);
      } catch (_e) {
        return;
      }
      if (parsedData && parsedData.protocol === "nuanria_messaging" && parsedData.type === "request") {
        const payload = parsedData.payload;
        if (payload && payload.functionId === "makeChanges") {
          const args = payload.args;
          if (args) {
            const [elementStart, elementLength, text, selStart, selLength] = args;
            editor.update(() => {
              const selection = $getSelection2();
              if ($isRangeSelection2(selection)) {
                const anchor = selection.anchor;
                let anchorNode = anchor.getNode();
                let setSelStart = 0;
                let setSelEnd = 0;
                if ($isTextNode2(anchorNode)) {
                  if (elementStart >= 0 && elementLength >= 0) {
                    setSelStart = elementStart;
                    setSelEnd = elementStart + elementLength;
                    selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);
                  }
                }
                if (setSelStart !== setSelEnd || text !== "") {
                  selection.insertRawText(text);
                  anchorNode = anchor.getNode();
                }
                if ($isTextNode2(anchorNode)) {
                  setSelStart = selStart;
                  setSelEnd = selStart + selLength;
                  const anchorNodeTextLength = anchorNode.getTextContentSize();
                  setSelStart = setSelStart > anchorNodeTextLength ? anchorNodeTextLength : setSelStart;
                  setSelEnd = setSelEnd > anchorNodeTextLength ? anchorNodeTextLength : setSelEnd;
                  selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);
                }
                event.stopImmediatePropagation();
              }
            });
          }
        }
      }
    }
  };
  window.addEventListener("message", handler, true);
  return () => {
    window.removeEventListener("message", handler, true);
  };
}
var DragonExtension = defineExtension2({
  build: (editor, config, state) => namedSignals2(config),
  config: safeCast2({
    disabled: typeof window === "undefined"
  }),
  name: "@lexical/dragon",
  register: (editor, config, state) => effect(() => state.getOutput().disabled.value ? void 0 : registerDragonSupport(editor))
});

// node_modules/@lexical/dragon/LexicalDragon.mjs
var mod7 = true ? LexicalDragon_dev_exports : LexicalDragon_prod_exports;
var DragonExtension2 = mod7.DragonExtension;
var registerDragonSupport2 = mod7.registerDragonSupport;

// node_modules/@lexical/rich-text/LexicalRichText.dev.mjs
function caretFromPoint(x, y2) {
  if (typeof document.caretRangeFromPoint !== "undefined") {
    const range = document.caretRangeFromPoint(x, y2);
    if (range === null) {
      return null;
    }
    return {
      node: range.startContainer,
      offset: range.startOffset
    };
  } else if (document.caretPositionFromPoint !== "undefined") {
    const range = document.caretPositionFromPoint(x, y2);
    if (range === null) {
      return null;
    }
    return {
      node: range.offsetNode,
      offset: range.offset
    };
  } else {
    return null;
  }
}
var CAN_USE_DOM4 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
var documentMode3 = CAN_USE_DOM4 && "documentMode" in document ? document.documentMode : null;
var IS_APPLE4 = CAN_USE_DOM4 && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
var CAN_USE_BEFORE_INPUT4 = CAN_USE_DOM4 && "InputEvent" in window && !documentMode3 ? "getTargetRanges" in new window.InputEvent("input") : false;
var IS_SAFARI4 = CAN_USE_DOM4 && /Version\/[\d.]+.*Safari/.test(navigator.userAgent);
var IS_IOS4 = CAN_USE_DOM4 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
var IS_CHROME4 = CAN_USE_DOM4 && /^(?=.*Chrome).*/i.test(navigator.userAgent);
var IS_APPLE_WEBKIT4 = CAN_USE_DOM4 && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && IS_APPLE4 && !IS_CHROME4;
var DRAG_DROP_PASTE = createCommand2("DRAG_DROP_PASTE_FILE");
var QuoteNode = class _QuoteNode extends ElementNode2 {
  static getType() {
    return "quote";
  }
  static clone(node) {
    return new _QuoteNode(node.__key);
  }
  // View
  createDOM(config) {
    const element = document.createElement("blockquote");
    addClassNamesToElement2(element, config.theme.quote);
    return element;
  }
  updateDOM(prevNode, dom) {
    return false;
  }
  static importDOM() {
    return {
      blockquote: (node) => ({
        conversion: $convertBlockquoteElement,
        priority: 0
      })
    };
  }
  exportDOM(editor) {
    const {
      element
    } = super.exportDOM(editor);
    if (isHTMLElement3(element)) {
      if (this.isEmpty()) {
        element.append(document.createElement("br"));
      }
      const formatType = this.getFormatType();
      if (formatType) {
        element.style.textAlign = formatType;
      }
      const direction = this.getDirection();
      if (direction) {
        element.dir = direction;
      }
    }
    return {
      element
    };
  }
  static importJSON(serializedNode) {
    return $createQuoteNode().updateFromJSON(serializedNode);
  }
  // Mutation
  insertNewAfter(_2, restoreSelection) {
    const newBlock = $createParagraphNode2();
    const direction = this.getDirection();
    newBlock.setDirection(direction);
    this.insertAfter(newBlock, restoreSelection);
    return newBlock;
  }
  collapseAtStart() {
    const paragraph = $createParagraphNode2();
    const children = this.getChildren();
    children.forEach((child) => paragraph.append(child));
    this.replace(paragraph);
    return true;
  }
  canMergeWhenEmpty() {
    return true;
  }
};
function $createQuoteNode() {
  return $applyNodeReplacement2(new QuoteNode());
}
function $isQuoteNode(node) {
  return node instanceof QuoteNode;
}
var HeadingNode = class _HeadingNode extends ElementNode2 {
  constructor(tag, key) {
    super(key);
    /** @internal */
    __publicField(this, "__tag");
    this.__tag = tag;
  }
  static getType() {
    return "heading";
  }
  static clone(node) {
    return new _HeadingNode(node.__tag, node.__key);
  }
  getTag() {
    return this.__tag;
  }
  setTag(tag) {
    const self2 = this.getWritable();
    this.__tag = tag;
    return self2;
  }
  // View
  createDOM(config) {
    const tag = this.__tag;
    const element = document.createElement(tag);
    const theme2 = config.theme;
    const classNames = theme2.heading;
    if (classNames !== void 0) {
      const className = classNames[tag];
      addClassNamesToElement2(element, className);
    }
    return element;
  }
  updateDOM(prevNode, dom, config) {
    return prevNode.__tag !== this.__tag;
  }
  static importDOM() {
    return {
      h1: (node) => ({
        conversion: $convertHeadingElement,
        priority: 0
      }),
      h2: (node) => ({
        conversion: $convertHeadingElement,
        priority: 0
      }),
      h3: (node) => ({
        conversion: $convertHeadingElement,
        priority: 0
      }),
      h4: (node) => ({
        conversion: $convertHeadingElement,
        priority: 0
      }),
      h5: (node) => ({
        conversion: $convertHeadingElement,
        priority: 0
      }),
      h6: (node) => ({
        conversion: $convertHeadingElement,
        priority: 0
      }),
      p: (node) => {
        const paragraph = node;
        const firstChild = paragraph.firstChild;
        if (firstChild !== null && isGoogleDocsTitle(firstChild)) {
          return {
            conversion: () => ({
              node: null
            }),
            priority: 3
          };
        }
        return null;
      },
      span: (node) => {
        if (isGoogleDocsTitle(node)) {
          return {
            conversion: (domNode) => {
              return {
                node: $createHeadingNode("h1")
              };
            },
            priority: 3
          };
        }
        return null;
      }
    };
  }
  exportDOM(editor) {
    const {
      element
    } = super.exportDOM(editor);
    if (isHTMLElement3(element)) {
      if (this.isEmpty()) {
        element.append(document.createElement("br"));
      }
      const formatType = this.getFormatType();
      if (formatType) {
        element.style.textAlign = formatType;
      }
      const direction = this.getDirection();
      if (direction) {
        element.dir = direction;
      }
    }
    return {
      element
    };
  }
  static importJSON(serializedNode) {
    return $createHeadingNode(serializedNode.tag).updateFromJSON(serializedNode);
  }
  updateFromJSON(serializedNode) {
    return super.updateFromJSON(serializedNode).setTag(serializedNode.tag);
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      tag: this.getTag()
    };
  }
  // Mutation
  insertNewAfter(selection, restoreSelection = true) {
    const anchorOffet = selection ? selection.anchor.offset : 0;
    const lastDesc = this.getLastDescendant();
    const isAtEnd = !lastDesc || selection && selection.anchor.key === lastDesc.getKey() && anchorOffet === lastDesc.getTextContentSize();
    const newElement = isAtEnd || !selection ? $createParagraphNode2() : $createHeadingNode(this.getTag());
    const direction = this.getDirection();
    newElement.setDirection(direction);
    this.insertAfter(newElement, restoreSelection);
    if (anchorOffet === 0 && !this.isEmpty() && selection) {
      const paragraph = $createParagraphNode2();
      paragraph.select();
      this.replace(paragraph, true);
    }
    return newElement;
  }
  collapseAtStart() {
    const newElement = !this.isEmpty() ? $createHeadingNode(this.getTag()) : $createParagraphNode2();
    const children = this.getChildren();
    children.forEach((child) => newElement.append(child));
    this.replace(newElement);
    return true;
  }
  extractWithChild() {
    return true;
  }
};
function isGoogleDocsTitle(domNode) {
  if (domNode.nodeName.toLowerCase() === "span") {
    return domNode.style.fontSize === "26pt";
  }
  return false;
}
function $convertHeadingElement(element) {
  const nodeName = element.nodeName.toLowerCase();
  let node = null;
  if (nodeName === "h1" || nodeName === "h2" || nodeName === "h3" || nodeName === "h4" || nodeName === "h5" || nodeName === "h6") {
    node = $createHeadingNode(nodeName);
    if (element.style !== null) {
      setNodeIndentFromDOM2(element, node);
      node.setFormat(element.style.textAlign);
    }
  }
  return {
    node
  };
}
function $convertBlockquoteElement(element) {
  const node = $createQuoteNode();
  if (element.style !== null) {
    node.setFormat(element.style.textAlign);
    setNodeIndentFromDOM2(element, node);
  }
  return {
    node
  };
}
function $createHeadingNode(headingTag = "h1") {
  return $applyNodeReplacement2(new HeadingNode(headingTag));
}
function $isHeadingNode(node) {
  return node instanceof HeadingNode;
}
function onPasteForRichText(event, editor) {
  event.preventDefault();
  editor.update(() => {
    const selection = $getSelection2();
    const clipboardData = objectKlassEquals2(event, InputEvent) || objectKlassEquals2(event, KeyboardEvent) ? null : event.clipboardData;
    if (clipboardData != null && selection !== null) {
      $insertDataTransferForRichText2(clipboardData, selection, editor);
    }
  }, {
    tag: PASTE_TAG2
  });
}
async function onCutForRichText(event, editor) {
  await copyToClipboard2(editor, objectKlassEquals2(event, ClipboardEvent) ? event : null);
  editor.update(() => {
    const selection = $getSelection2();
    if ($isRangeSelection2(selection)) {
      selection.removeText();
    } else if ($isNodeSelection2(selection)) {
      selection.getNodes().forEach((node) => node.remove());
    }
  });
}
function eventFiles(event) {
  let dataTransfer = null;
  if (objectKlassEquals2(event, DragEvent)) {
    dataTransfer = event.dataTransfer;
  } else if (objectKlassEquals2(event, ClipboardEvent)) {
    dataTransfer = event.clipboardData;
  }
  if (dataTransfer === null) {
    return [false, [], false];
  }
  const types = dataTransfer.types;
  const hasFiles = types.includes("Files");
  const hasContent = types.includes("text/html") || types.includes("text/plain");
  return [hasFiles, Array.from(dataTransfer.files), hasContent];
}
function $handleIndentAndOutdent(indentOrOutdent) {
  const selection = $getSelection2();
  if (!$isRangeSelection2(selection)) {
    return false;
  }
  const alreadyHandled = /* @__PURE__ */ new Set();
  const nodes = selection.getNodes();
  for (let i2 = 0; i2 < nodes.length; i2++) {
    const node = nodes[i2];
    const key = node.getKey();
    if (alreadyHandled.has(key)) {
      continue;
    }
    const parentBlock = $findMatchingParent3(node, (parentNode) => $isElementNode2(parentNode) && !parentNode.isInline());
    if (parentBlock === null) {
      continue;
    }
    const parentKey = parentBlock.getKey();
    if (parentBlock.canIndent() && !alreadyHandled.has(parentKey)) {
      alreadyHandled.add(parentKey);
      indentOrOutdent(parentBlock);
    }
  }
  return alreadyHandled.size > 0;
}
function $isTargetWithinDecorator(target) {
  const node = $getNearestNodeFromDOMNode2(target);
  return $isDecoratorNode2(node);
}
function $isSelectionAtEndOfRoot(selection) {
  const focus = selection.focus;
  return focus.key === "root" && focus.offset === $getRoot2().getChildrenSize();
}
function $isSelectionCollapsedAtFrontOfIndentedBlock(selection) {
  if (!selection.isCollapsed()) {
    return false;
  }
  const {
    anchor
  } = selection;
  if (anchor.offset !== 0) {
    return false;
  }
  const anchorNode = anchor.getNode();
  if ($isRootNode2(anchorNode)) {
    return false;
  }
  const element = $getNearestBlockElementAncestorOrThrow2(anchorNode);
  return element.getIndent() > 0 && (element.is(anchorNode) || anchorNode.is(element.getFirstDescendant()));
}
function $resetCapitalization(selection) {
  for (const format of ["lowercase", "uppercase", "capitalize"]) {
    if (selection.hasFormat(format)) {
      selection.toggleFormat(format);
    }
  }
}
function registerRichText(editor) {
  const removeListener = mergeRegister2(editor.registerCommand(CLICK_COMMAND2, (payload) => {
    const selection = $getSelection2();
    if ($isNodeSelection2(selection)) {
      selection.clear();
      return true;
    }
    return false;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(DELETE_CHARACTER_COMMAND2, (isBackward) => {
    const selection = $getSelection2();
    if ($isRangeSelection2(selection)) {
      selection.deleteCharacter(isBackward);
      return true;
    } else if ($isNodeSelection2(selection)) {
      selection.deleteNodes();
      return true;
    }
    return false;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(DELETE_WORD_COMMAND2, (isBackward) => {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    selection.deleteWord(isBackward);
    return true;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(DELETE_LINE_COMMAND2, (isBackward) => {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    selection.deleteLine(isBackward);
    return true;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(CONTROLLED_TEXT_INSERTION_COMMAND2, (eventOrText) => {
    const selection = $getSelection2();
    if (typeof eventOrText === "string") {
      if (selection !== null) {
        selection.insertText(eventOrText);
      }
    } else {
      if (selection === null) {
        return false;
      }
      const dataTransfer = eventOrText.dataTransfer;
      if (dataTransfer != null) {
        $insertDataTransferForRichText2(dataTransfer, selection, editor);
      } else if ($isRangeSelection2(selection)) {
        const data = eventOrText.data;
        if (data) {
          selection.insertText(data);
        }
        return true;
      }
    }
    return true;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(REMOVE_TEXT_COMMAND2, () => {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    selection.removeText();
    return true;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(FORMAT_TEXT_COMMAND2, (format) => {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    selection.formatText(format);
    return true;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(FORMAT_ELEMENT_COMMAND2, (format) => {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection) && !$isNodeSelection2(selection)) {
      return false;
    }
    const nodes = selection.getNodes();
    for (const node of nodes) {
      const element = $findMatchingParent3(node, (parentNode) => $isElementNode2(parentNode) && !parentNode.isInline());
      if (element !== null) {
        element.setFormat(format);
      }
    }
    return true;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(INSERT_LINE_BREAK_COMMAND2, (selectStart) => {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    selection.insertLineBreak(selectStart);
    return true;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(INSERT_PARAGRAPH_COMMAND2, () => {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    selection.insertParagraph();
    return true;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(INSERT_TAB_COMMAND2, () => {
    $insertNodes2([$createTabNode2()]);
    return true;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(INDENT_CONTENT_COMMAND2, () => {
    return $handleIndentAndOutdent((block) => {
      const indent = block.getIndent();
      block.setIndent(indent + 1);
    });
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(OUTDENT_CONTENT_COMMAND2, () => {
    return $handleIndentAndOutdent((block) => {
      const indent = block.getIndent();
      if (indent > 0) {
        block.setIndent(Math.max(0, indent - 1));
      }
    });
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(KEY_ARROW_UP_COMMAND2, (event) => {
    const selection = $getSelection2();
    if ($isNodeSelection2(selection)) {
      const nodes = selection.getNodes();
      if (nodes.length > 0) {
        event.preventDefault();
        nodes[0].selectPrevious();
        return true;
      }
    } else if ($isRangeSelection2(selection)) {
      const possibleNode = $getAdjacentNode2(selection.focus, true);
      if (!event.shiftKey && $isDecoratorNode2(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {
        possibleNode.selectPrevious();
        event.preventDefault();
        return true;
      }
    }
    return false;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(KEY_ARROW_DOWN_COMMAND2, (event) => {
    const selection = $getSelection2();
    if ($isNodeSelection2(selection)) {
      const nodes = selection.getNodes();
      if (nodes.length > 0) {
        event.preventDefault();
        nodes[0].selectNext(0, 0);
        return true;
      }
    } else if ($isRangeSelection2(selection)) {
      if ($isSelectionAtEndOfRoot(selection)) {
        event.preventDefault();
        return true;
      }
      const possibleNode = $getAdjacentNode2(selection.focus, false);
      if (!event.shiftKey && $isDecoratorNode2(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {
        possibleNode.selectNext();
        event.preventDefault();
        return true;
      }
    }
    return false;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(KEY_ARROW_LEFT_COMMAND2, (event) => {
    const selection = $getSelection2();
    if ($isNodeSelection2(selection)) {
      const nodes = selection.getNodes();
      if (nodes.length > 0) {
        event.preventDefault();
        if ($isParentRTL2(nodes[0])) {
          nodes[0].selectNext(0, 0);
        } else {
          nodes[0].selectPrevious();
        }
        return true;
      }
    }
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    if ($shouldOverrideDefaultCharacterSelection2(selection, true)) {
      const isHoldingShift = event.shiftKey;
      event.preventDefault();
      $moveCharacter2(selection, isHoldingShift, true);
      return true;
    }
    return false;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(KEY_ARROW_RIGHT_COMMAND2, (event) => {
    const selection = $getSelection2();
    if ($isNodeSelection2(selection)) {
      const nodes = selection.getNodes();
      if (nodes.length > 0) {
        event.preventDefault();
        if ($isParentRTL2(nodes[0])) {
          nodes[0].selectPrevious();
        } else {
          nodes[0].selectNext(0, 0);
        }
        return true;
      }
    }
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    const isHoldingShift = event.shiftKey;
    if ($shouldOverrideDefaultCharacterSelection2(selection, false)) {
      event.preventDefault();
      $moveCharacter2(selection, isHoldingShift, false);
      return true;
    }
    return false;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(KEY_BACKSPACE_COMMAND2, (event) => {
    if ($isTargetWithinDecorator(event.target)) {
      return false;
    }
    const selection = $getSelection2();
    if ($isRangeSelection2(selection)) {
      if ($isSelectionCollapsedAtFrontOfIndentedBlock(selection)) {
        event.preventDefault();
        return editor.dispatchCommand(OUTDENT_CONTENT_COMMAND2, void 0);
      }
      if (IS_IOS4 && navigator.language === "ko-KR") {
        return false;
      }
    } else if (!$isNodeSelection2(selection)) {
      return false;
    }
    event.preventDefault();
    return editor.dispatchCommand(DELETE_CHARACTER_COMMAND2, true);
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(KEY_DELETE_COMMAND2, (event) => {
    if ($isTargetWithinDecorator(event.target)) {
      return false;
    }
    const selection = $getSelection2();
    if (!($isRangeSelection2(selection) || $isNodeSelection2(selection))) {
      return false;
    }
    event.preventDefault();
    return editor.dispatchCommand(DELETE_CHARACTER_COMMAND2, false);
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(KEY_ENTER_COMMAND2, (event) => {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    $resetCapitalization(selection);
    if (event !== null) {
      if ((IS_IOS4 || IS_SAFARI4 || IS_APPLE_WEBKIT4) && CAN_USE_BEFORE_INPUT4) {
        return false;
      }
      event.preventDefault();
      if (event.shiftKey) {
        return editor.dispatchCommand(INSERT_LINE_BREAK_COMMAND2, false);
      }
    }
    return editor.dispatchCommand(INSERT_PARAGRAPH_COMMAND2, void 0);
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(KEY_ESCAPE_COMMAND2, () => {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    editor.blur();
    return true;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(DROP_COMMAND2, (event) => {
    const [, files] = eventFiles(event);
    if (files.length > 0) {
      const x = event.clientX;
      const y2 = event.clientY;
      const eventRange = caretFromPoint(x, y2);
      if (eventRange !== null) {
        const {
          offset: domOffset,
          node: domNode
        } = eventRange;
        const node = $getNearestNodeFromDOMNode2(domNode);
        if (node !== null) {
          const selection2 = $createRangeSelection2();
          if ($isTextNode2(node)) {
            selection2.anchor.set(node.getKey(), domOffset, "text");
            selection2.focus.set(node.getKey(), domOffset, "text");
          } else {
            const parentKey = node.getParentOrThrow().getKey();
            const offset = node.getIndexWithinParent() + 1;
            selection2.anchor.set(parentKey, offset, "element");
            selection2.focus.set(parentKey, offset, "element");
          }
          const normalizedSelection = $normalizeSelection__EXPERIMENTAL(selection2);
          $setSelection2(normalizedSelection);
        }
        editor.dispatchCommand(DRAG_DROP_PASTE, files);
      }
      event.preventDefault();
      return true;
    }
    const selection = $getSelection2();
    if ($isRangeSelection2(selection)) {
      return true;
    }
    return false;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(DRAGSTART_COMMAND2, (event) => {
    const [isFileTransfer] = eventFiles(event);
    const selection = $getSelection2();
    if (isFileTransfer && !$isRangeSelection2(selection)) {
      return false;
    }
    return true;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(DRAGOVER_COMMAND2, (event) => {
    const [isFileTransfer] = eventFiles(event);
    const selection = $getSelection2();
    if (isFileTransfer && !$isRangeSelection2(selection)) {
      return false;
    }
    const x = event.clientX;
    const y2 = event.clientY;
    const eventRange = caretFromPoint(x, y2);
    if (eventRange !== null) {
      const node = $getNearestNodeFromDOMNode2(eventRange.node);
      if ($isDecoratorNode2(node)) {
        event.preventDefault();
      }
    }
    return true;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(SELECT_ALL_COMMAND2, () => {
    $selectAll2();
    return true;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(COPY_COMMAND2, (event) => {
    copyToClipboard2(editor, objectKlassEquals2(event, ClipboardEvent) ? event : null);
    return true;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(CUT_COMMAND2, (event) => {
    onCutForRichText(event, editor);
    return true;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(PASTE_COMMAND2, (event) => {
    const [, files, hasTextContent] = eventFiles(event);
    if (files.length > 0 && !hasTextContent) {
      editor.dispatchCommand(DRAG_DROP_PASTE, files);
      return true;
    }
    if (isDOMNode2(event.target) && isSelectionCapturedInDecoratorInput2(event.target)) {
      return false;
    }
    const selection = $getSelection2();
    if (selection !== null) {
      onPasteForRichText(event, editor);
      return true;
    }
    return false;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(KEY_SPACE_COMMAND2, (_2) => {
    const selection = $getSelection2();
    if ($isRangeSelection2(selection)) {
      $resetCapitalization(selection);
    }
    return false;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(KEY_TAB_COMMAND2, (_2) => {
    const selection = $getSelection2();
    if ($isRangeSelection2(selection)) {
      $resetCapitalization(selection);
    }
    return false;
  }, COMMAND_PRIORITY_EDITOR2));
  return removeListener;
}
var RichTextExtension = defineExtension2({
  conflictsWith: ["@lexical/plain-text"],
  dependencies: [DragonExtension2],
  name: "@lexical/rich-text",
  nodes: () => [HeadingNode, QuoteNode],
  register: registerRichText
});

// node_modules/@lexical/rich-text/LexicalRichText.mjs
var mod8 = true ? LexicalRichText_dev_exports : LexicalRichText_prod_exports;
var $createHeadingNode2 = mod8.$createHeadingNode;
var $createQuoteNode2 = mod8.$createQuoteNode;
var $isHeadingNode2 = mod8.$isHeadingNode;
var $isQuoteNode2 = mod8.$isQuoteNode;
var DRAG_DROP_PASTE2 = mod8.DRAG_DROP_PASTE;
var HeadingNode2 = mod8.HeadingNode;
var QuoteNode2 = mod8.QuoteNode;
var RichTextExtension2 = mod8.RichTextExtension;
var eventFiles2 = mod8.eventFiles;
var registerRichText2 = mod8.registerRichText;

// node_modules/@lexical/hashtag/LexicalHashtag.dev.mjs
var LexicalHashtag_dev_exports = {};
__export(LexicalHashtag_dev_exports, {
  $createHashtagNode: () => $createHashtagNode,
  $isHashtagNode: () => $isHashtagNode,
  HashtagExtension: () => HashtagExtension,
  HashtagNode: () => HashtagNode,
  registerLexicalHashtag: () => registerLexicalHashtag
});

// node_modules/@lexical/text/LexicalText.dev.mjs
var LexicalText_dev_exports = {};
__export(LexicalText_dev_exports, {
  $canShowPlaceholder: () => $canShowPlaceholder,
  $canShowPlaceholderCurry: () => $canShowPlaceholderCurry,
  $findTextIntersectionFromCharacters: () => $findTextIntersectionFromCharacters,
  $isRootTextContentEmpty: () => $isRootTextContentEmpty,
  $isRootTextContentEmptyCurry: () => $isRootTextContentEmptyCurry,
  $rootTextContent: () => $rootTextContent,
  registerLexicalTextEntity: () => registerLexicalTextEntity
});
function $rootTextContent() {
  const root = $getRoot2();
  return root.getTextContent();
}
function $isRootTextContentEmpty(isEditorComposing, trim = true) {
  if (isEditorComposing) {
    return false;
  }
  let text = $rootTextContent();
  if (trim) {
    text = text.trim();
  }
  return text === "";
}
function $isRootTextContentEmptyCurry(isEditorComposing, trim) {
  return () => $isRootTextContentEmpty(isEditorComposing, trim);
}
function $canShowPlaceholder(isComposing) {
  if (!$isRootTextContentEmpty(isComposing, false)) {
    return false;
  }
  const root = $getRoot2();
  const children = root.getChildren();
  const childrenLength = children.length;
  if (childrenLength > 1) {
    return false;
  }
  for (let i2 = 0; i2 < childrenLength; i2++) {
    const topBlock = children[i2];
    if ($isDecoratorNode2(topBlock)) {
      return false;
    }
    if ($isElementNode2(topBlock)) {
      if (!$isParagraphNode2(topBlock)) {
        return false;
      }
      if (topBlock.__indent !== 0) {
        return false;
      }
      const topBlockChildren = topBlock.getChildren();
      const topBlockChildrenLength = topBlockChildren.length;
      for (let s2 = 0; s2 < topBlockChildrenLength; s2++) {
        const child = topBlockChildren[i2];
        if (!$isTextNode2(child)) {
          return false;
        }
      }
    }
  }
  return true;
}
function $canShowPlaceholderCurry(isEditorComposing) {
  return () => $canShowPlaceholder(isEditorComposing);
}
function $findTextIntersectionFromCharacters(root, targetCharacters) {
  let node = root.getFirstChild();
  let currentCharacters = 0;
  mainLoop: while (node !== null) {
    if ($isElementNode2(node)) {
      const child = node.getFirstChild();
      if (child !== null) {
        node = child;
        continue;
      }
    } else if ($isTextNode2(node)) {
      const characters = node.getTextContentSize();
      if (currentCharacters + characters > targetCharacters) {
        return {
          node,
          offset: targetCharacters - currentCharacters
        };
      }
      currentCharacters += characters;
    }
    const sibling = node.getNextSibling();
    if (sibling !== null) {
      node = sibling;
      continue;
    }
    let parent = node.getParent();
    while (parent !== null) {
      const parentSibling = parent.getNextSibling();
      if (parentSibling !== null) {
        node = parentSibling;
        continue mainLoop;
      }
      parent = parent.getParent();
    }
    break;
  }
  return null;
}
function formatDevErrorMessage6(message) {
  throw new Error(message);
}
function registerLexicalTextEntity(editor, getMatch, targetNode, createNode) {
  const isTargetNode = (node) => {
    return node instanceof targetNode;
  };
  const $replaceWithSimpleText = (node) => {
    const textNode = $createTextNode2(node.getTextContent());
    textNode.setFormat(node.getFormat());
    node.replace(textNode);
  };
  const getMode = (node) => {
    return node.getLatest().__mode;
  };
  const $textNodeTransform2 = (node) => {
    if (!node.isSimpleText()) {
      return;
    }
    let prevSibling = node.getPreviousSibling();
    let text = node.getTextContent();
    let currentNode = node;
    let match;
    if ($isTextNode2(prevSibling)) {
      const previousText = prevSibling.getTextContent();
      const combinedText = previousText + text;
      const prevMatch = getMatch(combinedText);
      if (isTargetNode(prevSibling)) {
        if (prevMatch === null || getMode(prevSibling) !== 0) {
          $replaceWithSimpleText(prevSibling);
          return;
        } else {
          const diff = prevMatch.end - previousText.length;
          if (diff > 0) {
            const concatText = text.slice(0, diff);
            const newTextContent = previousText + concatText;
            prevSibling.select();
            prevSibling.setTextContent(newTextContent);
            if (diff === text.length) {
              node.remove();
            } else {
              const remainingText = text.slice(diff);
              node.setTextContent(remainingText);
            }
            return;
          }
        }
      } else if (prevMatch === null || prevMatch.start < previousText.length) {
        return;
      }
    }
    let prevMatchLengthToSkip = 0;
    while (true) {
      match = getMatch(text);
      let nextText = match === null ? "" : text.slice(match.end);
      text = nextText;
      if (nextText === "") {
        const nextSibling = currentNode.getNextSibling();
        if ($isTextNode2(nextSibling)) {
          nextText = currentNode.getTextContent() + nextSibling.getTextContent();
          const nextMatch = getMatch(nextText);
          if (nextMatch === null) {
            if (isTargetNode(nextSibling)) {
              $replaceWithSimpleText(nextSibling);
            } else {
              nextSibling.markDirty();
            }
            return;
          } else if (nextMatch.start !== 0) {
            return;
          }
        }
      }
      if (match === null) {
        return;
      }
      if (match.start === 0 && $isTextNode2(prevSibling) && prevSibling.isTextEntity()) {
        prevMatchLengthToSkip += match.end;
        continue;
      }
      let nodeToReplace;
      if (match.start === 0) {
        [nodeToReplace, currentNode] = currentNode.splitText(match.end);
      } else {
        [, nodeToReplace, currentNode] = currentNode.splitText(match.start + prevMatchLengthToSkip, match.end + prevMatchLengthToSkip);
      }
      if (!(nodeToReplace !== void 0)) {
        formatDevErrorMessage6(`${"nodeToReplace"} should not be undefined. You may want to check splitOffsets passed to the splitText.`);
      }
      const replacementNode = createNode(nodeToReplace);
      replacementNode.setFormat(nodeToReplace.getFormat());
      nodeToReplace.replace(replacementNode);
      if (currentNode == null) {
        return;
      }
      prevMatchLengthToSkip = 0;
      prevSibling = replacementNode;
    }
  };
  const $reverseNodeTransform = (node) => {
    const text = node.getTextContent();
    const match = getMatch(text);
    if (match === null || match.start !== 0) {
      $replaceWithSimpleText(node);
      return;
    }
    if (text.length > match.end) {
      node.splitText(match.end);
      return;
    }
    const prevSibling = node.getPreviousSibling();
    if ($isTextNode2(prevSibling) && prevSibling.isTextEntity()) {
      $replaceWithSimpleText(prevSibling);
      $replaceWithSimpleText(node);
    }
    const nextSibling = node.getNextSibling();
    if ($isTextNode2(nextSibling) && nextSibling.isTextEntity()) {
      $replaceWithSimpleText(nextSibling);
      if (isTargetNode(node)) {
        $replaceWithSimpleText(node);
      }
    }
  };
  const removePlainTextTransform = editor.registerNodeTransform(TextNode2, $textNodeTransform2);
  const removeReverseNodeTransform = editor.registerNodeTransform(targetNode, $reverseNodeTransform);
  return [removePlainTextTransform, removeReverseNodeTransform];
}

// node_modules/@lexical/text/LexicalText.mjs
var mod9 = true ? LexicalText_dev_exports : LexicalText_prod_exports;
var $canShowPlaceholder2 = mod9.$canShowPlaceholder;
var $canShowPlaceholderCurry2 = mod9.$canShowPlaceholderCurry;
var $findTextIntersectionFromCharacters2 = mod9.$findTextIntersectionFromCharacters;
var $isRootTextContentEmpty2 = mod9.$isRootTextContentEmpty;
var $isRootTextContentEmptyCurry2 = mod9.$isRootTextContentEmptyCurry;
var $rootTextContent2 = mod9.$rootTextContent;
var registerLexicalTextEntity2 = mod9.registerLexicalTextEntity;

// node_modules/@lexical/hashtag/LexicalHashtag.dev.mjs
var HashtagNode = class _HashtagNode extends TextNode2 {
  static getType() {
    return "hashtag";
  }
  static clone(node) {
    return new _HashtagNode(node.__text, node.__key);
  }
  createDOM(config) {
    const element = super.createDOM(config);
    addClassNamesToElement2(element, config.theme.hashtag);
    return element;
  }
  static importJSON(serializedNode) {
    return $createHashtagNode().updateFromJSON(serializedNode);
  }
  canInsertTextBefore() {
    return false;
  }
  isTextEntity() {
    return true;
  }
};
function $createHashtagNode(text = "") {
  return $applyNodeReplacement2(new HashtagNode(text));
}
function $isHashtagNode(node) {
  return node instanceof HashtagNode;
}
function getHashtagRegexStringChars() {
  const latinAccents = "\xC0-\xD6\xD8-\xF6\xF8-\xFF\u0100-\u024F\u0253-\u0254\u0256-\u0257\u0259\u025B\u0263\u0268\u026F\u0272\u0289\u028B\u02BB\u0300-\u036F\u1E00-\u1EFF";
  const nonLatinChars = "\u0400-\u04FF\u0500-\u0527\u2DE0-\u2DFF\uA640-\uA69F\u0591-\u05BF\u05C1-\u05C2\u05C4-\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F4\uFB12-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40-\uFB41\uFB43-\uFB44\uFB46-\uFB4F\u0610-\u061A\u0620-\u065F\u066E-\u06D3\u06D5-\u06DC\u06DE-\u06E8\u06EA-\u06EF\u06FA-\u06FC\u06FF\u0750-\u077F\u08A0\u08A2-\u08AC\u08E4-\u08FE\uFB50-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\u200C-\u200C\u0E01-\u0E3A\u0E40-\u0E4E\u1100-\u11FF\u3130-\u3185\uA960-\uA97F\uAC00-\uD7AF\uD7B0-\uD7FF\uFFA1-\uFFDC";
  const charCode = String.fromCharCode;
  const cjkChars = "\u30A1-\u30FA\u30FC-\u30FE\uFF66-\uFF9F\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\u3041-\u3096\u3099-\u309E\u3400-\u4DBF\u4E00-\u9FFF" + // Kanji (Unified)
  // Disabled as it breaks the Regex.
  // charCode(0x20000) + '-' + charCode(0x2A6DF) + // Kanji (CJK Extension B)
  charCode(173824) + "-" + charCode(177983) + // Kanji (CJK Extension C)
  charCode(177984) + "-" + charCode(178207) + // Kanji (CJK Extension D)
  charCode(194560) + "-" + charCode(195103) + "\u3003\u3005\u303B";
  const otherChars = latinAccents + nonLatinChars + cjkChars;
  const unicodeLetters = "A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u0241\u0250-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EE\u037A\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03CE\u03D0-\u03F5\u03F7-\u0481\u048A-\u04CE\u04D0-\u04F9\u0500-\u050F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0621-\u063A\u0640-\u064A\u066E-\u066F\u0671-\u06D3\u06D5\u06E5-\u06E6\u06EE-\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u076D\u0780-\u07A5\u07B1\u0904-\u0939\u093D\u0950\u0958-\u0961\u097D\u0985-\u098C\u098F-\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC-\u09DD\u09DF-\u09E1\u09F0-\u09F1\u0A05-\u0A0A\u0A0F-\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32-\u0A33\u0A35-\u0A36\u0A38-\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2-\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0-\u0AE1\u0B05-\u0B0C\u0B0F-\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32-\u0B33\u0B35-\u0B39\u0B3D\u0B5C-\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99-\u0B9A\u0B9C\u0B9E-\u0B9F\u0BA3-\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C60-\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0-\u0CE1\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D28\u0D2A-\u0D39\u0D60-\u0D61\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32-\u0E33\u0E40-\u0E46\u0E81-\u0E82\u0E84\u0E87-\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA-\u0EAB\u0EAD-\u0EB0\u0EB2-\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDD\u0F00\u0F40-\u0F47\u0F49-\u0F6A\u0F88-\u0F8B\u1000-\u1021\u1023-\u1027\u1029-\u102A\u1050-\u1055\u10A0-\u10C5\u10D0-\u10FA\u10FC\u1100-\u1159\u115F-\u11A2\u11A8-\u11F9\u1200-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u1676\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19A9\u19C1-\u19C7\u1A00-\u1A16\u1D00-\u1DBF\u1E00-\u1E9B\u1EA0-\u1EF9\u1F00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u2094\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2131\u2133-\u2139\u213C-\u213F\u2145-\u2149\u2C00-\u2C2E\u2C30-\u2C5E\u2C80-\u2CE4\u2D00-\u2D25\u2D30-\u2D65\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3006\u3031-\u3035\u303B-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312C\u3131-\u318E\u31A0-\u31B7\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FBB\uA000-\uA48C\uA800-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uAC00-\uD7A3\uF900-\uFA2D\uFA30-\uFA6A\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40-\uFB41\uFB43-\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
  const unicodeAccents = "\u0300-\u036F\u0483-\u0486\u0591-\u05B9\u05BB-\u05BD\u05BF\u05C1-\u05C2\u05C4-\u05C5\u05C7\u0610-\u0615\u064B-\u065E\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7-\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u0901-\u0903\u093C\u093E-\u094D\u0951-\u0954\u0962-\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7-\u09C8\u09CB-\u09CD\u09D7\u09E2-\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47-\u0A48\u0A4B-\u0A4D\u0A70-\u0A71\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2-\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B43\u0B47-\u0B48\u0B4B-\u0B4D\u0B56-\u0B57\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C01-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55-\u0C56\u0C82-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5-\u0CD6\u0D02-\u0D03\u0D3E-\u0D43\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D82-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2-\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB-\u0EBC\u0EC8-\u0ECD\u0F18-\u0F19\u0F35\u0F37\u0F39\u0F3E-\u0F3F\u0F71-\u0F84\u0F86-\u0F87\u0F90-\u0F97\u0F99-\u0FBC\u0FC6\u102C-\u1032\u1036-\u1039\u1056-\u1059\u135F\u1712-\u1714\u1732-\u1734\u1752-\u1753\u1772-\u1773\u17B6-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8-\u19C9\u1A17-\u1A1B\u1DC0-\u1DC3\u20D0-\u20DC\u20E1\u20E5-\u20EB\u302A-\u302F\u3099-\u309A\uA802\uA806\uA80B\uA823-\uA827\uFB1E\uFE00-\uFE0F\uFE20-\uFE23";
  const unicodeDigits = "0-9\u0660-\u0669\u06F0-\u06F9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\uFF10-\uFF19";
  const alpha = unicodeLetters + otherChars;
  const numeric = unicodeDigits + "_";
  const alphanumeric = alpha + unicodeAccents + numeric;
  const hashChars = "#\\uFF03";
  return {
    alpha,
    alphanumeric,
    hashChars
  };
}
function getHashtagRegexString() {
  const {
    alpha,
    alphanumeric,
    hashChars
  } = getHashtagRegexStringChars();
  const hashtagAlpha = "[" + alpha + "]";
  const hashtagAlphanumeric = "[" + alphanumeric + "]";
  const hashtagBoundary = "^|$|[^&/" + alphanumeric + "]";
  const hashCharList = "[" + hashChars + "]";
  const hashtag = "(" + hashtagBoundary + ")(" + hashCharList + ")(" + hashtagAlphanumeric + "*" + hashtagAlpha + hashtagAlphanumeric + "*)";
  return hashtag;
}
var REGEX = new RegExp(getHashtagRegexString(), "i");
function getHashtagMatch(text) {
  const matchArr = REGEX.exec(text);
  if (matchArr === null) {
    return null;
  }
  const hashtagLength = matchArr[3].length + 1;
  const startOffset = matchArr.index + matchArr[1].length;
  const endOffset = startOffset + hashtagLength;
  return {
    end: endOffset,
    start: startOffset
  };
}
var defaultHashtagConfig = {
  getHashtagMatch
};
function registerLexicalHashtag(editor, config = defaultHashtagConfig) {
  return mergeRegister2(...registerLexicalTextEntity2(editor, config.getHashtagMatch, HashtagNode, (textNode) => $createHashtagNode(textNode.getTextContent())));
}
var HashtagExtension = defineExtension2({
  config: defaultHashtagConfig,
  name: "@lexical/hashtag/Hashtag",
  nodes: () => [HashtagNode],
  register: registerLexicalHashtag
});

// node_modules/@lexical/hashtag/LexicalHashtag.mjs
var mod10 = true ? LexicalHashtag_dev_exports : LexicalHashtag_prod_exports;
var $createHashtagNode2 = mod10.$createHashtagNode;
var $isHashtagNode2 = mod10.$isHashtagNode;
var HashtagExtension2 = mod10.HashtagExtension;
var HashtagNode2 = mod10.HashtagNode;
var registerLexicalHashtag2 = mod10.registerLexicalHashtag;

// node_modules/@lexical/code/LexicalCode.dev.mjs
var LexicalCode_dev_exports = {};
__export(LexicalCode_dev_exports, {
  $createCodeHighlightNode: () => $createCodeHighlightNode,
  $createCodeNode: () => $createCodeNode,
  $getCodeLineDirection: () => $getCodeLineDirection,
  $getEndOfCodeInLine: () => $getEndOfCodeInLine,
  $getFirstCodeNodeOfLine: () => $getFirstCodeNodeOfLine,
  $getLastCodeNodeOfLine: () => $getLastCodeNodeOfLine,
  $getStartOfCodeInLine: () => $getStartOfCodeInLine,
  $isCodeHighlightNode: () => $isCodeHighlightNode,
  $isCodeNode: () => $isCodeNode,
  CODE_LANGUAGE_FRIENDLY_NAME_MAP: () => CODE_LANGUAGE_FRIENDLY_NAME_MAP,
  CODE_LANGUAGE_MAP: () => CODE_LANGUAGE_MAP,
  CodeExtension: () => CodeExtension,
  CodeHighlightNode: () => CodeHighlightNode,
  CodeNode: () => CodeNode,
  DEFAULT_CODE_LANGUAGE: () => DEFAULT_CODE_LANGUAGE,
  PrismTokenizer: () => PrismTokenizer,
  getCodeLanguageOptions: () => getCodeLanguageOptions,
  getCodeLanguages: () => getCodeLanguages,
  getCodeThemeOptions: () => getCodeThemeOptions,
  getDefaultCodeLanguage: () => getDefaultCodeLanguage,
  getEndOfCodeInLine: () => getEndOfCodeInLine,
  getFirstCodeNodeOfLine: () => getFirstCodeNodeOfLine,
  getLanguageFriendlyName: () => getLanguageFriendlyName,
  getLastCodeNodeOfLine: () => getLastCodeNodeOfLine,
  getStartOfCodeInLine: () => getStartOfCodeInLine,
  normalizeCodeLang: () => normalizeCodeLang,
  normalizeCodeLanguage: () => normalizeCodeLang,
  registerCodeHighlighting: () => registerCodeHighlighting
});
var import_prismjs = __toESM(require_prism(), 1);

// node_modules/prismjs/components/prism-clike.js
Prism.languages.clike = {
  "comment": [
    {
      pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
      lookbehind: true,
      greedy: true
    },
    {
      pattern: /(^|[^\\:])\/\/.*/,
      lookbehind: true,
      greedy: true
    }
  ],
  "string": {
    pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
    greedy: true
  },
  "class-name": {
    pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
    lookbehind: true,
    inside: {
      "punctuation": /[.\\]/
    }
  },
  "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
  "boolean": /\b(?:false|true)\b/,
  "function": /\b\w+(?=\()/,
  "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
  "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
  "punctuation": /[{}[\];(),.:]/
};

// node_modules/prismjs/components/prism-javascript.js
Prism.languages.javascript = Prism.languages.extend("clike", {
  "class-name": [
    Prism.languages.clike["class-name"],
    {
      pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
      lookbehind: true
    }
  ],
  "keyword": [
    {
      pattern: /((?:^|\})\s*)catch\b/,
      lookbehind: true
    },
    {
      pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
      lookbehind: true
    }
  ],
  // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
  "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
  "number": {
    pattern: RegExp(
      /(^|[^\w$])/.source + "(?:" + // constant
      (/NaN|Infinity/.source + "|" + // binary integer
      /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
      /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
      /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
      /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
      /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
    ),
    lookbehind: true
  },
  "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
});
Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
Prism.languages.insertBefore("javascript", "keyword", {
  "regex": {
    pattern: RegExp(
      // lookbehind
      // eslint-disable-next-line regexp/no-dupe-characters-character-class
      /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
      // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
      // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
      // with the only syntax, so we have to define 2 different regex patterns.
      /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
      /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
      /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
    ),
    lookbehind: true,
    greedy: true,
    inside: {
      "regex-source": {
        pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
        lookbehind: true,
        alias: "language-regex",
        inside: Prism.languages.regex
      },
      "regex-delimiter": /^\/|\/$/,
      "regex-flags": /^[a-z]+$/
    }
  },
  // This must be declared before keyword because we use "function" inside the look-forward
  "function-variable": {
    pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
    alias: "function"
  },
  "parameter": [
    {
      pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
      lookbehind: true,
      inside: Prism.languages.javascript
    },
    {
      pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
      lookbehind: true,
      inside: Prism.languages.javascript
    },
    {
      pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
      lookbehind: true,
      inside: Prism.languages.javascript
    },
    {
      pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
      lookbehind: true,
      inside: Prism.languages.javascript
    }
  ],
  "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
});
Prism.languages.insertBefore("javascript", "string", {
  "hashbang": {
    pattern: /^#!.*/,
    greedy: true,
    alias: "comment"
  },
  "template-string": {
    pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
    greedy: true,
    inside: {
      "template-punctuation": {
        pattern: /^`|`$/,
        alias: "string"
      },
      "interpolation": {
        pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
        lookbehind: true,
        inside: {
          "interpolation-punctuation": {
            pattern: /^\$\{|\}$/,
            alias: "punctuation"
          },
          rest: Prism.languages.javascript
        }
      },
      "string": /[\s\S]+/
    }
  },
  "string-property": {
    pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
    lookbehind: true,
    greedy: true,
    alias: "property"
  }
});
Prism.languages.insertBefore("javascript", "operator", {
  "literal-property": {
    pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
    lookbehind: true,
    alias: "property"
  }
});
if (Prism.languages.markup) {
  Prism.languages.markup.tag.addInlined("script", "javascript");
  Prism.languages.markup.tag.addAttribute(
    /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
    "javascript"
  );
}
Prism.languages.js = Prism.languages.javascript;

// node_modules/prismjs/components/prism-markup.js
Prism.languages.markup = {
  "comment": {
    pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
    greedy: true
  },
  "prolog": {
    pattern: /<\?[\s\S]+?\?>/,
    greedy: true
  },
  "doctype": {
    // https://www.w3.org/TR/xml/#NT-doctypedecl
    pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
    greedy: true,
    inside: {
      "internal-subset": {
        pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
        lookbehind: true,
        greedy: true,
        inside: null
        // see below
      },
      "string": {
        pattern: /"[^"]*"|'[^']*'/,
        greedy: true
      },
      "punctuation": /^<!|>$|[[\]]/,
      "doctype-tag": /^DOCTYPE/i,
      "name": /[^\s<>'"]+/
    }
  },
  "cdata": {
    pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
    greedy: true
  },
  "tag": {
    pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
    greedy: true,
    inside: {
      "tag": {
        pattern: /^<\/?[^\s>\/]+/,
        inside: {
          "punctuation": /^<\/?/,
          "namespace": /^[^\s>\/:]+:/
        }
      },
      "special-attr": [],
      "attr-value": {
        pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
        inside: {
          "punctuation": [
            {
              pattern: /^=/,
              alias: "attr-equals"
            },
            {
              pattern: /^(\s*)["']|["']$/,
              lookbehind: true
            }
          ]
        }
      },
      "punctuation": /\/?>/,
      "attr-name": {
        pattern: /[^\s>\/]+/,
        inside: {
          "namespace": /^[^\s>\/:]+:/
        }
      }
    }
  },
  "entity": [
    {
      pattern: /&[\da-z]{1,8};/i,
      alias: "named-entity"
    },
    /&#x?[\da-f]{1,8};/i
  ]
};
Prism.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism.languages.markup["entity"];
Prism.languages.markup["doctype"].inside["internal-subset"].inside = Prism.languages.markup;
Prism.hooks.add("wrap", function(env) {
  if (env.type === "entity") {
    env.attributes["title"] = env.content.replace(/&amp;/, "&");
  }
});
Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
  /**
   * Adds an inlined language to markup.
   *
   * An example of an inlined language is CSS with `<style>` tags.
   *
   * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
   * case insensitive.
   * @param {string} lang The language key.
   * @example
   * addInlined('style', 'css');
   */
  value: function addInlined(tagName, lang) {
    var includedCdataInside = {};
    includedCdataInside["language-" + lang] = {
      pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
      lookbehind: true,
      inside: Prism.languages[lang]
    };
    includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
    var inside = {
      "included-cdata": {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        inside: includedCdataInside
      }
    };
    inside["language-" + lang] = {
      pattern: /[\s\S]+/,
      inside: Prism.languages[lang]
    };
    var def = {};
    def[tagName] = {
      pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
        return tagName;
      }), "i"),
      lookbehind: true,
      greedy: true,
      inside
    };
    Prism.languages.insertBefore("markup", "cdata", def);
  }
});
Object.defineProperty(Prism.languages.markup.tag, "addAttribute", {
  /**
   * Adds an pattern to highlight languages embedded in HTML attributes.
   *
   * An example of an inlined language is CSS with `style` attributes.
   *
   * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
   * case insensitive.
   * @param {string} lang The language key.
   * @example
   * addAttribute('style', 'css');
   */
  value: function(attrName, lang) {
    Prism.languages.markup.tag.inside["special-attr"].push({
      pattern: RegExp(
        /(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
        "i"
      ),
      lookbehind: true,
      inside: {
        "attr-name": /^[^\s=]+/,
        "attr-value": {
          pattern: /=[\s\S]+/,
          inside: {
            "value": {
              pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
              lookbehind: true,
              alias: [lang, "language-" + lang],
              inside: Prism.languages[lang]
            },
            "punctuation": [
              {
                pattern: /^=/,
                alias: "attr-equals"
              },
              /"|'/
            ]
          }
        }
      }
    });
  }
});
Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;
Prism.languages.xml = Prism.languages.extend("markup", {});
Prism.languages.ssml = Prism.languages.xml;
Prism.languages.atom = Prism.languages.xml;
Prism.languages.rss = Prism.languages.xml;

// node_modules/prismjs/components/prism-markdown.js
(function(Prism2) {
  var inner = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
  function createInline(pattern) {
    pattern = pattern.replace(/<inner>/g, function() {
      return inner;
    });
    return RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + pattern + ")");
  }
  var tableCell = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source;
  var tableRow = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function() {
    return tableCell;
  });
  var tableLine = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
  Prism2.languages.markdown = Prism2.languages.extend("markup", {});
  Prism2.languages.insertBefore("markdown", "prolog", {
    "front-matter-block": {
      pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
      lookbehind: true,
      greedy: true,
      inside: {
        "punctuation": /^---|---$/,
        "front-matter": {
          pattern: /\S+(?:\s+\S+)*/,
          alias: ["yaml", "language-yaml"],
          inside: Prism2.languages.yaml
        }
      }
    },
    "blockquote": {
      // > ...
      pattern: /^>(?:[\t ]*>)*/m,
      alias: "punctuation"
    },
    "table": {
      pattern: RegExp("^" + tableRow + tableLine + "(?:" + tableRow + ")*", "m"),
      inside: {
        "table-data-rows": {
          pattern: RegExp("^(" + tableRow + tableLine + ")(?:" + tableRow + ")*$"),
          lookbehind: true,
          inside: {
            "table-data": {
              pattern: RegExp(tableCell),
              inside: Prism2.languages.markdown
            },
            "punctuation": /\|/
          }
        },
        "table-line": {
          pattern: RegExp("^(" + tableRow + ")" + tableLine + "$"),
          lookbehind: true,
          inside: {
            "punctuation": /\||:?-{3,}:?/
          }
        },
        "table-header-row": {
          pattern: RegExp("^" + tableRow + "$"),
          inside: {
            "table-header": {
              pattern: RegExp(tableCell),
              alias: "important",
              inside: Prism2.languages.markdown
            },
            "punctuation": /\|/
          }
        }
      }
    },
    "code": [
      {
        // Prefixed by 4 spaces or 1 tab and preceded by an empty line
        pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
        lookbehind: true,
        alias: "keyword"
      },
      {
        // ```optional language
        // code block
        // ```
        pattern: /^```[\s\S]*?^```$/m,
        greedy: true,
        inside: {
          "code-block": {
            pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
            lookbehind: true
          },
          "code-language": {
            pattern: /^(```).+/,
            lookbehind: true
          },
          "punctuation": /```/
        }
      }
    ],
    "title": [
      {
        // title 1
        // =======
        // title 2
        // -------
        pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
        alias: "important",
        inside: {
          punctuation: /==+$|--+$/
        }
      },
      {
        // # title 1
        // ###### title 6
        pattern: /(^\s*)#.+/m,
        lookbehind: true,
        alias: "important",
        inside: {
          punctuation: /^#+|#+$/
        }
      }
    ],
    "hr": {
      // ***
      // ---
      // * * *
      // -----------
      pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
      lookbehind: true,
      alias: "punctuation"
    },
    "list": {
      // * item
      // + item
      // - item
      // 1. item
      pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
      lookbehind: true,
      alias: "punctuation"
    },
    "url-reference": {
      // [id]: http://example.com "Optional title"
      // [id]: http://example.com 'Optional title'
      // [id]: http://example.com (Optional title)
      // [id]: <http://example.com> "Optional title"
      pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
      inside: {
        "variable": {
          pattern: /^(!?\[)[^\]]+/,
          lookbehind: true
        },
        "string": /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
        "punctuation": /^[\[\]!:]|[<>]/
      },
      alias: "url"
    },
    "bold": {
      // **strong**
      // __strong__
      // allow one nested instance of italic text using the same delimiter
      pattern: createInline(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "content": {
          pattern: /(^..)[\s\S]+(?=..$)/,
          lookbehind: true,
          inside: {}
          // see below
        },
        "punctuation": /\*\*|__/
      }
    },
    "italic": {
      // *em*
      // _em_
      // allow one nested instance of bold text using the same delimiter
      pattern: createInline(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "content": {
          pattern: /(^.)[\s\S]+(?=.$)/,
          lookbehind: true,
          inside: {}
          // see below
        },
        "punctuation": /[*_]/
      }
    },
    "strike": {
      // ~~strike through~~
      // ~strike~
      // eslint-disable-next-line regexp/strict
      pattern: createInline(/(~~?)(?:(?!~)<inner>)+\2/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "content": {
          pattern: /(^~~?)[\s\S]+(?=\1$)/,
          lookbehind: true,
          inside: {}
          // see below
        },
        "punctuation": /~~?/
      }
    },
    "code-snippet": {
      // `code`
      // ``code``
      pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
      lookbehind: true,
      greedy: true,
      alias: ["code", "keyword"]
    },
    "url": {
      // [example](http://example.com "Optional title")
      // [example][id]
      // [example] [id]
      pattern: createInline(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "operator": /^!/,
        "content": {
          pattern: /(^\[)[^\]]+(?=\])/,
          lookbehind: true,
          inside: {}
          // see below
        },
        "variable": {
          pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
          lookbehind: true
        },
        "url": {
          pattern: /(^\]\()[^\s)]+/,
          lookbehind: true
        },
        "string": {
          pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
          lookbehind: true
        }
      }
    }
  });
  ["url", "bold", "italic", "strike"].forEach(function(token) {
    ["url", "bold", "italic", "strike", "code-snippet"].forEach(function(inside) {
      if (token !== inside) {
        Prism2.languages.markdown[token].inside.content.inside[inside] = Prism2.languages.markdown[inside];
      }
    });
  });
  Prism2.hooks.add("after-tokenize", function(env) {
    if (env.language !== "markdown" && env.language !== "md") {
      return;
    }
    function walkTokens(tokens) {
      if (!tokens || typeof tokens === "string") {
        return;
      }
      for (var i2 = 0, l2 = tokens.length; i2 < l2; i2++) {
        var token = tokens[i2];
        if (token.type !== "code") {
          walkTokens(token.content);
          continue;
        }
        var codeLang = token.content[1];
        var codeBlock = token.content[3];
        if (codeLang && codeBlock && codeLang.type === "code-language" && codeBlock.type === "code-block" && typeof codeLang.content === "string") {
          var lang = codeLang.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp");
          lang = (/[a-z][\w-]*/i.exec(lang) || [""])[0].toLowerCase();
          var alias = "language-" + lang;
          if (!codeBlock.alias) {
            codeBlock.alias = [alias];
          } else if (typeof codeBlock.alias === "string") {
            codeBlock.alias = [codeBlock.alias, alias];
          } else {
            codeBlock.alias.push(alias);
          }
        }
      }
    }
    walkTokens(env.tokens);
  });
  Prism2.hooks.add("wrap", function(env) {
    if (env.type !== "code-block") {
      return;
    }
    var codeLang = "";
    for (var i2 = 0, l2 = env.classes.length; i2 < l2; i2++) {
      var cls = env.classes[i2];
      var match = /language-(.+)/.exec(cls);
      if (match) {
        codeLang = match[1];
        break;
      }
    }
    var grammar = Prism2.languages[codeLang];
    if (!grammar) {
      if (codeLang && codeLang !== "none" && Prism2.plugins.autoloader) {
        var id = "md-" + (/* @__PURE__ */ new Date()).valueOf() + "-" + Math.floor(Math.random() * 1e16);
        env.attributes["id"] = id;
        Prism2.plugins.autoloader.loadLanguages(codeLang, function() {
          var ele = document.getElementById(id);
          if (ele) {
            ele.innerHTML = Prism2.highlight(ele.textContent, Prism2.languages[codeLang], codeLang);
          }
        });
      }
    } else {
      env.content = Prism2.highlight(textContent(env.content), grammar, codeLang);
    }
  });
  var tagPattern = RegExp(Prism2.languages.markup.tag.pattern.source, "gi");
  var KNOWN_ENTITY_NAMES = {
    "amp": "&",
    "lt": "<",
    "gt": ">",
    "quot": '"'
  };
  var fromCodePoint = String.fromCodePoint || String.fromCharCode;
  function textContent(html) {
    var text = html.replace(tagPattern, "");
    text = text.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function(m, code) {
      code = code.toLowerCase();
      if (code[0] === "#") {
        var value;
        if (code[1] === "x") {
          value = parseInt(code.slice(2), 16);
        } else {
          value = Number(code.slice(1));
        }
        return fromCodePoint(value);
      } else {
        var known = KNOWN_ENTITY_NAMES[code];
        if (known) {
          return known;
        }
        return m;
      }
    });
    return text;
  }
  Prism2.languages.md = Prism2.languages.markdown;
})(Prism);

// node_modules/prismjs/components/prism-c.js
Prism.languages.c = Prism.languages.extend("clike", {
  "comment": {
    pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
    greedy: true
  },
  "string": {
    // https://en.cppreference.com/w/c/language/string_literal
    pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
    greedy: true
  },
  "class-name": {
    pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
    lookbehind: true
  },
  "keyword": /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
  "function": /\b[a-z_]\w*(?=\s*\()/i,
  "number": /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
  "operator": />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
});
Prism.languages.insertBefore("c", "string", {
  "char": {
    // https://en.cppreference.com/w/c/language/character_constant
    pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,
    greedy: true
  }
});
Prism.languages.insertBefore("c", "string", {
  "macro": {
    // allow for multiline macro definitions
    // spaces after the # character compile fine with gcc
    pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
    lookbehind: true,
    greedy: true,
    alias: "property",
    inside: {
      "string": [
        {
          // highlight the path of the include statement as a string
          pattern: /^(#\s*include\s*)<[^>]+>/,
          lookbehind: true
        },
        Prism.languages.c["string"]
      ],
      "char": Prism.languages.c["char"],
      "comment": Prism.languages.c["comment"],
      "macro-name": [
        {
          pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
          lookbehind: true
        },
        {
          pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
          lookbehind: true,
          alias: "function"
        }
      ],
      // highlight macro directives as keywords
      "directive": {
        pattern: /^(#\s*)[a-z]+/,
        lookbehind: true,
        alias: "keyword"
      },
      "directive-hash": /^#/,
      "punctuation": /##|\\(?=[\r\n])/,
      "expression": {
        pattern: /\S[\s\S]*/,
        inside: Prism.languages.c
      }
    }
  }
});
Prism.languages.insertBefore("c", "function", {
  // highlight predefined macros as constants
  "constant": /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/
});
delete Prism.languages.c["boolean"];

// node_modules/prismjs/components/prism-css.js
(function(Prism2) {
  var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
  Prism2.languages.css = {
    "comment": /\/\*[\s\S]*?\*\//,
    "atrule": {
      pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string.source + ")*?" + /(?:;|(?=\s*\{))/.source),
      inside: {
        "rule": /^@[\w-]+/,
        "selector-function-argument": {
          pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
          lookbehind: true,
          alias: "selector"
        },
        "keyword": {
          pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
          lookbehind: true
        }
        // See rest below
      }
    },
    "url": {
      // https://drafts.csswg.org/css-values-3/#urls
      pattern: RegExp("\\burl\\((?:" + string.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
      greedy: true,
      inside: {
        "function": /^url/i,
        "punctuation": /^\(|\)$/,
        "string": {
          pattern: RegExp("^" + string.source + "$"),
          alias: "url"
        }
      }
    },
    "selector": {
      pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string.source + ")*(?=\\s*\\{)"),
      lookbehind: true
    },
    "string": {
      pattern: string,
      greedy: true
    },
    "property": {
      pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
      lookbehind: true
    },
    "important": /!important\b/i,
    "function": {
      pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
      lookbehind: true
    },
    "punctuation": /[(){};:,]/
  };
  Prism2.languages.css["atrule"].inside.rest = Prism2.languages.css;
  var markup = Prism2.languages.markup;
  if (markup) {
    markup.tag.addInlined("style", "css");
    markup.tag.addAttribute("style", "css");
  }
})(Prism);

// node_modules/prismjs/components/prism-objectivec.js
Prism.languages.objectivec = Prism.languages.extend("c", {
  "string": {
    pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
    greedy: true
  },
  "keyword": /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
  "operator": /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/
});
delete Prism.languages.objectivec["class-name"];
Prism.languages.objc = Prism.languages.objectivec;

// node_modules/prismjs/components/prism-sql.js
Prism.languages.sql = {
  "comment": {
    pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
    lookbehind: true
  },
  "variable": [
    {
      pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
      greedy: true
    },
    /@[\w.$]+/
  ],
  "string": {
    pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
    greedy: true,
    lookbehind: true
  },
  "identifier": {
    pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
    greedy: true,
    lookbehind: true,
    inside: {
      "punctuation": /^`|`$/
    }
  },
  "function": /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
  // Should we highlight user defined functions too?
  "keyword": /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
  "boolean": /\b(?:FALSE|NULL|TRUE)\b/i,
  "number": /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
  "operator": /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
  "punctuation": /[;[\]()`,.]/
};

// node_modules/prismjs/components/prism-powershell.js
(function(Prism2) {
  var powershell = Prism2.languages.powershell = {
    "comment": [
      {
        pattern: /(^|[^`])<#[\s\S]*?#>/,
        lookbehind: true
      },
      {
        pattern: /(^|[^`])#.*/,
        lookbehind: true
      }
    ],
    "string": [
      {
        pattern: /"(?:`[\s\S]|[^`"])*"/,
        greedy: true,
        inside: null
        // see below
      },
      {
        pattern: /'(?:[^']|'')*'/,
        greedy: true
      }
    ],
    // Matches name spaces as well as casts, attribute decorators. Force starting with letter to avoid matching array indices
    // Supports two levels of nested brackets (e.g. `[OutputType([System.Collections.Generic.List[int]])]`)
    "namespace": /\[[a-z](?:\[(?:\[[^\]]*\]|[^\[\]])*\]|[^\[\]])*\]/i,
    "boolean": /\$(?:false|true)\b/i,
    "variable": /\$\w+\b/,
    // Cmdlets and aliases. Aliases should come last, otherwise "write" gets preferred over "write-host" for example
    // Get-Command | ?{ $_.ModuleName -match "Microsoft.PowerShell.(Util|Core|Management)" }
    // Get-Alias | ?{ $_.ReferencedCommand.Module.Name -match "Microsoft.PowerShell.(Util|Core|Management)" }
    "function": [
      /\b(?:Add|Approve|Assert|Backup|Block|Checkpoint|Clear|Close|Compare|Complete|Compress|Confirm|Connect|Convert|ConvertFrom|ConvertTo|Copy|Debug|Deny|Disable|Disconnect|Dismount|Edit|Enable|Enter|Exit|Expand|Export|Find|ForEach|Format|Get|Grant|Group|Hide|Import|Initialize|Install|Invoke|Join|Limit|Lock|Measure|Merge|Move|New|Open|Optimize|Out|Ping|Pop|Protect|Publish|Push|Read|Receive|Redo|Register|Remove|Rename|Repair|Request|Reset|Resize|Resolve|Restart|Restore|Resume|Revoke|Save|Search|Select|Send|Set|Show|Skip|Sort|Split|Start|Step|Stop|Submit|Suspend|Switch|Sync|Tee|Test|Trace|Unblock|Undo|Uninstall|Unlock|Unprotect|Unpublish|Unregister|Update|Use|Wait|Watch|Where|Write)-[a-z]+\b/i,
      /\b(?:ac|cat|chdir|clc|cli|clp|clv|compare|copy|cp|cpi|cpp|cvpa|dbp|del|diff|dir|ebp|echo|epal|epcsv|epsn|erase|fc|fl|ft|fw|gal|gbp|gc|gci|gcs|gdr|gi|gl|gm|gp|gps|group|gsv|gu|gv|gwmi|iex|ii|ipal|ipcsv|ipsn|irm|iwmi|iwr|kill|lp|ls|measure|mi|mount|move|mp|mv|nal|ndr|ni|nv|ogv|popd|ps|pushd|pwd|rbp|rd|rdr|ren|ri|rm|rmdir|rni|rnp|rp|rv|rvpa|rwmi|sal|saps|sasv|sbp|sc|select|set|shcm|si|sl|sleep|sls|sort|sp|spps|spsv|start|sv|swmi|tee|trcm|type|write)\b/i
    ],
    // per http://technet.microsoft.com/en-us/library/hh847744.aspx
    "keyword": /\b(?:Begin|Break|Catch|Class|Continue|Data|Define|Do|DynamicParam|Else|ElseIf|End|Exit|Filter|Finally|For|ForEach|From|Function|If|InlineScript|Parallel|Param|Process|Return|Sequence|Switch|Throw|Trap|Try|Until|Using|Var|While|Workflow)\b/i,
    "operator": {
      pattern: /(^|\W)(?:!|-(?:b?(?:and|x?or)|as|(?:Not)?(?:Contains|In|Like|Match)|eq|ge|gt|is(?:Not)?|Join|le|lt|ne|not|Replace|sh[lr])\b|-[-=]?|\+[+=]?|[*\/%]=?)/i,
      lookbehind: true
    },
    "punctuation": /[|{}[\];(),.]/
  };
  powershell.string[0].inside = {
    "function": {
      // Allow for one level of nesting
      pattern: /(^|[^`])\$\((?:\$\([^\r\n()]*\)|(?!\$\()[^\r\n)])*\)/,
      lookbehind: true,
      inside: powershell
    },
    "boolean": powershell.boolean,
    "variable": powershell.variable
  };
})(Prism);

// node_modules/prismjs/components/prism-python.js
Prism.languages.python = {
  "comment": {
    pattern: /(^|[^\\])#.*/,
    lookbehind: true,
    greedy: true
  },
  "string-interpolation": {
    pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
    greedy: true,
    inside: {
      "interpolation": {
        // "{" <expression> <optional "!s", "!r", or "!a"> <optional ":" format specifier> "}"
        pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
        lookbehind: true,
        inside: {
          "format-spec": {
            pattern: /(:)[^:(){}]+(?=\}$)/,
            lookbehind: true
          },
          "conversion-option": {
            pattern: /![sra](?=[:}]$)/,
            alias: "punctuation"
          },
          rest: null
        }
      },
      "string": /[\s\S]+/
    }
  },
  "triple-quoted-string": {
    pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
    greedy: true,
    alias: "string"
  },
  "string": {
    pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
    greedy: true
  },
  "function": {
    pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
    lookbehind: true
  },
  "class-name": {
    pattern: /(\bclass\s+)\w+/i,
    lookbehind: true
  },
  "decorator": {
    pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
    lookbehind: true,
    alias: ["annotation", "punctuation"],
    inside: {
      "punctuation": /\./
    }
  },
  "keyword": /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
  "builtin": /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
  "boolean": /\b(?:False|None|True)\b/,
  "number": /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
  "operator": /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
  "punctuation": /[{}[\];(),.:]/
};
Prism.languages.python["string-interpolation"].inside["interpolation"].inside.rest = Prism.languages.python;
Prism.languages.py = Prism.languages.python;

// node_modules/prismjs/components/prism-rust.js
(function(Prism2) {
  var multilineComment = /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\//.source;
  for (var i2 = 0; i2 < 2; i2++) {
    multilineComment = multilineComment.replace(/<self>/g, function() {
      return multilineComment;
    });
  }
  multilineComment = multilineComment.replace(/<self>/g, function() {
    return /[^\s\S]/.source;
  });
  Prism2.languages.rust = {
    "comment": [
      {
        pattern: RegExp(/(^|[^\\])/.source + multilineComment),
        lookbehind: true,
        greedy: true
      },
      {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: true,
        greedy: true
      }
    ],
    "string": {
      pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/,
      greedy: true
    },
    "char": {
      pattern: /b?'(?:\\(?:x[0-7][\da-fA-F]|u\{(?:[\da-fA-F]_*){1,6}\}|.)|[^\\\r\n\t'])'/,
      greedy: true
    },
    "attribute": {
      pattern: /#!?\[(?:[^\[\]"]|"(?:\\[\s\S]|[^\\"])*")*\]/,
      greedy: true,
      alias: "attr-name",
      inside: {
        "string": null
        // see below
      }
    },
    // Closure params should not be confused with bitwise OR |
    "closure-params": {
      pattern: /([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/,
      lookbehind: true,
      greedy: true,
      inside: {
        "closure-punctuation": {
          pattern: /^\||\|$/,
          alias: "punctuation"
        },
        rest: null
        // see below
      }
    },
    "lifetime-annotation": {
      pattern: /'\w+/,
      alias: "symbol"
    },
    "fragment-specifier": {
      pattern: /(\$\w+:)[a-z]+/,
      lookbehind: true,
      alias: "punctuation"
    },
    "variable": /\$\w+/,
    "function-definition": {
      pattern: /(\bfn\s+)\w+/,
      lookbehind: true,
      alias: "function"
    },
    "type-definition": {
      pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/,
      lookbehind: true,
      alias: "class-name"
    },
    "module-declaration": [
      {
        pattern: /(\b(?:crate|mod)\s+)[a-z][a-z_\d]*/,
        lookbehind: true,
        alias: "namespace"
      },
      {
        pattern: /(\b(?:crate|self|super)\s*)::\s*[a-z][a-z_\d]*\b(?:\s*::(?:\s*[a-z][a-z_\d]*\s*::)*)?/,
        lookbehind: true,
        alias: "namespace",
        inside: {
          "punctuation": /::/
        }
      }
    ],
    "keyword": [
      // https://github.com/rust-lang/reference/blob/master/src/keywords.md
      /\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/,
      // primitives and str
      // https://doc.rust-lang.org/stable/rust-by-example/primitives.html
      /\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\b/
    ],
    // functions can technically start with an upper-case letter, but this will introduce a lot of false positives
    // and Rust's naming conventions recommend snake_case anyway.
    // https://doc.rust-lang.org/1.0.0/style/style/naming/README.html
    "function": /\b[a-z_]\w*(?=\s*(?:::\s*<|\())/,
    "macro": {
      pattern: /\b\w+!/,
      alias: "property"
    },
    "constant": /\b[A-Z_][A-Z_\d]+\b/,
    "class-name": /\b[A-Z]\w*\b/,
    "namespace": {
      pattern: /(?:\b[a-z][a-z_\d]*\s*::\s*)*\b[a-z][a-z_\d]*\s*::(?!\s*<)/,
      inside: {
        "punctuation": /::/
      }
    },
    // Hex, oct, bin, dec numbers with visual separators and type suffix
    "number": /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\b/,
    "boolean": /\b(?:false|true)\b/,
    "punctuation": /->|\.\.=|\.{1,3}|::|[{}[\];(),:]/,
    "operator": /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/
  };
  Prism2.languages.rust["closure-params"].inside.rest = Prism2.languages.rust;
  Prism2.languages.rust["attribute"].inside["string"] = Prism2.languages.rust["string"];
})(Prism);

// node_modules/prismjs/components/prism-swift.js
Prism.languages.swift = {
  "comment": {
    // Nested comments are supported up to 2 levels
    pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/,
    lookbehind: true,
    greedy: true
  },
  "string-literal": [
    // https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html
    {
      pattern: RegExp(
        /(^|[^"#])/.source + "(?:" + /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source + "|" + /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source + ")" + /(?!["#])/.source
      ),
      lookbehind: true,
      greedy: true,
      inside: {
        "interpolation": {
          pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/,
          lookbehind: true,
          inside: null
          // see below
        },
        "interpolation-punctuation": {
          pattern: /^\)|\\\($/,
          alias: "punctuation"
        },
        "punctuation": /\\(?=[\r\n])/,
        "string": /[\s\S]+/
      }
    },
    {
      pattern: RegExp(
        /(^|[^"#])(#+)/.source + "(?:" + /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source + "|" + /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source + ")\\2"
      ),
      lookbehind: true,
      greedy: true,
      inside: {
        "interpolation": {
          pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/,
          lookbehind: true,
          inside: null
          // see below
        },
        "interpolation-punctuation": {
          pattern: /^\)|\\#+\($/,
          alias: "punctuation"
        },
        "string": /[\s\S]+/
      }
    }
  ],
  "directive": {
    // directives with conditions
    pattern: RegExp(
      /#/.source + "(?:" + (/(?:elseif|if)\b/.source + "(?:[ 	]*" + /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source + ")+") + "|" + /(?:else|endif)\b/.source + ")"
    ),
    alias: "property",
    inside: {
      "directive-name": /^#\w+/,
      "boolean": /\b(?:false|true)\b/,
      "number": /\b\d+(?:\.\d+)*\b/,
      "operator": /!|&&|\|\||[<>]=?/,
      "punctuation": /[(),]/
    }
  },
  "literal": {
    pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/,
    alias: "constant"
  },
  "other-directive": {
    pattern: /#\w+\b/,
    alias: "property"
  },
  "attribute": {
    pattern: /@\w+/,
    alias: "atrule"
  },
  "function-definition": {
    pattern: /(\bfunc\s+)\w+/,
    lookbehind: true,
    alias: "function"
  },
  "label": {
    // https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html#ID141
    pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/,
    lookbehind: true,
    alias: "important"
  },
  "keyword": /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/,
  "boolean": /\b(?:false|true)\b/,
  "nil": {
    pattern: /\bnil\b/,
    alias: "constant"
  },
  "short-argument": /\$\d+\b/,
  "omit": {
    pattern: /\b_\b/,
    alias: "keyword"
  },
  "number": /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,
  // A class name must start with an upper-case letter and be either 1 letter long or contain a lower-case letter.
  "class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/,
  "function": /\b[a-z_]\w*(?=\s*\()/i,
  "constant": /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,
  // Operators are generic in Swift. Developers can even create new operators (e.g. +++).
  // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html#ID481
  // This regex only supports ASCII operators.
  "operator": /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/,
  "punctuation": /[{}[\]();,.:\\]/
};
Prism.languages.swift["string-literal"].forEach(function(rule) {
  rule.inside["interpolation"].inside = Prism.languages.swift;
});

// node_modules/prismjs/components/prism-typescript.js
(function(Prism2) {
  Prism2.languages.typescript = Prism2.languages.extend("javascript", {
    "class-name": {
      pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
      lookbehind: true,
      greedy: true,
      inside: null
      // see below
    },
    "builtin": /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/
  });
  Prism2.languages.typescript.keyword.push(
    /\b(?:abstract|declare|is|keyof|readonly|require)\b/,
    // keywords that have to be followed by an identifier
    /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
    // This is for `import type *, {}`
    /\btype\b(?=\s*(?:[\{*]|$))/
  );
  delete Prism2.languages.typescript["parameter"];
  delete Prism2.languages.typescript["literal-property"];
  var typeInside = Prism2.languages.extend("typescript", {});
  delete typeInside["class-name"];
  Prism2.languages.typescript["class-name"].inside = typeInside;
  Prism2.languages.insertBefore("typescript", "function", {
    "decorator": {
      pattern: /@[$\w\xA0-\uFFFF]+/,
      inside: {
        "at": {
          pattern: /^@/,
          alias: "operator"
        },
        "function": /^[\s\S]+/
      }
    },
    "generic-function": {
      // e.g. foo<T extends "bar" | "baz">( ...
      pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
      greedy: true,
      inside: {
        "function": /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
        "generic": {
          pattern: /<[\s\S]+/,
          // everything after the first <
          alias: "class-name",
          inside: typeInside
        }
      }
    }
  });
  Prism2.languages.ts = Prism2.languages.typescript;
})(Prism);

// node_modules/prismjs/components/prism-java.js
(function(Prism2) {
  var keywords = /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\s*[(){}[\]<>=%~.:,;?+\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/;
  var classNamePrefix = /(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source;
  var className = {
    pattern: RegExp(/(^|[^\w.])/.source + classNamePrefix + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
    lookbehind: true,
    inside: {
      "namespace": {
        pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
        inside: {
          "punctuation": /\./
        }
      },
      "punctuation": /\./
    }
  };
  Prism2.languages.java = Prism2.languages.extend("clike", {
    "string": {
      pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"/,
      lookbehind: true,
      greedy: true
    },
    "class-name": [
      className,
      {
        // variables, parameters, and constructor references
        // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
        pattern: RegExp(/(^|[^\w.])/.source + classNamePrefix + /[A-Z]\w*(?=\s+\w+\s*[;,=()]|\s*(?:\[[\s,]*\]\s*)?::\s*new\b)/.source),
        lookbehind: true,
        inside: className.inside
      },
      {
        // class names based on keyword
        // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
        pattern: RegExp(/(\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\s+)/.source + classNamePrefix + /[A-Z]\w*\b/.source),
        lookbehind: true,
        inside: className.inside
      }
    ],
    "keyword": keywords,
    "function": [
      Prism2.languages.clike.function,
      {
        pattern: /(::\s*)[a-z_]\w*/,
        lookbehind: true
      }
    ],
    "number": /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
    "operator": {
      pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
      lookbehind: true
    },
    "constant": /\b[A-Z][A-Z_\d]+\b/
  });
  Prism2.languages.insertBefore("java", "string", {
    "triple-quoted-string": {
      // http://openjdk.java.net/jeps/355#Description
      pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,
      greedy: true,
      alias: "string"
    },
    "char": {
      pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/,
      greedy: true
    }
  });
  Prism2.languages.insertBefore("java", "class-name", {
    "annotation": {
      pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
      lookbehind: true,
      alias: "punctuation"
    },
    "generics": {
      pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
      inside: {
        "class-name": className,
        "keyword": keywords,
        "punctuation": /[<>(),.:]/,
        "operator": /[?&|]/
      }
    },
    "import": [
      {
        pattern: RegExp(/(\bimport\s+)/.source + classNamePrefix + /(?:[A-Z]\w*|\*)(?=\s*;)/.source),
        lookbehind: true,
        inside: {
          "namespace": className.inside.namespace,
          "punctuation": /\./,
          "operator": /\*/,
          "class-name": /\w+/
        }
      },
      {
        pattern: RegExp(/(\bimport\s+static\s+)/.source + classNamePrefix + /(?:\w+|\*)(?=\s*;)/.source),
        lookbehind: true,
        alias: "static",
        inside: {
          "namespace": className.inside.namespace,
          "static": /\b\w+$/,
          "punctuation": /\./,
          "operator": /\*/,
          "class-name": /\w+/
        }
      }
    ],
    "namespace": {
      pattern: RegExp(
        /(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(/<keyword>/g, function() {
          return keywords.source;
        })
      ),
      lookbehind: true,
      inside: {
        "punctuation": /\./
      }
    }
  });
})(Prism);

// node_modules/prismjs/components/prism-cpp.js
(function(Prism2) {
  var keyword = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/;
  var modName = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function() {
    return keyword.source;
  });
  Prism2.languages.cpp = Prism2.languages.extend("c", {
    "class-name": [
      {
        pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function() {
          return keyword.source;
        })),
        lookbehind: true
      },
      // This is intended to capture the class name of method implementations like:
      //   void foo::bar() const {}
      // However! The `foo` in the above example could also be a namespace, so we only capture the class name if
      // it starts with an uppercase letter. This approximation should give decent results.
      /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
      // This will capture the class name before destructors like:
      //   Foo::~Foo() {}
      /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
      // This also intends to capture the class name of method implementations but here the class has template
      // parameters, so it can't be a namespace (until C++ adds generic namespaces).
      /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/
    ],
    "keyword": keyword,
    "number": {
      pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
      greedy: true
    },
    "operator": />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
    "boolean": /\b(?:false|true)\b/
  });
  Prism2.languages.insertBefore("cpp", "string", {
    "module": {
      // https://en.cppreference.com/w/cpp/language/modules
      pattern: RegExp(
        /(\b(?:import|module)\s+)/.source + "(?:" + // header-name
        /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + // module name or partition or both
        /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function() {
          return modName;
        }) + ")"
      ),
      lookbehind: true,
      greedy: true,
      inside: {
        "string": /^[<"][\s\S]+/,
        "operator": /:/,
        "punctuation": /\./
      }
    },
    "raw-string": {
      pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
      alias: "string",
      greedy: true
    }
  });
  Prism2.languages.insertBefore("cpp", "keyword", {
    "generic-function": {
      pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
      inside: {
        "function": /^\w+/,
        "generic": {
          pattern: /<[\s\S]+/,
          alias: "class-name",
          inside: Prism2.languages.cpp
        }
      }
    }
  });
  Prism2.languages.insertBefore("cpp", "operator", {
    "double-colon": {
      pattern: /::/,
      alias: "punctuation"
    }
  });
  Prism2.languages.insertBefore("cpp", "class-name", {
    // the base clause is an optional list of parent classes
    // https://en.cppreference.com/w/cpp/language/class
    "base-clause": {
      pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
      lookbehind: true,
      greedy: true,
      inside: Prism2.languages.extend("cpp", {})
    }
  });
  Prism2.languages.insertBefore("inside", "double-colon", {
    // All untokenized words that are not namespaces should be class names
    "class-name": /\b[a-z_]\w*\b(?!\s*::)/i
  }, Prism2.languages.cpp["base-clause"]);
})(Prism);

// node_modules/@lexical/code/LexicalCode.dev.mjs
function formatDevErrorMessage7(message) {
  throw new Error(message);
}
var DEFAULT_CODE_LANGUAGE = "javascript";
var getDefaultCodeLanguage = () => DEFAULT_CODE_LANGUAGE;
function hasChildDOMNodeTag(node, tagName) {
  for (const child of node.childNodes) {
    if (isHTMLElement3(child) && child.tagName === tagName) {
      return true;
    }
    hasChildDOMNodeTag(child, tagName);
  }
  return false;
}
var LANGUAGE_DATA_ATTRIBUTE = "data-language";
var HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE = "data-highlight-language";
var THEME_DATA_ATTRIBUTE = "data-theme";
var CodeNode = class _CodeNode extends ElementNode2 {
  constructor(language, key) {
    super(key);
    /** @internal */
    __publicField(this, "__language");
    /** @internal */
    __publicField(this, "__theme");
    /** @internal */
    __publicField(this, "__isSyntaxHighlightSupported");
    this.__language = language || void 0;
    this.__isSyntaxHighlightSupported = false;
    this.__theme = void 0;
  }
  static getType() {
    return "code";
  }
  static clone(node) {
    return new _CodeNode(node.__language, node.__key);
  }
  afterCloneFrom(prevNode) {
    super.afterCloneFrom(prevNode);
    this.__language = prevNode.__language;
    this.__theme = prevNode.__theme;
    this.__isSyntaxHighlightSupported = prevNode.__isSyntaxHighlightSupported;
  }
  // View
  createDOM(config) {
    const element = document.createElement("code");
    addClassNamesToElement2(element, config.theme.code);
    element.setAttribute("spellcheck", "false");
    const language = this.getLanguage();
    if (language) {
      element.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);
      if (this.getIsSyntaxHighlightSupported()) {
        element.setAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE, language);
      }
    }
    const theme2 = this.getTheme();
    if (theme2) {
      element.setAttribute(THEME_DATA_ATTRIBUTE, theme2);
    }
    const style = this.getStyle();
    if (style) {
      element.setAttribute("style", style);
    }
    return element;
  }
  updateDOM(prevNode, dom, config) {
    const language = this.__language;
    const prevLanguage = prevNode.__language;
    if (language) {
      if (language !== prevLanguage) {
        dom.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);
      }
    } else if (prevLanguage) {
      dom.removeAttribute(LANGUAGE_DATA_ATTRIBUTE);
    }
    const isSyntaxHighlightSupported = this.__isSyntaxHighlightSupported;
    const prevIsSyntaxHighlightSupported = prevNode.__isSyntaxHighlightSupported;
    if (prevIsSyntaxHighlightSupported && prevLanguage) {
      if (isSyntaxHighlightSupported && language) {
        if (language !== prevLanguage) {
          dom.setAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE, language);
        }
      } else {
        dom.removeAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE);
      }
    } else if (isSyntaxHighlightSupported && language) {
      dom.setAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE, language);
    }
    const theme2 = this.__theme;
    const prevTheme = prevNode.__theme;
    if (theme2) {
      if (theme2 !== prevTheme) {
        dom.setAttribute(THEME_DATA_ATTRIBUTE, theme2);
      }
    } else if (prevTheme) {
      dom.removeAttribute(THEME_DATA_ATTRIBUTE);
    }
    const style = this.__style;
    const prevStyle = prevNode.__style;
    if (style) {
      if (style !== prevStyle) {
        dom.setAttribute("style", style);
      }
    } else if (prevStyle) {
      dom.removeAttribute("style");
    }
    return false;
  }
  exportDOM(editor) {
    const element = document.createElement("pre");
    addClassNamesToElement2(element, editor._config.theme.code);
    element.setAttribute("spellcheck", "false");
    const language = this.getLanguage();
    if (language) {
      element.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);
      if (this.getIsSyntaxHighlightSupported()) {
        element.setAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE, language);
      }
    }
    const theme2 = this.getTheme();
    if (theme2) {
      element.setAttribute(THEME_DATA_ATTRIBUTE, theme2);
    }
    const style = this.getStyle();
    if (style) {
      element.setAttribute("style", style);
    }
    return {
      element
    };
  }
  static importDOM() {
    return {
      // Typically <pre> is used for code blocks, and <code> for inline code styles
      // but if it's a multi line <code> we'll create a block. Pass through to
      // inline format handled by TextNode otherwise.
      code: (node) => {
        const isMultiLine = node.textContent != null && (/\r?\n/.test(node.textContent) || hasChildDOMNodeTag(node, "BR"));
        return isMultiLine ? {
          conversion: $convertPreElement,
          priority: 1
        } : null;
      },
      div: () => ({
        conversion: $convertDivElement,
        priority: 1
      }),
      pre: () => ({
        conversion: $convertPreElement,
        priority: 0
      }),
      table: (node) => {
        const table = node;
        if (isGitHubCodeTable(table)) {
          return {
            conversion: $convertTableElement,
            priority: 3
          };
        }
        return null;
      },
      td: (node) => {
        const td = node;
        const table = td.closest("table");
        if (isGitHubCodeCell(td) || table && isGitHubCodeTable(table)) {
          return {
            conversion: convertCodeNoop,
            priority: 3
          };
        }
        return null;
      },
      tr: (node) => {
        const tr = node;
        const table = tr.closest("table");
        if (table && isGitHubCodeTable(table)) {
          return {
            conversion: convertCodeNoop,
            priority: 3
          };
        }
        return null;
      }
    };
  }
  static importJSON(serializedNode) {
    return $createCodeNode().updateFromJSON(serializedNode);
  }
  updateFromJSON(serializedNode) {
    return super.updateFromJSON(serializedNode).setLanguage(serializedNode.language).setTheme(serializedNode.theme);
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      language: this.getLanguage(),
      theme: this.getTheme()
    };
  }
  // Mutation
  insertNewAfter(selection, restoreSelection = true) {
    const children = this.getChildren();
    const childrenLength = children.length;
    if (childrenLength >= 2 && children[childrenLength - 1].getTextContent() === "\n" && children[childrenLength - 2].getTextContent() === "\n" && selection.isCollapsed() && selection.anchor.key === this.__key && selection.anchor.offset === childrenLength) {
      children[childrenLength - 1].remove();
      children[childrenLength - 2].remove();
      const newElement = $createParagraphNode2();
      this.insertAfter(newElement, restoreSelection);
      return newElement;
    }
    const {
      anchor,
      focus
    } = selection;
    const firstPoint = anchor.isBefore(focus) ? anchor : focus;
    const firstSelectionNode = firstPoint.getNode();
    if ($isTextNode2(firstSelectionNode)) {
      let node = $getFirstCodeNodeOfLine(firstSelectionNode);
      const insertNodes = [];
      while (true) {
        if ($isTabNode2(node)) {
          insertNodes.push($createTabNode2());
          node = node.getNextSibling();
        } else if ($isCodeHighlightNode(node)) {
          let spaces = 0;
          const text = node.getTextContent();
          const textSize = node.getTextContentSize();
          while (spaces < textSize && text[spaces] === " ") {
            spaces++;
          }
          if (spaces !== 0) {
            insertNodes.push($createCodeHighlightNode(" ".repeat(spaces)));
          }
          if (spaces !== textSize) {
            break;
          }
          node = node.getNextSibling();
        } else {
          break;
        }
      }
      const split = firstSelectionNode.splitText(anchor.offset)[0];
      const x = anchor.offset === 0 ? 0 : 1;
      const index = split.getIndexWithinParent() + x;
      const codeNode = firstSelectionNode.getParentOrThrow();
      const nodesToInsert = [$createLineBreakNode2(), ...insertNodes];
      codeNode.splice(index, 0, nodesToInsert);
      const last = insertNodes[insertNodes.length - 1];
      if (last) {
        last.select();
      } else if (anchor.offset === 0) {
        split.selectPrevious();
      } else {
        split.getNextSibling().selectNext(0, 0);
      }
    }
    if ($isCodeNode(firstSelectionNode)) {
      const {
        offset
      } = selection.anchor;
      firstSelectionNode.splice(offset, 0, [$createLineBreakNode2()]);
      firstSelectionNode.select(offset + 1, offset + 1);
    }
    return null;
  }
  canIndent() {
    return false;
  }
  collapseAtStart() {
    const paragraph = $createParagraphNode2();
    const children = this.getChildren();
    children.forEach((child) => paragraph.append(child));
    this.replace(paragraph);
    return true;
  }
  setLanguage(language) {
    const writable = this.getWritable();
    writable.__language = language || void 0;
    return writable;
  }
  getLanguage() {
    return this.getLatest().__language;
  }
  setIsSyntaxHighlightSupported(isSupported) {
    const writable = this.getWritable();
    writable.__isSyntaxHighlightSupported = isSupported;
    return writable;
  }
  getIsSyntaxHighlightSupported() {
    return this.getLatest().__isSyntaxHighlightSupported;
  }
  setTheme(theme2) {
    const writable = this.getWritable();
    writable.__theme = theme2 || void 0;
    return writable;
  }
  getTheme() {
    return this.getLatest().__theme;
  }
};
function $createCodeNode(language, theme2) {
  return $create2(CodeNode).setLanguage(language).setTheme(theme2);
}
function $isCodeNode(node) {
  return node instanceof CodeNode;
}
function $convertPreElement(domNode) {
  const language = domNode.getAttribute(LANGUAGE_DATA_ATTRIBUTE);
  return {
    node: $createCodeNode(language)
  };
}
function $convertDivElement(domNode) {
  const div = domNode;
  const isCode = isCodeElement(div);
  if (!isCode && !isCodeChildElement(div)) {
    return {
      node: null
    };
  }
  return {
    node: isCode ? $createCodeNode() : null
  };
}
function $convertTableElement() {
  return {
    node: $createCodeNode()
  };
}
function convertCodeNoop() {
  return {
    node: null
  };
}
function isCodeElement(div) {
  return div.style.fontFamily.match("monospace") !== null;
}
function isCodeChildElement(node) {
  let parent = node.parentElement;
  while (parent !== null) {
    if (isCodeElement(parent)) {
      return true;
    }
    parent = parent.parentElement;
  }
  return false;
}
function isGitHubCodeCell(cell) {
  return cell.classList.contains("js-file-line");
}
function isGitHubCodeTable(table) {
  return table.classList.contains("js-file-line-container");
}
var CodeHighlightNode = class _CodeHighlightNode extends TextNode2 {
  constructor(text = "", highlightType, key) {
    super(text, key);
    /** @internal */
    __publicField(this, "__highlightType");
    this.__highlightType = highlightType;
  }
  static getType() {
    return "code-highlight";
  }
  static clone(node) {
    return new _CodeHighlightNode(node.__text, node.__highlightType || void 0, node.__key);
  }
  getHighlightType() {
    const self2 = this.getLatest();
    return self2.__highlightType;
  }
  setHighlightType(highlightType) {
    const self2 = this.getWritable();
    self2.__highlightType = highlightType || void 0;
    return self2;
  }
  canHaveFormat() {
    return false;
  }
  createDOM(config) {
    const element = super.createDOM(config);
    const className = getHighlightThemeClass(config.theme, this.__highlightType);
    addClassNamesToElement2(element, className);
    return element;
  }
  updateDOM(prevNode, dom, config) {
    const update = super.updateDOM(prevNode, dom, config);
    const prevClassName = getHighlightThemeClass(config.theme, prevNode.__highlightType);
    const nextClassName = getHighlightThemeClass(config.theme, this.__highlightType);
    if (prevClassName !== nextClassName) {
      if (prevClassName) {
        removeClassNamesFromElement2(dom, prevClassName);
      }
      if (nextClassName) {
        addClassNamesToElement2(dom, nextClassName);
      }
    }
    return update;
  }
  static importJSON(serializedNode) {
    return $createCodeHighlightNode().updateFromJSON(serializedNode);
  }
  updateFromJSON(serializedNode) {
    return super.updateFromJSON(serializedNode).setHighlightType(serializedNode.highlightType);
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      highlightType: this.getHighlightType()
    };
  }
  // Prevent formatting (bold, underline, etc)
  setFormat(format) {
    return this;
  }
  isParentRequired() {
    return true;
  }
  createParentElementNode() {
    return $createCodeNode();
  }
};
function getHighlightThemeClass(theme2, highlightType) {
  return highlightType && theme2 && theme2.codeHighlight && theme2.codeHighlight[highlightType];
}
function $createCodeHighlightNode(text = "", highlightType) {
  return $applyNodeReplacement2(new CodeHighlightNode(text, highlightType));
}
function $isCodeHighlightNode(node) {
  return node instanceof CodeHighlightNode;
}
function $getLastMatchingCodeNode(anchor, direction) {
  let matchingNode = anchor;
  for (let caret = $getSiblingCaret2(anchor, direction); caret && ($isCodeHighlightNode(caret.origin) || $isTabNode2(caret.origin)); caret = $getAdjacentCaret2(caret)) {
    matchingNode = caret.origin;
  }
  return matchingNode;
}
function $getFirstCodeNodeOfLine(anchor) {
  return $getLastMatchingCodeNode(anchor, "previous");
}
function $getLastCodeNodeOfLine(anchor) {
  return $getLastMatchingCodeNode(anchor, "next");
}
function $getCodeLineDirection(anchor) {
  const start = $getFirstCodeNodeOfLine(anchor);
  const end = $getLastCodeNodeOfLine(anchor);
  let node = start;
  while (node !== null) {
    if ($isCodeHighlightNode(node)) {
      const direction = getTextDirection2(node.getTextContent());
      if (direction !== null) {
        return direction;
      }
    }
    if (node === end) {
      break;
    }
    node = node.getNextSibling();
  }
  const parent = start.getParent();
  if ($isElementNode2(parent)) {
    const parentDirection = parent.getDirection();
    if (parentDirection === "ltr" || parentDirection === "rtl") {
      return parentDirection;
    }
  }
  return null;
}
function $getStartOfCodeInLine(anchor, offset) {
  let last = null;
  let lastNonBlank = null;
  let node = anchor;
  let nodeOffset = offset;
  let nodeTextContent = anchor.getTextContent();
  while (true) {
    if (nodeOffset === 0) {
      node = node.getPreviousSibling();
      if (node === null) {
        break;
      }
      if (!($isCodeHighlightNode(node) || $isTabNode2(node) || $isLineBreakNode2(node))) {
        formatDevErrorMessage7(`Expected a valid Code Node: CodeHighlightNode, TabNode, LineBreakNode`);
      }
      if ($isLineBreakNode2(node)) {
        last = {
          node,
          offset: 1
        };
        break;
      }
      nodeOffset = Math.max(0, node.getTextContentSize() - 1);
      nodeTextContent = node.getTextContent();
    } else {
      nodeOffset--;
    }
    const character = nodeTextContent[nodeOffset];
    if ($isCodeHighlightNode(node) && character !== " ") {
      lastNonBlank = {
        node,
        offset: nodeOffset
      };
    }
  }
  if (lastNonBlank !== null) {
    return lastNonBlank;
  }
  let codeCharacterAtAnchorOffset = null;
  if (offset < anchor.getTextContentSize()) {
    if ($isCodeHighlightNode(anchor)) {
      codeCharacterAtAnchorOffset = anchor.getTextContent()[offset];
    }
  } else {
    const nextSibling = anchor.getNextSibling();
    if ($isCodeHighlightNode(nextSibling)) {
      codeCharacterAtAnchorOffset = nextSibling.getTextContent()[0];
    }
  }
  if (codeCharacterAtAnchorOffset !== null && codeCharacterAtAnchorOffset !== " ") {
    return last;
  } else {
    const nextNonBlank = findNextNonBlankInLine(anchor, offset);
    if (nextNonBlank !== null) {
      return nextNonBlank;
    } else {
      return last;
    }
  }
}
function findNextNonBlankInLine(anchor, offset) {
  let node = anchor;
  let nodeOffset = offset;
  let nodeTextContent = anchor.getTextContent();
  let nodeTextContentSize = anchor.getTextContentSize();
  while (true) {
    if (!$isCodeHighlightNode(node) || nodeOffset === nodeTextContentSize) {
      node = node.getNextSibling();
      if (node === null || $isLineBreakNode2(node)) {
        return null;
      }
      if ($isCodeHighlightNode(node)) {
        nodeOffset = 0;
        nodeTextContent = node.getTextContent();
        nodeTextContentSize = node.getTextContentSize();
      }
    }
    if ($isCodeHighlightNode(node)) {
      if (nodeTextContent[nodeOffset] !== " ") {
        return {
          node,
          offset: nodeOffset
        };
      }
      nodeOffset++;
    }
  }
}
function $getEndOfCodeInLine(anchor) {
  const lastNode = $getLastCodeNodeOfLine(anchor);
  if (!!$isLineBreakNode2(lastNode)) {
    formatDevErrorMessage7(`Unexpected lineBreakNode in getEndOfCodeInLine`);
  }
  return lastNode;
}
var CodeExtension = defineExtension2({
  name: "@lexical/code",
  nodes: () => [CodeNode, CodeHighlightNode]
});
(function(Prism2) {
  Prism2.languages.diff = {
    "coord": [
      // Match all kinds of coord lines (prefixed by "+++", "---" or "***").
      /^(?:\*{3}|-{3}|\+{3}).*$/m,
      // Match "@@ ... @@" coord lines in unified diff.
      /^@@.*@@$/m,
      // Match coord lines in normal diff (starts with a number).
      /^\d.*$/m
    ]
    // deleted, inserted, unchanged, diff
  };
  var PREFIXES = {
    "deleted-sign": "-",
    "deleted-arrow": "<",
    "inserted-sign": "+",
    "inserted-arrow": ">",
    "unchanged": " ",
    "diff": "!"
  };
  Object.keys(PREFIXES).forEach(function(name) {
    var prefix = PREFIXES[name];
    var alias = [];
    if (!/^\w+$/.test(name)) {
      alias.push(/\w+/.exec(name)[0]);
    }
    if (name === "diff") {
      alias.push("bold");
    }
    Prism2.languages.diff[name] = {
      pattern: RegExp("^(?:[" + prefix + "].*(?:\r\n?|\n|(?![\\s\\S])))+", "m"),
      alias,
      inside: {
        "line": {
          pattern: /(.)(?=[\s\S]).*(?:\r\n?|\n)?/,
          lookbehind: true
        },
        "prefix": {
          pattern: /[\s\S]/,
          alias: /\w+/.exec(name)[0]
        }
      }
    };
  });
  Object.defineProperty(Prism2.languages.diff, "PREFIXES", {
    value: PREFIXES
  });
})(Prism);
var Prism$1 = globalThis.Prism || window.Prism;
var CODE_LANGUAGE_FRIENDLY_NAME_MAP = {
  c: "C",
  clike: "C-like",
  cpp: "C++",
  css: "CSS",
  html: "HTML",
  java: "Java",
  js: "JavaScript",
  markdown: "Markdown",
  objc: "Objective-C",
  plain: "Plain Text",
  powershell: "PowerShell",
  py: "Python",
  rust: "Rust",
  sql: "SQL",
  swift: "Swift",
  typescript: "TypeScript",
  xml: "XML"
};
var CODE_LANGUAGE_MAP = {
  cpp: "cpp",
  java: "java",
  javascript: "js",
  md: "markdown",
  plaintext: "plain",
  python: "py",
  text: "plain",
  ts: "typescript"
};
function normalizeCodeLang(lang) {
  return CODE_LANGUAGE_MAP[lang] || lang;
}
function getLanguageFriendlyName(lang) {
  const _lang = normalizeCodeLang(lang);
  return CODE_LANGUAGE_FRIENDLY_NAME_MAP[_lang] || _lang;
}
var getCodeLanguages = () => Object.keys(Prism$1.languages).filter(
  // Prism has several language helpers mixed into languages object
  // so filtering them out here to get langs list
  (language) => typeof Prism$1.languages[language] !== "function"
).sort();
function getCodeLanguageOptions() {
  const options = [];
  for (const [lang, friendlyName] of Object.entries(CODE_LANGUAGE_FRIENDLY_NAME_MAP)) {
    options.push([lang, friendlyName]);
  }
  return options;
}
function getCodeThemeOptions() {
  const options = [];
  return options;
}
function getDiffedLanguage(language) {
  const DIFF_LANGUAGE_REGEX = /^diff-([\w-]+)/i;
  const diffLanguageMatch = DIFF_LANGUAGE_REGEX.exec(language);
  return diffLanguageMatch ? diffLanguageMatch[1] : null;
}
function isCodeLanguageLoaded(language) {
  const diffedLanguage = getDiffedLanguage(language);
  const langId = diffedLanguage ? diffedLanguage : language;
  try {
    return langId ? Prism$1.languages.hasOwnProperty(langId) : false;
  } catch (_unused) {
    return false;
  }
}
async function loadCodeLanguage(language, editor, codeNodeKey) {
}
function getTextContent(token) {
  if (typeof token === "string") {
    return token;
  } else if (Array.isArray(token)) {
    return token.map(getTextContent).join("");
  } else {
    return getTextContent(token.content);
  }
}
function tokenizeDiffHighlight(tokens, language) {
  const diffLanguage = language;
  const diffGrammar = Prism$1.languages[diffLanguage];
  const env = {
    tokens
  };
  const PREFIXES = Prism$1.languages.diff.PREFIXES;
  for (const token of env.tokens) {
    if (typeof token === "string" || !(token.type in PREFIXES) || !Array.isArray(token.content)) {
      continue;
    }
    const type = token.type;
    let insertedPrefixes = 0;
    const getPrefixToken = () => {
      insertedPrefixes++;
      return new Prism$1.Token("prefix", PREFIXES[type], type.replace(/^(\w+).*/, "$1"));
    };
    const withoutPrefixes = token.content.filter((t2) => typeof t2 === "string" || t2.type !== "prefix");
    const prefixCount = token.content.length - withoutPrefixes.length;
    const diffTokens = Prism$1.tokenize(getTextContent(withoutPrefixes), diffGrammar);
    diffTokens.unshift(getPrefixToken());
    const LINE_BREAK = /\r\n|\n/g;
    const insertAfterLineBreakString = (text) => {
      const result = [];
      LINE_BREAK.lastIndex = 0;
      let last = 0;
      let m;
      while (insertedPrefixes < prefixCount && (m = LINE_BREAK.exec(text))) {
        const end = m.index + m[0].length;
        result.push(text.slice(last, end));
        last = end;
        result.push(getPrefixToken());
      }
      if (result.length === 0) {
        return void 0;
      }
      if (last < text.length) {
        result.push(text.slice(last));
      }
      return result;
    };
    const insertAfterLineBreak = (toks) => {
      for (let i2 = 0; i2 < toks.length && insertedPrefixes < prefixCount; i2++) {
        const tok = toks[i2];
        if (typeof tok === "string") {
          const inserted = insertAfterLineBreakString(tok);
          if (inserted) {
            toks.splice(i2, 1, ...inserted);
            i2 += inserted.length - 1;
          }
        } else if (typeof tok.content === "string") {
          const inserted = insertAfterLineBreakString(tok.content);
          if (inserted) {
            tok.content = inserted;
          }
        } else if (Array.isArray(tok.content)) {
          insertAfterLineBreak(tok.content);
        } else {
          insertAfterLineBreak([tok.content]);
        }
      }
    };
    insertAfterLineBreak(diffTokens);
    if (insertedPrefixes < prefixCount) {
      diffTokens.push(getPrefixToken());
    }
    token.content = diffTokens;
  }
  return env.tokens;
}
function $getHighlightNodes(codeNode, language) {
  const DIFF_LANGUAGE_REGEX = /^diff-([\w-]+)/i;
  const diffLanguageMatch = DIFF_LANGUAGE_REGEX.exec(language);
  const code = codeNode.getTextContent();
  let tokens = Prism$1.tokenize(code, Prism$1.languages[diffLanguageMatch ? "diff" : language]);
  if (diffLanguageMatch) {
    tokens = tokenizeDiffHighlight(tokens, diffLanguageMatch[1]);
  }
  return $mapTokensToLexicalStructure(tokens);
}
function $mapTokensToLexicalStructure(tokens, type) {
  const nodes = [];
  for (const token of tokens) {
    if (typeof token === "string") {
      const partials = token.split(/(\n|\t)/);
      const partialsLength = partials.length;
      for (let i2 = 0; i2 < partialsLength; i2++) {
        const part = partials[i2];
        if (part === "\n" || part === "\r\n") {
          nodes.push($createLineBreakNode2());
        } else if (part === "	") {
          nodes.push($createTabNode2());
        } else if (part.length > 0) {
          nodes.push($createCodeHighlightNode(part, type));
        }
      }
    } else {
      const {
        content,
        alias
      } = token;
      if (typeof content === "string") {
        nodes.push(...$mapTokensToLexicalStructure([content], token.type === "prefix" && typeof alias === "string" ? alias : token.type));
      } else if (Array.isArray(content)) {
        nodes.push(...$mapTokensToLexicalStructure(content, token.type === "unchanged" ? void 0 : token.type));
      }
    }
  }
  return nodes;
}
var PrismTokenizer = {
  $tokenize(codeNode, language) {
    return $getHighlightNodes(codeNode, language || this.defaultLanguage);
  },
  defaultLanguage: DEFAULT_CODE_LANGUAGE,
  tokenize(code, language) {
    return Prism$1.tokenize(code, Prism$1.languages[language || ""] || Prism$1.languages[this.defaultLanguage]);
  }
};
function $textNodeTransform(node, editor, tokenizer) {
  const parentNode = node.getParent();
  if ($isCodeNode(parentNode)) {
    codeNodeTransform(parentNode, editor, tokenizer);
  } else if ($isCodeHighlightNode(node)) {
    node.replace($createTextNode2(node.__text));
  }
}
function updateCodeGutter(node, editor) {
  const codeElement = editor.getElementByKey(node.getKey());
  if (codeElement === null) {
    return;
  }
  const children = node.getChildren();
  const childrenLength = children.length;
  if (childrenLength === codeElement.__cachedChildrenLength) {
    return;
  }
  codeElement.__cachedChildrenLength = childrenLength;
  let gutter = "1";
  let count = 1;
  for (let i2 = 0; i2 < childrenLength; i2++) {
    if ($isLineBreakNode2(children[i2])) {
      gutter += "\n" + ++count;
    }
  }
  codeElement.setAttribute("data-gutter", gutter);
}
var nodesCurrentlyHighlighting = /* @__PURE__ */ new Set();
function codeNodeTransform(node, editor, tokenizer) {
  const nodeKey = node.getKey();
  const cacheKey = editor.getKey() + "/" + nodeKey;
  if (node.getLanguage() === void 0) {
    node.setLanguage(tokenizer.defaultLanguage);
  }
  const language = node.getLanguage() || tokenizer.defaultLanguage;
  if (isCodeLanguageLoaded(language)) {
    if (!node.getIsSyntaxHighlightSupported()) {
      node.setIsSyntaxHighlightSupported(true);
    }
  } else {
    if (node.getIsSyntaxHighlightSupported()) {
      node.setIsSyntaxHighlightSupported(false);
    }
    loadCodeLanguage(language, editor, nodeKey);
    return;
  }
  if (nodesCurrentlyHighlighting.has(cacheKey)) {
    return;
  }
  nodesCurrentlyHighlighting.add(cacheKey);
  editor.update(() => {
    $updateAndRetainSelection(nodeKey, () => {
      const currentNode = $getNodeByKey2(nodeKey);
      if (!$isCodeNode(currentNode) || !currentNode.isAttached()) {
        return false;
      }
      const currentLanguage = currentNode.getLanguage() || tokenizer.defaultLanguage;
      const highlightNodes = tokenizer.$tokenize(currentNode, currentLanguage);
      const diffRange = getDiffRange(currentNode.getChildren(), highlightNodes);
      const {
        from,
        to,
        nodesForReplacement
      } = diffRange;
      if (from !== to || nodesForReplacement.length) {
        node.splice(from, to - from, nodesForReplacement);
        return true;
      }
      return false;
    });
  }, {
    onUpdate: () => {
      nodesCurrentlyHighlighting.delete(cacheKey);
    },
    skipTransforms: true
  });
}
function $updateAndRetainSelection(nodeKey, updateFn) {
  const node = $getNodeByKey2(nodeKey);
  if (!$isCodeNode(node) || !node.isAttached()) {
    return;
  }
  const selection = $getSelection2();
  if (!$isRangeSelection2(selection)) {
    updateFn();
    return;
  }
  const anchor = selection.anchor;
  const anchorOffset = anchor.offset;
  const isNewLineAnchor = anchor.type === "element" && $isLineBreakNode2(node.getChildAtIndex(anchor.offset - 1));
  let textOffset = 0;
  if (!isNewLineAnchor) {
    const anchorNode = anchor.getNode();
    textOffset = anchorOffset + anchorNode.getPreviousSiblings().reduce((offset, _node) => {
      return offset + _node.getTextContentSize();
    }, 0);
  }
  const hasChanges = updateFn();
  if (!hasChanges) {
    return;
  }
  if (isNewLineAnchor) {
    anchor.getNode().select(anchorOffset, anchorOffset);
    return;
  }
  node.getChildren().some((_node) => {
    const isText = $isTextNode2(_node);
    if (isText || $isLineBreakNode2(_node)) {
      const textContentSize = _node.getTextContentSize();
      if (isText && textContentSize >= textOffset) {
        _node.select(textOffset, textOffset);
        return true;
      }
      textOffset -= textContentSize;
    }
    return false;
  });
}
function getDiffRange(prevNodes, nextNodes) {
  let leadingMatch = 0;
  while (leadingMatch < prevNodes.length) {
    if (!isEqual(prevNodes[leadingMatch], nextNodes[leadingMatch])) {
      break;
    }
    leadingMatch++;
  }
  const prevNodesLength = prevNodes.length;
  const nextNodesLength = nextNodes.length;
  const maxTrailingMatch = Math.min(prevNodesLength, nextNodesLength) - leadingMatch;
  let trailingMatch = 0;
  while (trailingMatch < maxTrailingMatch) {
    trailingMatch++;
    if (!isEqual(prevNodes[prevNodesLength - trailingMatch], nextNodes[nextNodesLength - trailingMatch])) {
      trailingMatch--;
      break;
    }
  }
  const from = leadingMatch;
  const to = prevNodesLength - trailingMatch;
  const nodesForReplacement = nextNodes.slice(leadingMatch, nextNodesLength - trailingMatch);
  return {
    from,
    nodesForReplacement,
    to
  };
}
function isEqual(nodeA, nodeB) {
  return $isCodeHighlightNode(nodeA) && $isCodeHighlightNode(nodeB) && nodeA.__text === nodeB.__text && nodeA.__highlightType === nodeB.__highlightType || $isTabNode2(nodeA) && $isTabNode2(nodeB) || $isLineBreakNode2(nodeA) && $isLineBreakNode2(nodeB);
}
function $isSelectionInCode(selection) {
  if (!$isRangeSelection2(selection)) {
    return false;
  }
  const anchorNode = selection.anchor.getNode();
  const maybeAnchorCodeNode = $isCodeNode(anchorNode) ? anchorNode : anchorNode.getParent();
  const focusNode = selection.focus.getNode();
  const maybeFocusCodeNode = $isCodeNode(focusNode) ? focusNode : focusNode.getParent();
  return $isCodeNode(maybeAnchorCodeNode) && maybeAnchorCodeNode.is(maybeFocusCodeNode);
}
function $getCodeLines(selection) {
  const nodes = selection.getNodes();
  const lines = [];
  if (nodes.length === 1 && $isCodeNode(nodes[0])) {
    return lines;
  }
  let lastLine = [];
  for (let i2 = 0; i2 < nodes.length; i2++) {
    const node = nodes[i2];
    if (!($isCodeHighlightNode(node) || $isTabNode2(node) || $isLineBreakNode2(node))) {
      formatDevErrorMessage7(`Expected selection to be inside CodeBlock and consisting of CodeHighlightNode, TabNode and LineBreakNode`);
    }
    if ($isLineBreakNode2(node)) {
      if (lastLine.length > 0) {
        lines.push(lastLine);
        lastLine = [];
      }
    } else {
      lastLine.push(node);
    }
  }
  if (lastLine.length > 0) {
    const selectionEnd = selection.isBackward() ? selection.anchor : selection.focus;
    const lastPoint = $createPoint2(lastLine[0].getKey(), 0, "text");
    if (!selectionEnd.is(lastPoint)) {
      lines.push(lastLine);
    }
  }
  return lines;
}
function $handleTab(shiftKey) {
  const selection = $getSelection2();
  if (!$isRangeSelection2(selection) || !$isSelectionInCode(selection)) {
    return null;
  }
  const indentOrOutdent = !shiftKey ? INDENT_CONTENT_COMMAND2 : OUTDENT_CONTENT_COMMAND2;
  const tabOrOutdent = !shiftKey ? INSERT_TAB_COMMAND2 : OUTDENT_CONTENT_COMMAND2;
  const anchor = selection.anchor;
  const focus = selection.focus;
  if (anchor.is(focus)) {
    return tabOrOutdent;
  }
  const codeLines = $getCodeLines(selection);
  if (codeLines.length !== 1) {
    return indentOrOutdent;
  }
  const codeLine = codeLines[0];
  const codeLineLength = codeLine.length;
  if (!(codeLineLength !== 0)) {
    formatDevErrorMessage7(`$getCodeLines only extracts non-empty lines`);
  }
  let selectionFirst;
  let selectionLast;
  if (selection.isBackward()) {
    selectionFirst = focus;
    selectionLast = anchor;
  } else {
    selectionFirst = anchor;
    selectionLast = focus;
  }
  const firstOfLine = $getFirstCodeNodeOfLine(codeLine[0]);
  const lastOfLine = $getLastCodeNodeOfLine(codeLine[0]);
  const anchorOfLine = $createPoint2(firstOfLine.getKey(), 0, "text");
  const focusOfLine = $createPoint2(lastOfLine.getKey(), lastOfLine.getTextContentSize(), "text");
  if (selectionFirst.isBefore(anchorOfLine)) {
    return indentOrOutdent;
  }
  if (focusOfLine.isBefore(selectionLast)) {
    return indentOrOutdent;
  }
  if (anchorOfLine.isBefore(selectionFirst) || selectionLast.isBefore(focusOfLine)) {
    return tabOrOutdent;
  }
  return indentOrOutdent;
}
function $handleMultilineIndent(type) {
  const selection = $getSelection2();
  if (!$isRangeSelection2(selection) || !$isSelectionInCode(selection)) {
    return false;
  }
  const codeLines = $getCodeLines(selection);
  const codeLinesLength = codeLines.length;
  if (codeLinesLength === 0 && selection.isCollapsed()) {
    if (type === INDENT_CONTENT_COMMAND2) {
      selection.insertNodes([$createTabNode2()]);
    }
    return true;
  }
  if (codeLinesLength === 0 && type === INDENT_CONTENT_COMMAND2 && selection.getTextContent() === "\n") {
    const tabNode = $createTabNode2();
    const lineBreakNode = $createLineBreakNode2();
    const direction = selection.isBackward() ? "previous" : "next";
    selection.insertNodes([tabNode, lineBreakNode]);
    $setSelectionFromCaretRange2($getCaretRangeInDirection2($getCaretRange2($getTextPointCaret2(tabNode, "next", 0), $normalizeCaret2($getSiblingCaret2(lineBreakNode, "next"))), direction));
    return true;
  }
  for (let i2 = 0; i2 < codeLinesLength; i2++) {
    const line = codeLines[i2];
    if (line.length > 0) {
      let firstOfLine = line[0];
      if (i2 === 0) {
        firstOfLine = $getFirstCodeNodeOfLine(firstOfLine);
      }
      if (type === INDENT_CONTENT_COMMAND2) {
        const tabNode = $createTabNode2();
        firstOfLine.insertBefore(tabNode);
        if (i2 === 0) {
          const anchorKey = selection.isBackward() ? "focus" : "anchor";
          const anchorLine = $createPoint2(firstOfLine.getKey(), 0, "text");
          if (selection[anchorKey].is(anchorLine)) {
            selection[anchorKey].set(tabNode.getKey(), 0, "text");
          }
        }
      } else if ($isTabNode2(firstOfLine)) {
        firstOfLine.remove();
      }
    }
  }
  return true;
}
function $handleShiftLines(type, event) {
  const selection = $getSelection2();
  if (!$isRangeSelection2(selection)) {
    return false;
  }
  const {
    anchor,
    focus
  } = selection;
  const anchorOffset = anchor.offset;
  const focusOffset = focus.offset;
  const anchorNode = anchor.getNode();
  const focusNode = focus.getNode();
  const arrowIsUp = type === KEY_ARROW_UP_COMMAND2;
  if (!$isSelectionInCode(selection) || !($isCodeHighlightNode(anchorNode) || $isTabNode2(anchorNode)) || !($isCodeHighlightNode(focusNode) || $isTabNode2(focusNode))) {
    return false;
  }
  if (!event.altKey) {
    if (selection.isCollapsed()) {
      const codeNode = anchorNode.getParentOrThrow();
      if (arrowIsUp && anchorOffset === 0 && anchorNode.getPreviousSibling() === null) {
        const codeNodeSibling = codeNode.getPreviousSibling();
        if (codeNodeSibling === null) {
          codeNode.selectPrevious();
          event.preventDefault();
          return true;
        }
      } else if (!arrowIsUp && anchorOffset === anchorNode.getTextContentSize() && anchorNode.getNextSibling() === null) {
        const codeNodeSibling = codeNode.getNextSibling();
        if (codeNodeSibling === null) {
          codeNode.selectNext();
          event.preventDefault();
          return true;
        }
      }
    }
    return false;
  }
  let start;
  let end;
  if (anchorNode.isBefore(focusNode)) {
    start = $getFirstCodeNodeOfLine(anchorNode);
    end = $getLastCodeNodeOfLine(focusNode);
  } else {
    start = $getFirstCodeNodeOfLine(focusNode);
    end = $getLastCodeNodeOfLine(anchorNode);
  }
  if (start == null || end == null) {
    return false;
  }
  const range = start.getNodesBetween(end);
  for (let i2 = 0; i2 < range.length; i2++) {
    const node = range[i2];
    if (!$isCodeHighlightNode(node) && !$isTabNode2(node) && !$isLineBreakNode2(node)) {
      return false;
    }
  }
  event.preventDefault();
  event.stopPropagation();
  const linebreak = arrowIsUp ? start.getPreviousSibling() : end.getNextSibling();
  if (!$isLineBreakNode2(linebreak)) {
    return true;
  }
  const sibling = arrowIsUp ? linebreak.getPreviousSibling() : linebreak.getNextSibling();
  if (sibling == null) {
    return true;
  }
  const maybeInsertionPoint = $isCodeHighlightNode(sibling) || $isTabNode2(sibling) || $isLineBreakNode2(sibling) ? arrowIsUp ? $getFirstCodeNodeOfLine(sibling) : $getLastCodeNodeOfLine(sibling) : null;
  let insertionPoint = maybeInsertionPoint != null ? maybeInsertionPoint : sibling;
  linebreak.remove();
  range.forEach((node) => node.remove());
  if (type === KEY_ARROW_UP_COMMAND2) {
    range.forEach((node) => insertionPoint.insertBefore(node));
    insertionPoint.insertBefore(linebreak);
  } else {
    insertionPoint.insertAfter(linebreak);
    insertionPoint = linebreak;
    range.forEach((node) => {
      insertionPoint.insertAfter(node);
      insertionPoint = node;
    });
  }
  selection.setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset);
  return true;
}
function $handleMoveTo(type, event) {
  const selection = $getSelection2();
  if (!$isRangeSelection2(selection)) {
    return false;
  }
  const {
    anchor,
    focus
  } = selection;
  const anchorNode = anchor.getNode();
  const focusNode = focus.getNode();
  const isMoveToStart2 = type === MOVE_TO_START2;
  if (!$isSelectionInCode(selection) || !($isCodeHighlightNode(anchorNode) || $isTabNode2(anchorNode)) || !($isCodeHighlightNode(focusNode) || $isTabNode2(focusNode))) {
    return false;
  }
  const focusLineNode = focusNode;
  const direction = $getCodeLineDirection(focusLineNode);
  const moveToStart = direction === "rtl" ? !isMoveToStart2 : isMoveToStart2;
  if (moveToStart) {
    const start = $getStartOfCodeInLine(focusLineNode, focus.offset);
    if (start !== null) {
      const {
        node,
        offset
      } = start;
      if ($isLineBreakNode2(node)) {
        node.selectNext(0, 0);
      } else {
        selection.setTextNodeRange(node, offset, node, offset);
      }
    } else {
      focusLineNode.getParentOrThrow().selectStart();
    }
  } else {
    const node = $getEndOfCodeInLine(focusLineNode);
    node.select();
  }
  event.preventDefault();
  event.stopPropagation();
  return true;
}
function registerCodeHighlighting(editor, tokenizer) {
  if (!editor.hasNodes([CodeNode, CodeHighlightNode])) {
    throw new Error("CodeHighlightPlugin: CodeNode or CodeHighlightNode not registered on editor");
  }
  if (tokenizer == null) {
    tokenizer = PrismTokenizer;
  }
  const registrations = [];
  if (editor._headless !== true) {
    registrations.push(editor.registerMutationListener(CodeNode, (mutations) => {
      editor.getEditorState().read(() => {
        for (const [key, type] of mutations) {
          if (type !== "destroyed") {
            const node = $getNodeByKey2(key);
            if (node !== null) {
              updateCodeGutter(node, editor);
            }
          }
        }
      });
    }, {
      skipInitialization: false
    }));
  }
  registrations.push(editor.registerNodeTransform(CodeNode, (node) => codeNodeTransform(node, editor, tokenizer)), editor.registerNodeTransform(TextNode2, (node) => $textNodeTransform(node, editor, tokenizer)), editor.registerNodeTransform(CodeHighlightNode, (node) => $textNodeTransform(node, editor, tokenizer)), editor.registerCommand(KEY_TAB_COMMAND2, (event) => {
    const command = $handleTab(event.shiftKey);
    if (command === null) {
      return false;
    }
    event.preventDefault();
    editor.dispatchCommand(command, void 0);
    return true;
  }, COMMAND_PRIORITY_LOW2), editor.registerCommand(INSERT_TAB_COMMAND2, () => {
    const selection = $getSelection2();
    if (!$isSelectionInCode(selection)) {
      return false;
    }
    $insertNodes2([$createTabNode2()]);
    return true;
  }, COMMAND_PRIORITY_LOW2), editor.registerCommand(INDENT_CONTENT_COMMAND2, (payload) => $handleMultilineIndent(INDENT_CONTENT_COMMAND2), COMMAND_PRIORITY_LOW2), editor.registerCommand(OUTDENT_CONTENT_COMMAND2, (payload) => $handleMultilineIndent(OUTDENT_CONTENT_COMMAND2), COMMAND_PRIORITY_LOW2), editor.registerCommand(KEY_ARROW_UP_COMMAND2, (event) => {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    const {
      anchor
    } = selection;
    const anchorNode = anchor.getNode();
    if (!$isSelectionInCode(selection)) {
      return false;
    }
    if (selection.isCollapsed() && anchor.offset === 0 && anchorNode.getPreviousSibling() === null && $isCodeNode(anchorNode.getParentOrThrow())) {
      event.preventDefault();
      return true;
    }
    return $handleShiftLines(KEY_ARROW_UP_COMMAND2, event);
  }, COMMAND_PRIORITY_LOW2), editor.registerCommand(KEY_ARROW_DOWN_COMMAND2, (event) => {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    const {
      anchor
    } = selection;
    const anchorNode = anchor.getNode();
    if (!$isSelectionInCode(selection)) {
      return false;
    }
    if (selection.isCollapsed() && anchor.offset === anchorNode.getTextContentSize() && anchorNode.getNextSibling() === null && $isCodeNode(anchorNode.getParentOrThrow())) {
      event.preventDefault();
      return true;
    }
    return $handleShiftLines(KEY_ARROW_DOWN_COMMAND2, event);
  }, COMMAND_PRIORITY_LOW2), editor.registerCommand(MOVE_TO_START2, (event) => $handleMoveTo(MOVE_TO_START2, event), COMMAND_PRIORITY_LOW2), editor.registerCommand(MOVE_TO_END2, (event) => $handleMoveTo(MOVE_TO_END2, event), COMMAND_PRIORITY_LOW2));
  return mergeRegister2(...registrations);
}
var getFirstCodeNodeOfLine = $getFirstCodeNodeOfLine;
var getLastCodeNodeOfLine = $getLastCodeNodeOfLine;
var getEndOfCodeInLine = $getEndOfCodeInLine;
var getStartOfCodeInLine = $getStartOfCodeInLine;

// node_modules/@lexical/code/LexicalCode.prod.mjs
var import_prismjs2 = __toESM(require_prism(), 1);
function R(e2, n2) {
  for (const r2 of e2.childNodes) {
    if (isHTMLElement3(r2) && r2.tagName === n2) return true;
    R(r2, n2);
  }
  return false;
}
var K = "data-language";
var $ = "data-highlight-language";
var W = "data-theme";
var q = class _q extends ElementNode2 {
  constructor(t2, e2) {
    super(e2);
    __publicField(this, "__language");
    __publicField(this, "__theme");
    __publicField(this, "__isSyntaxHighlightSupported");
    this.__language = t2 || void 0, this.__isSyntaxHighlightSupported = false, this.__theme = void 0;
  }
  static getType() {
    return "code";
  }
  static clone(t2) {
    return new _q(t2.__language, t2.__key);
  }
  afterCloneFrom(t2) {
    super.afterCloneFrom(t2), this.__language = t2.__language, this.__theme = t2.__theme, this.__isSyntaxHighlightSupported = t2.__isSyntaxHighlightSupported;
  }
  createDOM(t2) {
    const n2 = document.createElement("code");
    addClassNamesToElement2(n2, t2.theme.code), n2.setAttribute("spellcheck", "false");
    const r2 = this.getLanguage();
    r2 && (n2.setAttribute(K, r2), this.getIsSyntaxHighlightSupported() && n2.setAttribute($, r2));
    const i2 = this.getTheme();
    i2 && n2.setAttribute(W, i2);
    const o2 = this.getStyle();
    return o2 && n2.setAttribute("style", o2), n2;
  }
  updateDOM(t2, e2, n2) {
    const r2 = this.__language, i2 = t2.__language;
    r2 ? r2 !== i2 && e2.setAttribute(K, r2) : i2 && e2.removeAttribute(K);
    const o2 = this.__isSyntaxHighlightSupported;
    t2.__isSyntaxHighlightSupported && i2 ? o2 && r2 ? r2 !== i2 && e2.setAttribute($, r2) : e2.removeAttribute($) : o2 && r2 && e2.setAttribute($, r2);
    const s2 = this.__theme, l2 = t2.__theme;
    s2 ? s2 !== l2 && e2.setAttribute(W, s2) : l2 && e2.removeAttribute(W);
    const u2 = this.__style, c2 = t2.__style;
    return u2 ? u2 !== c2 && e2.setAttribute("style", u2) : c2 && e2.removeAttribute("style"), false;
  }
  exportDOM(t2) {
    const n2 = document.createElement("pre");
    addClassNamesToElement2(n2, t2._config.theme.code), n2.setAttribute("spellcheck", "false");
    const r2 = this.getLanguage();
    r2 && (n2.setAttribute(K, r2), this.getIsSyntaxHighlightSupported() && n2.setAttribute($, r2));
    const i2 = this.getTheme();
    i2 && n2.setAttribute(W, i2);
    const o2 = this.getStyle();
    return o2 && n2.setAttribute("style", o2), { element: n2 };
  }
  static importDOM() {
    return { code: (t2) => null != t2.textContent && (/\r?\n/.test(t2.textContent) || R(t2, "BR")) ? { conversion: Q, priority: 1 } : null, div: () => ({ conversion: G, priority: 1 }), pre: () => ({ conversion: Q, priority: 0 }), table: (t2) => tt(t2) ? { conversion: V, priority: 3 } : null, td: (t2) => {
      const e2 = t2, n2 = e2.closest("table");
      return e2.classList.contains("js-file-line") || n2 && tt(n2) ? { conversion: Y, priority: 3 } : null;
    }, tr: (t2) => {
      const e2 = t2.closest("table");
      return e2 && tt(e2) ? { conversion: Y, priority: 3 } : null;
    } };
  }
  static importJSON(t2) {
    return U().updateFromJSON(t2);
  }
  updateFromJSON(t2) {
    return super.updateFromJSON(t2).setLanguage(t2.language).setTheme(t2.theme);
  }
  exportJSON() {
    return { ...super.exportJSON(), language: this.getLanguage(), theme: this.getTheme() };
  }
  insertNewAfter(t2, e2 = true) {
    const n2 = this.getChildren(), r2 = n2.length;
    if (r2 >= 2 && "\n" === n2[r2 - 1].getTextContent() && "\n" === n2[r2 - 2].getTextContent() && t2.isCollapsed() && t2.anchor.key === this.__key && t2.anchor.offset === r2) {
      n2[r2 - 1].remove(), n2[r2 - 2].remove();
      const t3 = $createParagraphNode2();
      return this.insertAfter(t3, e2), t3;
    }
    const { anchor: i2, focus: o2 } = t2, a2 = (i2.isBefore(o2) ? i2 : o2).getNode();
    if ($isTextNode2(a2)) {
      let t3 = st(a2);
      const e3 = [];
      for (; ; ) if ($isTabNode2(t3)) e3.push($createTabNode2()), t3 = t3.getNextSibling();
      else {
        if (!it(t3)) break;
        {
          let n4 = 0;
          const r4 = t3.getTextContent(), i3 = t3.getTextContentSize();
          for (; n4 < i3 && " " === r4[n4]; ) n4++;
          if (0 !== n4 && e3.push(rt(" ".repeat(n4))), n4 !== i3) break;
          t3 = t3.getNextSibling();
        }
      }
      const n3 = a2.splitText(i2.offset)[0], r3 = 0 === i2.offset ? 0 : 1, o3 = n3.getIndexWithinParent() + r3, s2 = a2.getParentOrThrow(), l2 = [$createLineBreakNode2(), ...e3];
      s2.splice(o3, 0, l2);
      const f2 = e3[e3.length - 1];
      f2 ? f2.select() : 0 === i2.offset ? n3.selectPrevious() : n3.getNextSibling().selectNext(0, 0);
    }
    if (X(a2)) {
      const { offset: e3 } = t2.anchor;
      a2.splice(e3, 0, [$createLineBreakNode2()]), a2.select(e3 + 1, e3 + 1);
    }
    return null;
  }
  canIndent() {
    return false;
  }
  collapseAtStart() {
    const t2 = $createParagraphNode2();
    return this.getChildren().forEach((e2) => t2.append(e2)), this.replace(t2), true;
  }
  setLanguage(t2) {
    const e2 = this.getWritable();
    return e2.__language = t2 || void 0, e2;
  }
  getLanguage() {
    return this.getLatest().__language;
  }
  setIsSyntaxHighlightSupported(t2) {
    const e2 = this.getWritable();
    return e2.__isSyntaxHighlightSupported = t2, e2;
  }
  getIsSyntaxHighlightSupported() {
    return this.getLatest().__isSyntaxHighlightSupported;
  }
  setTheme(t2) {
    const e2 = this.getWritable();
    return e2.__theme = t2 || void 0, e2;
  }
  getTheme() {
    return this.getLatest().__theme;
  }
};
function U(t2, e2) {
  return $create2(q).setLanguage(t2).setTheme(e2);
}
function X(t2) {
  return t2 instanceof q;
}
function Q(t2) {
  return { node: U(t2.getAttribute(K)) };
}
function G(t2) {
  const e2 = t2, n2 = Z(e2);
  return n2 || (function(t3) {
    let e3 = t3.parentElement;
    for (; null !== e3; ) {
      if (Z(e3)) return true;
      e3 = e3.parentElement;
    }
    return false;
  })(e2) ? { node: n2 ? U() : null } : { node: null };
}
function V() {
  return { node: U() };
}
function Y() {
  return { node: null };
}
function Z(t2) {
  return null !== t2.style.fontFamily.match("monospace");
}
function tt(t2) {
  return t2.classList.contains("js-file-line-container");
}
var et = class _et extends TextNode2 {
  constructor(t2 = "", e2, n2) {
    super(t2, n2);
    __publicField(this, "__highlightType");
    this.__highlightType = e2;
  }
  static getType() {
    return "code-highlight";
  }
  static clone(t2) {
    return new _et(t2.__text, t2.__highlightType || void 0, t2.__key);
  }
  getHighlightType() {
    return this.getLatest().__highlightType;
  }
  setHighlightType(t2) {
    const e2 = this.getWritable();
    return e2.__highlightType = t2 || void 0, e2;
  }
  canHaveFormat() {
    return false;
  }
  createDOM(t2) {
    const n2 = super.createDOM(t2), r2 = nt(t2.theme, this.__highlightType);
    return addClassNamesToElement2(n2, r2), n2;
  }
  updateDOM(t2, r2, i2) {
    const o2 = super.updateDOM(t2, r2, i2), s2 = nt(i2.theme, t2.__highlightType), l2 = nt(i2.theme, this.__highlightType);
    return s2 !== l2 && (s2 && removeClassNamesFromElement2(r2, s2), l2 && addClassNamesToElement2(r2, l2)), o2;
  }
  static importJSON(t2) {
    return rt().updateFromJSON(t2);
  }
  updateFromJSON(t2) {
    return super.updateFromJSON(t2).setHighlightType(t2.highlightType);
  }
  exportJSON() {
    return { ...super.exportJSON(), highlightType: this.getHighlightType() };
  }
  setFormat(t2) {
    return this;
  }
  isParentRequired() {
    return true;
  }
  createParentElementNode() {
    return U();
  }
};
function nt(t2, e2) {
  return e2 && t2 && t2.codeHighlight && t2.codeHighlight[e2];
}
function rt(t2 = "", e2) {
  return $applyNodeReplacement2(new et(t2, e2));
}
function it(t2) {
  return t2 instanceof et;
}
function ot(t2, e2) {
  let n2 = t2;
  for (let i2 = $getSiblingCaret2(t2, e2); i2 && (it(i2.origin) || $isTabNode2(i2.origin)); i2 = $getAdjacentCaret2(i2)) n2 = i2.origin;
  return n2;
}
function st(t2) {
  return ot(t2, "previous");
}
var at = defineExtension2({ name: "@lexical/code", nodes: () => [q, et] });
!(function(t2) {
  t2.languages.diff = { coord: [/^(?:\*{3}|-{3}|\+{3}).*$/m, /^@@.*@@$/m, /^\d.*$/m] };
  var e2 = { "deleted-sign": "-", "deleted-arrow": "<", "inserted-sign": "+", "inserted-arrow": ">", unchanged: " ", diff: "!" };
  Object.keys(e2).forEach(function(n2) {
    var r2 = e2[n2], i2 = [];
    /^\w+$/.test(n2) || i2.push(/\w+/.exec(n2)[0]), "diff" === n2 && i2.push("bold"), t2.languages.diff[n2] = { pattern: RegExp("^(?:[" + r2 + "].*(?:\r\n?|\n|(?![\\s\\S])))+", "m"), alias: i2, inside: { line: { pattern: /(.)(?=[\s\S]).*(?:\r\n?|\n)?/, lookbehind: true }, prefix: { pattern: /[\s\S]/, alias: /\w+/.exec(n2)[0] } } };
  }), Object.defineProperty(t2.languages.diff, "PREFIXES", { value: e2 });
})(Prism);
var ft = globalThis.Prism || window.Prism;

// node_modules/@lexical/code/LexicalCode.mjs
var mod11 = true ? LexicalCode_dev_exports : LexicalCode_prod_exports;
var $createCodeHighlightNode2 = mod11.$createCodeHighlightNode;
var $createCodeNode2 = mod11.$createCodeNode;
var $getCodeLineDirection2 = mod11.$getCodeLineDirection;
var $getEndOfCodeInLine2 = mod11.$getEndOfCodeInLine;
var $getFirstCodeNodeOfLine2 = mod11.$getFirstCodeNodeOfLine;
var $getLastCodeNodeOfLine2 = mod11.$getLastCodeNodeOfLine;
var $getStartOfCodeInLine2 = mod11.$getStartOfCodeInLine;
var $isCodeHighlightNode2 = mod11.$isCodeHighlightNode;
var $isCodeNode2 = mod11.$isCodeNode;
var CODE_LANGUAGE_FRIENDLY_NAME_MAP2 = mod11.CODE_LANGUAGE_FRIENDLY_NAME_MAP;
var CODE_LANGUAGE_MAP2 = mod11.CODE_LANGUAGE_MAP;
var CodeExtension2 = mod11.CodeExtension;
var CodeHighlightNode2 = mod11.CodeHighlightNode;
var CodeNode2 = mod11.CodeNode;
var DEFAULT_CODE_LANGUAGE2 = mod11.DEFAULT_CODE_LANGUAGE;
var PrismTokenizer2 = mod11.PrismTokenizer;
var getCodeLanguageOptions2 = mod11.getCodeLanguageOptions;
var getCodeLanguages2 = mod11.getCodeLanguages;
var getCodeThemeOptions2 = mod11.getCodeThemeOptions;
var getDefaultCodeLanguage2 = mod11.getDefaultCodeLanguage;
var getEndOfCodeInLine2 = mod11.getEndOfCodeInLine;
var getFirstCodeNodeOfLine2 = mod11.getFirstCodeNodeOfLine;
var getLanguageFriendlyName2 = mod11.getLanguageFriendlyName;
var getLastCodeNodeOfLine2 = mod11.getLastCodeNodeOfLine;
var getStartOfCodeInLine2 = mod11.getStartOfCodeInLine;
var normalizeCodeLang2 = mod11.normalizeCodeLang;
var normalizeCodeLanguage = mod11.normalizeCodeLanguage;
var registerCodeHighlighting2 = mod11.registerCodeHighlighting;

// node_modules/@lexical/link/LexicalLink.dev.mjs
var LexicalLink_dev_exports = {};
__export(LexicalLink_dev_exports, {
  $createAutoLinkNode: () => $createAutoLinkNode,
  $createLinkNode: () => $createLinkNode,
  $isAutoLinkNode: () => $isAutoLinkNode,
  $isLinkNode: () => $isLinkNode,
  $toggleLink: () => $toggleLink,
  AutoLinkExtension: () => AutoLinkExtension,
  AutoLinkNode: () => AutoLinkNode,
  ClickableLinkExtension: () => ClickableLinkExtension,
  LinkExtension: () => LinkExtension,
  LinkNode: () => LinkNode,
  TOGGLE_LINK_COMMAND: () => TOGGLE_LINK_COMMAND,
  createLinkMatcherWithRegExp: () => createLinkMatcherWithRegExp,
  formatUrl: () => formatUrl,
  registerAutoLink: () => registerAutoLink,
  registerClickableLink: () => registerClickableLink,
  registerLink: () => registerLink,
  toggleLink: () => toggleLink
});
function formatDevErrorMessage8(message) {
  throw new Error(message);
}
var SUPPORTED_URL_PROTOCOLS = /* @__PURE__ */ new Set(["http:", "https:", "mailto:", "sms:", "tel:"]);
var LinkNode = class _LinkNode extends ElementNode2 {
  constructor(url = "", attributes = {}, key) {
    super(key);
    /** @internal */
    __publicField(this, "__url");
    /** @internal */
    __publicField(this, "__target");
    /** @internal */
    __publicField(this, "__rel");
    /** @internal */
    __publicField(this, "__title");
    const {
      target = null,
      rel = null,
      title = null
    } = attributes;
    this.__url = url;
    this.__target = target;
    this.__rel = rel;
    this.__title = title;
  }
  static getType() {
    return "link";
  }
  static clone(node) {
    return new _LinkNode(node.__url, {
      rel: node.__rel,
      target: node.__target,
      title: node.__title
    }, node.__key);
  }
  createDOM(config) {
    const element = document.createElement("a");
    this.updateLinkDOM(null, element, config);
    addClassNamesToElement2(element, config.theme.link);
    return element;
  }
  updateLinkDOM(prevNode, anchor, config) {
    if (isHTMLAnchorElement3(anchor)) {
      if (!prevNode || prevNode.__url !== this.__url) {
        anchor.href = this.sanitizeUrl(this.__url);
      }
      for (const attr of ["target", "rel", "title"]) {
        const key = `__${attr}`;
        const value = this[key];
        if (!prevNode || prevNode[key] !== value) {
          if (value) {
            anchor[attr] = value;
          } else {
            anchor.removeAttribute(attr);
          }
        }
      }
    }
  }
  updateDOM(prevNode, anchor, config) {
    this.updateLinkDOM(prevNode, anchor, config);
    return false;
  }
  static importDOM() {
    return {
      a: (node) => ({
        conversion: $convertAnchorElement,
        priority: 1
      })
    };
  }
  static importJSON(serializedNode) {
    return $createLinkNode().updateFromJSON(serializedNode);
  }
  updateFromJSON(serializedNode) {
    return super.updateFromJSON(serializedNode).setURL(serializedNode.url).setRel(serializedNode.rel || null).setTarget(serializedNode.target || null).setTitle(serializedNode.title || null);
  }
  sanitizeUrl(url) {
    url = formatUrl(url);
    try {
      const parsedUrl = new URL(formatUrl(url));
      if (!SUPPORTED_URL_PROTOCOLS.has(parsedUrl.protocol)) {
        return "about:blank";
      }
    } catch (_unused) {
      return url;
    }
    return url;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      rel: this.getRel(),
      target: this.getTarget(),
      title: this.getTitle(),
      url: this.getURL()
    };
  }
  getURL() {
    return this.getLatest().__url;
  }
  setURL(url) {
    const writable = this.getWritable();
    writable.__url = url;
    return writable;
  }
  getTarget() {
    return this.getLatest().__target;
  }
  setTarget(target) {
    const writable = this.getWritable();
    writable.__target = target;
    return writable;
  }
  getRel() {
    return this.getLatest().__rel;
  }
  setRel(rel) {
    const writable = this.getWritable();
    writable.__rel = rel;
    return writable;
  }
  getTitle() {
    return this.getLatest().__title;
  }
  setTitle(title) {
    const writable = this.getWritable();
    writable.__title = title;
    return writable;
  }
  insertNewAfter(_2, restoreSelection = true) {
    const linkNode = $createLinkNode(this.__url, {
      rel: this.__rel,
      target: this.__target,
      title: this.__title
    });
    this.insertAfter(linkNode, restoreSelection);
    return linkNode;
  }
  canInsertTextBefore() {
    return false;
  }
  canInsertTextAfter() {
    return false;
  }
  canBeEmpty() {
    return false;
  }
  isInline() {
    return true;
  }
  extractWithChild(child, selection, destination) {
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    const anchorNode = selection.anchor.getNode();
    const focusNode = selection.focus.getNode();
    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && selection.getTextContent().length > 0;
  }
  isEmailURI() {
    return this.__url.startsWith("mailto:");
  }
  isWebSiteURI() {
    return this.__url.startsWith("https://") || this.__url.startsWith("http://");
  }
};
function $convertAnchorElement(domNode) {
  let node = null;
  if (isHTMLAnchorElement3(domNode)) {
    const content = domNode.textContent;
    if (content !== null && content !== "" || domNode.children.length > 0) {
      node = $createLinkNode(domNode.getAttribute("href") || "", {
        rel: domNode.getAttribute("rel"),
        target: domNode.getAttribute("target"),
        title: domNode.getAttribute("title")
      });
    }
  }
  return {
    node
  };
}
function $createLinkNode(url = "", attributes) {
  return $applyNodeReplacement2(new LinkNode(url, attributes));
}
function $isLinkNode(node) {
  return node instanceof LinkNode;
}
var AutoLinkNode = class _AutoLinkNode extends LinkNode {
  constructor(url = "", attributes = {}, key) {
    super(url, attributes, key);
    /** @internal */
    /** Indicates whether the autolink was ever unlinked. **/
    __publicField(this, "__isUnlinked");
    this.__isUnlinked = attributes.isUnlinked !== void 0 && attributes.isUnlinked !== null ? attributes.isUnlinked : false;
  }
  static getType() {
    return "autolink";
  }
  static clone(node) {
    return new _AutoLinkNode(node.__url, {
      isUnlinked: node.__isUnlinked,
      rel: node.__rel,
      target: node.__target,
      title: node.__title
    }, node.__key);
  }
  getIsUnlinked() {
    return this.__isUnlinked;
  }
  setIsUnlinked(value) {
    const self2 = this.getWritable();
    self2.__isUnlinked = value;
    return self2;
  }
  createDOM(config) {
    if (this.__isUnlinked) {
      return document.createElement("span");
    } else {
      return super.createDOM(config);
    }
  }
  updateDOM(prevNode, anchor, config) {
    return super.updateDOM(prevNode, anchor, config) || prevNode.__isUnlinked !== this.__isUnlinked;
  }
  static importJSON(serializedNode) {
    return $createAutoLinkNode().updateFromJSON(serializedNode);
  }
  updateFromJSON(serializedNode) {
    return super.updateFromJSON(serializedNode).setIsUnlinked(serializedNode.isUnlinked || false);
  }
  static importDOM() {
    return null;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      isUnlinked: this.__isUnlinked
    };
  }
  insertNewAfter(selection, restoreSelection = true) {
    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);
    if ($isElementNode2(element)) {
      const linkNode = $createAutoLinkNode(this.__url, {
        isUnlinked: this.__isUnlinked,
        rel: this.__rel,
        target: this.__target,
        title: this.__title
      });
      element.append(linkNode);
      return linkNode;
    }
    return null;
  }
};
function $createAutoLinkNode(url = "", attributes) {
  return $applyNodeReplacement2(new AutoLinkNode(url, attributes));
}
function $isAutoLinkNode(node) {
  return node instanceof AutoLinkNode;
}
var TOGGLE_LINK_COMMAND = createCommand2("TOGGLE_LINK_COMMAND");
function $getPointNode(point, offset) {
  if (point.type === "element") {
    const node = point.getNode();
    if (!$isElementNode2(node)) {
      formatDevErrorMessage8(`$getPointNode: element point is not an ElementNode`);
    }
    const childNode = node.getChildren()[point.offset + offset];
    return childNode || null;
  }
  return null;
}
function $withSelectedNodes($fn) {
  const initialSelection = $getSelection2();
  if (!$isRangeSelection2(initialSelection)) {
    return $fn();
  }
  const normalized = $normalizeSelection__EXPERIMENTAL(initialSelection);
  const isBackwards = normalized.isBackward();
  const anchorNode = $getPointNode(normalized.anchor, isBackwards ? -1 : 0);
  const focusNode = $getPointNode(normalized.focus, isBackwards ? 0 : -1);
  const rval = $fn();
  if (anchorNode || focusNode) {
    const updatedSelection = $getSelection2();
    if ($isRangeSelection2(updatedSelection)) {
      const finalSelection = updatedSelection.clone();
      if (anchorNode) {
        const anchorParent = anchorNode.getParent();
        if (anchorParent) {
          finalSelection.anchor.set(anchorParent.getKey(), anchorNode.getIndexWithinParent() + (isBackwards ? 1 : 0), "element");
        }
      }
      if (focusNode) {
        const focusParent = focusNode.getParent();
        if (focusParent) {
          finalSelection.focus.set(focusParent.getKey(), focusNode.getIndexWithinParent() + (isBackwards ? 0 : 1), "element");
        }
      }
      $setSelection2($normalizeSelection__EXPERIMENTAL(finalSelection));
    }
  }
  return rval;
}
function $splitLinkAtSelection(parentLink, extractedNodes) {
  const extractedKeys = new Set(extractedNodes.filter((n2) => parentLink.isParentOf(n2)).map((n2) => n2.getKey()));
  const allChildren = parentLink.getChildren();
  const extractedChildren = allChildren.filter((child) => extractedKeys.has(child.getKey()));
  if (extractedChildren.length === allChildren.length) {
    allChildren.forEach((child) => parentLink.insertBefore(child));
    parentLink.remove();
    return;
  }
  const firstExtractedIndex = allChildren.findIndex((child) => extractedKeys.has(child.getKey()));
  const lastExtractedIndex = allChildren.findLastIndex((child) => extractedKeys.has(child.getKey()));
  const isAtStart = firstExtractedIndex === 0;
  const isAtEnd = lastExtractedIndex === allChildren.length - 1;
  if (isAtStart) {
    extractedChildren.forEach((child) => parentLink.insertBefore(child));
  } else if (isAtEnd) {
    for (let i2 = extractedChildren.length - 1; i2 >= 0; i2--) {
      parentLink.insertAfter(extractedChildren[i2]);
    }
  } else {
    for (let i2 = extractedChildren.length - 1; i2 >= 0; i2--) {
      parentLink.insertAfter(extractedChildren[i2]);
    }
    const trailingChildren = allChildren.slice(lastExtractedIndex + 1);
    if (trailingChildren.length > 0) {
      const newLink = $createLinkNode(parentLink.getURL(), {
        rel: parentLink.getRel(),
        target: parentLink.getTarget(),
        title: parentLink.getTitle()
      });
      extractedChildren[extractedChildren.length - 1].insertAfter(newLink);
      trailingChildren.forEach((child) => newLink.append(child));
    }
  }
}
function $toggleLink(urlOrAttributes, attributes = {}) {
  let url;
  if (urlOrAttributes && typeof urlOrAttributes === "object") {
    const {
      url: urlProp,
      ...rest
    } = urlOrAttributes;
    url = urlProp;
    attributes = {
      ...rest,
      ...attributes
    };
  } else {
    url = urlOrAttributes;
  }
  const {
    target,
    title
  } = attributes;
  const rel = attributes.rel === void 0 ? "noreferrer" : attributes.rel;
  const selection = $getSelection2();
  if (selection === null || !$isRangeSelection2(selection) && !$isNodeSelection2(selection)) {
    return;
  }
  if ($isNodeSelection2(selection)) {
    const nodes2 = selection.getNodes();
    if (nodes2.length === 0) {
      return;
    }
    nodes2.forEach((node) => {
      if (url === null) {
        const linkParent = $findMatchingParent3(node, (parent) => !$isAutoLinkNode(parent) && $isLinkNode(parent));
        if (linkParent) {
          linkParent.insertBefore(node);
          if (linkParent.getChildren().length === 0) {
            linkParent.remove();
          }
        }
      } else {
        const existingLink = $findMatchingParent3(node, (parent) => !$isAutoLinkNode(parent) && $isLinkNode(parent));
        if (existingLink) {
          existingLink.setURL(url);
          if (target !== void 0) {
            existingLink.setTarget(target);
          }
          if (rel !== void 0) {
            existingLink.setRel(rel);
          }
        } else {
          const linkNode = $createLinkNode(url, {
            rel,
            target
          });
          node.insertBefore(linkNode);
          linkNode.append(node);
        }
      }
    });
    return;
  }
  const nodes = selection.extract();
  if (url === null) {
    const processedLinks = /* @__PURE__ */ new Set();
    nodes.forEach((node) => {
      const parentLink = node.getParent();
      if ($isLinkNode(parentLink) && !$isAutoLinkNode(parentLink)) {
        const linkKey = parentLink.getKey();
        if (processedLinks.has(linkKey)) {
          return;
        }
        $splitLinkAtSelection(parentLink, nodes);
        processedLinks.add(linkKey);
      }
    });
    return;
  }
  const updatedNodes = /* @__PURE__ */ new Set();
  const updateLinkNode = (linkNode) => {
    if (updatedNodes.has(linkNode.getKey())) {
      return;
    }
    updatedNodes.add(linkNode.getKey());
    linkNode.setURL(url);
    if (target !== void 0) {
      linkNode.setTarget(target);
    }
    if (rel !== void 0) {
      linkNode.setRel(rel);
    }
    if (title !== void 0) {
      linkNode.setTitle(title);
    }
  };
  if (nodes.length === 1) {
    const firstNode = nodes[0];
    const linkNode = $findMatchingParent3(firstNode, $isLinkNode);
    if (linkNode !== null) {
      return updateLinkNode(linkNode);
    }
  }
  $withSelectedNodes(() => {
    let linkNode = null;
    for (const node of nodes) {
      if (!node.isAttached()) {
        continue;
      }
      const parentLinkNode = $findMatchingParent3(node, $isLinkNode);
      if (parentLinkNode) {
        updateLinkNode(parentLinkNode);
        continue;
      }
      if ($isElementNode2(node)) {
        if (!node.isInline()) {
          continue;
        }
        if ($isLinkNode(node)) {
          if (!$isAutoLinkNode(node) && (linkNode === null || !linkNode.getParentOrThrow().isParentOf(node))) {
            updateLinkNode(node);
            linkNode = node;
            continue;
          }
          for (const child of node.getChildren()) {
            node.insertBefore(child);
          }
          node.remove();
          continue;
        }
      }
      const prevLinkNode = node.getPreviousSibling();
      if ($isLinkNode(prevLinkNode) && prevLinkNode.is(linkNode)) {
        prevLinkNode.append(node);
        continue;
      }
      linkNode = $createLinkNode(url, {
        rel,
        target,
        title
      });
      node.insertAfter(linkNode);
      linkNode.append(node);
    }
  });
}
var PHONE_NUMBER_REGEX = /^\+?[0-9\s()-]{5,}$/;
function formatUrl(url) {
  if (url.match(/^[a-z][a-z0-9+.-]*:/i)) {
    return url;
  } else if (url.match(/^[/#.]/)) {
    return url;
  } else if (url.includes("@")) {
    return `mailto:${url}`;
  } else if (PHONE_NUMBER_REGEX.test(url)) {
    return `tel:${url}`;
  }
  return `https://${url}`;
}
var defaultProps = {
  attributes: void 0,
  validateUrl: void 0
};
function registerLink(editor, stores) {
  return mergeRegister2(effect(() => editor.registerCommand(TOGGLE_LINK_COMMAND, (payload) => {
    const validateUrl = stores.validateUrl.peek();
    const attributes = stores.attributes.peek();
    if (payload === null) {
      $toggleLink(null);
      return true;
    } else if (typeof payload === "string") {
      if (validateUrl === void 0 || validateUrl(payload)) {
        $toggleLink(payload, attributes);
        return true;
      }
      return false;
    } else {
      const {
        url,
        target,
        rel,
        title
      } = payload;
      $toggleLink(url, {
        ...attributes,
        rel,
        target,
        title
      });
      return true;
    }
  }, COMMAND_PRIORITY_LOW2)), effect(() => {
    const validateUrl = stores.validateUrl.value;
    if (!validateUrl) {
      return;
    }
    const attributes = stores.attributes.value;
    return editor.registerCommand(PASTE_COMMAND2, (event) => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection) || selection.isCollapsed() || !objectKlassEquals2(event, ClipboardEvent)) {
        return false;
      }
      if (event.clipboardData === null) {
        return false;
      }
      const clipboardText = event.clipboardData.getData("text");
      if (!validateUrl(clipboardText)) {
        return false;
      }
      if (!selection.getNodes().some((node) => $isElementNode2(node))) {
        editor.dispatchCommand(TOGGLE_LINK_COMMAND, {
          ...attributes,
          url: clipboardText
        });
        event.preventDefault();
        return true;
      }
      return false;
    }, COMMAND_PRIORITY_LOW2);
  }));
}
var LinkExtension = defineExtension2({
  build(editor, config, state) {
    return namedSignals2(config);
  },
  config: defaultProps,
  mergeConfig(config, overrides) {
    const merged = shallowMergeConfig2(config, overrides);
    if (config.attributes) {
      merged.attributes = shallowMergeConfig2(config.attributes, merged.attributes);
    }
    return merged;
  },
  name: "@lexical/link/Link",
  nodes: () => [LinkNode],
  register(editor, config, state) {
    return registerLink(editor, state.getOutput());
  }
});
function findMatchingDOM(startNode, predicate) {
  let node = startNode;
  while (node != null) {
    if (predicate(node)) {
      return node;
    }
    node = node.parentNode;
  }
  return null;
}
function registerClickableLink(editor, stores, eventOptions = {}) {
  const onClick3 = (event) => {
    const target = event.target;
    if (!isDOMNode2(target)) {
      return;
    }
    const nearestEditor = getNearestEditorFromDOMNode2(target);
    if (nearestEditor === null) {
      return;
    }
    let url = null;
    let urlTarget = null;
    nearestEditor.update(() => {
      const clickedNode = $getNearestNodeFromDOMNode2(target);
      if (clickedNode !== null) {
        const maybeLinkNode = $findMatchingParent3(clickedNode, $isElementNode2);
        if (!stores.disabled.peek()) {
          if ($isLinkNode(maybeLinkNode)) {
            url = maybeLinkNode.sanitizeUrl(maybeLinkNode.getURL());
            urlTarget = maybeLinkNode.getTarget();
          } else {
            const a2 = findMatchingDOM(target, isHTMLAnchorElement3);
            if (a2 !== null) {
              url = a2.href;
              urlTarget = a2.target;
            }
          }
        }
      }
    });
    if (url === null || url === "") {
      return;
    }
    const selection = editor.getEditorState().read($getSelection2);
    if ($isRangeSelection2(selection) && !selection.isCollapsed()) {
      event.preventDefault();
      return;
    }
    const isMiddle = event.type === "auxclick" && event.button === 1;
    window.open(url, stores.newTab.peek() || isMiddle || event.metaKey || event.ctrlKey || urlTarget === "_blank" ? "_blank" : "_self");
    event.preventDefault();
  };
  const onMouseUp2 = (event) => {
    if (event.button === 1) {
      onClick3(event);
    }
  };
  return editor.registerRootListener((rootElement, prevRootElement) => {
    if (prevRootElement !== null) {
      prevRootElement.removeEventListener("click", onClick3);
      prevRootElement.removeEventListener("mouseup", onMouseUp2);
    }
    if (rootElement !== null) {
      rootElement.addEventListener("click", onClick3, eventOptions);
      rootElement.addEventListener("mouseup", onMouseUp2, eventOptions);
    }
  });
}
var ClickableLinkExtension = defineExtension2({
  build(editor, config, state) {
    return namedSignals2(config);
  },
  config: safeCast2({
    disabled: false,
    newTab: false
  }),
  dependencies: [LinkExtension],
  name: "@lexical/link/ClickableLink",
  register(editor, config, state) {
    return registerClickableLink(editor, state.getOutput());
  }
});
function createLinkMatcherWithRegExp(regExp, urlTransformer = (text) => text) {
  return (text) => {
    const match = regExp.exec(text);
    if (match === null) {
      return null;
    }
    return {
      index: match.index,
      length: match[0].length,
      text: match[0],
      url: urlTransformer(match[0])
    };
  };
}
function findFirstMatch(text, matchers) {
  for (let i2 = 0; i2 < matchers.length; i2++) {
    const match = matchers[i2](text);
    if (match) {
      return match;
    }
  }
  return null;
}
var PUNCTUATION_OR_SPACE = /[.,;\s]/;
function isSeparator(char) {
  return PUNCTUATION_OR_SPACE.test(char);
}
function endsWithSeparator(textContent) {
  return isSeparator(textContent[textContent.length - 1]);
}
function startsWithSeparator(textContent) {
  return isSeparator(textContent[0]);
}
function startsWithTLD(textContent, isEmail) {
  if (isEmail) {
    return /^\.[a-zA-Z]{2,}/.test(textContent);
  } else {
    return /^\.[a-zA-Z0-9]{1,}/.test(textContent);
  }
}
function isPreviousNodeValid(node) {
  let previousNode = node.getPreviousSibling();
  if ($isElementNode2(previousNode)) {
    previousNode = previousNode.getLastDescendant();
  }
  return previousNode === null || $isLineBreakNode2(previousNode) || $isTextNode2(previousNode) && endsWithSeparator(previousNode.getTextContent());
}
function isNextNodeValid(node) {
  let nextNode = node.getNextSibling();
  if ($isElementNode2(nextNode)) {
    nextNode = nextNode.getFirstDescendant();
  }
  return nextNode === null || $isLineBreakNode2(nextNode) || $isTextNode2(nextNode) && startsWithSeparator(nextNode.getTextContent());
}
function isContentAroundIsValid(matchStart, matchEnd, text, nodes) {
  const contentBeforeIsValid = matchStart > 0 ? isSeparator(text[matchStart - 1]) : isPreviousNodeValid(nodes[0]);
  if (!contentBeforeIsValid) {
    return false;
  }
  const contentAfterIsValid = matchEnd < text.length ? isSeparator(text[matchEnd]) : isNextNodeValid(nodes[nodes.length - 1]);
  return contentAfterIsValid;
}
function extractMatchingNodes(nodes, startIndex, endIndex) {
  const unmodifiedBeforeNodes = [];
  const matchingNodes = [];
  const unmodifiedAfterNodes = [];
  let matchingOffset = 0;
  let currentOffset = 0;
  const currentNodes = [...nodes];
  while (currentNodes.length > 0) {
    const currentNode = currentNodes[0];
    const currentNodeText = currentNode.getTextContent();
    const currentNodeLength = currentNodeText.length;
    const currentNodeStart = currentOffset;
    const currentNodeEnd = currentOffset + currentNodeLength;
    if (currentNodeEnd <= startIndex) {
      unmodifiedBeforeNodes.push(currentNode);
      matchingOffset += currentNodeLength;
    } else if (currentNodeStart >= endIndex) {
      unmodifiedAfterNodes.push(currentNode);
    } else {
      matchingNodes.push(currentNode);
    }
    currentOffset += currentNodeLength;
    currentNodes.shift();
  }
  return [matchingOffset, unmodifiedBeforeNodes, matchingNodes, unmodifiedAfterNodes];
}
function $createAutoLinkNode_(nodes, startIndex, endIndex, match) {
  const linkNode = $createAutoLinkNode(match.url, match.attributes);
  if (nodes.length === 1) {
    let remainingTextNode = nodes[0];
    let linkTextNode;
    if (startIndex === 0) {
      [linkTextNode, remainingTextNode] = remainingTextNode.splitText(endIndex);
    } else {
      [, linkTextNode, remainingTextNode] = remainingTextNode.splitText(startIndex, endIndex);
    }
    const textNode = $createTextNode2(match.text);
    textNode.setFormat(linkTextNode.getFormat());
    textNode.setDetail(linkTextNode.getDetail());
    textNode.setStyle(linkTextNode.getStyle());
    linkNode.append(textNode);
    linkTextNode.replace(linkNode);
    return remainingTextNode;
  } else if (nodes.length > 1) {
    const firstTextNode = nodes[0];
    let offset = firstTextNode.getTextContent().length;
    let firstLinkTextNode;
    if (startIndex === 0) {
      firstLinkTextNode = firstTextNode;
    } else {
      [, firstLinkTextNode] = firstTextNode.splitText(startIndex);
    }
    const linkNodes = [];
    let remainingTextNode;
    for (let i2 = 1; i2 < nodes.length; i2++) {
      const currentNode = nodes[i2];
      const currentNodeText = currentNode.getTextContent();
      const currentNodeLength = currentNodeText.length;
      const currentNodeStart = offset;
      const currentNodeEnd = offset + currentNodeLength;
      if (currentNodeStart < endIndex) {
        if (currentNodeEnd <= endIndex) {
          linkNodes.push(currentNode);
        } else {
          const [linkTextNode, endNode] = currentNode.splitText(endIndex - currentNodeStart);
          linkNodes.push(linkTextNode);
          remainingTextNode = endNode;
        }
      }
      offset += currentNodeLength;
    }
    const selection = $getSelection2();
    const selectedTextNode = selection ? selection.getNodes().find($isTextNode2) : void 0;
    const textNode = $createTextNode2(firstLinkTextNode.getTextContent());
    textNode.setFormat(firstLinkTextNode.getFormat());
    textNode.setDetail(firstLinkTextNode.getDetail());
    textNode.setStyle(firstLinkTextNode.getStyle());
    linkNode.append(textNode, ...linkNodes);
    if (selectedTextNode && selectedTextNode === firstLinkTextNode) {
      if ($isRangeSelection2(selection)) {
        textNode.select(selection.anchor.offset, selection.focus.offset);
      } else if ($isNodeSelection2(selection)) {
        textNode.select(0, textNode.getTextContent().length);
      }
    }
    firstLinkTextNode.replace(linkNode);
    return remainingTextNode;
  }
  return void 0;
}
function $handleLinkCreation(nodes, matchers, onChange) {
  let currentNodes = [...nodes];
  const initialText = currentNodes.map((node) => node.getTextContent()).join("");
  let text = initialText;
  let match;
  let invalidMatchEnd = 0;
  while ((match = findFirstMatch(text, matchers)) && match !== null) {
    const matchStart = match.index;
    const matchLength = match.length;
    const matchEnd = matchStart + matchLength;
    const isValid = isContentAroundIsValid(invalidMatchEnd + matchStart, invalidMatchEnd + matchEnd, initialText, currentNodes);
    if (isValid) {
      const [matchingOffset, , matchingNodes, unmodifiedAfterNodes] = extractMatchingNodes(currentNodes, invalidMatchEnd + matchStart, invalidMatchEnd + matchEnd);
      const actualMatchStart = invalidMatchEnd + matchStart - matchingOffset;
      const actualMatchEnd = invalidMatchEnd + matchEnd - matchingOffset;
      const remainingTextNode = $createAutoLinkNode_(matchingNodes, actualMatchStart, actualMatchEnd, match);
      currentNodes = remainingTextNode ? [remainingTextNode, ...unmodifiedAfterNodes] : unmodifiedAfterNodes;
      onChange(match.url, null);
      invalidMatchEnd = 0;
    } else {
      invalidMatchEnd += matchEnd;
    }
    text = text.substring(matchEnd);
  }
}
function handleLinkEdit(linkNode, matchers, onChange) {
  const children = linkNode.getChildren();
  const childrenLength = children.length;
  for (let i2 = 0; i2 < childrenLength; i2++) {
    const child = children[i2];
    if (!$isTextNode2(child) || !child.isSimpleText()) {
      replaceWithChildren(linkNode);
      onChange(null, linkNode.getURL());
      return;
    }
  }
  const text = linkNode.getTextContent();
  const match = findFirstMatch(text, matchers);
  if (match === null || match.text !== text) {
    replaceWithChildren(linkNode);
    onChange(null, linkNode.getURL());
    return;
  }
  if (!isPreviousNodeValid(linkNode) || !isNextNodeValid(linkNode)) {
    replaceWithChildren(linkNode);
    onChange(null, linkNode.getURL());
    return;
  }
  const url = linkNode.getURL();
  if (url !== match.url) {
    linkNode.setURL(match.url);
    onChange(match.url, url);
  }
  if (match.attributes) {
    const rel = linkNode.getRel();
    if (rel !== match.attributes.rel) {
      linkNode.setRel(match.attributes.rel || null);
      onChange(match.attributes.rel || null, rel);
    }
    const target = linkNode.getTarget();
    if (target !== match.attributes.target) {
      linkNode.setTarget(match.attributes.target || null);
      onChange(match.attributes.target || null, target);
    }
  }
}
function handleBadNeighbors(textNode, matchers, onChange) {
  const previousSibling = textNode.getPreviousSibling();
  const nextSibling = textNode.getNextSibling();
  const text = textNode.getTextContent();
  if ($isAutoLinkNode(previousSibling) && !previousSibling.getIsUnlinked() && (!startsWithSeparator(text) || startsWithTLD(text, previousSibling.isEmailURI()))) {
    previousSibling.append(textNode);
    handleLinkEdit(previousSibling, matchers, onChange);
    onChange(null, previousSibling.getURL());
  }
  if ($isAutoLinkNode(nextSibling) && !nextSibling.getIsUnlinked() && !endsWithSeparator(text)) {
    replaceWithChildren(nextSibling);
    handleLinkEdit(nextSibling, matchers, onChange);
    onChange(null, nextSibling.getURL());
  }
}
function replaceWithChildren(node) {
  const children = node.getChildren();
  const childrenLength = children.length;
  for (let j = childrenLength - 1; j >= 0; j--) {
    node.insertAfter(children[j]);
  }
  node.remove();
  return children.map((child) => child.getLatest());
}
function getTextNodesToMatch(textNode) {
  const textNodesToMatch = [textNode];
  let nextSibling = textNode.getNextSibling();
  while (nextSibling !== null && $isTextNode2(nextSibling) && nextSibling.isSimpleText()) {
    textNodesToMatch.push(nextSibling);
    if (/[\s]/.test(nextSibling.getTextContent())) {
      break;
    }
    nextSibling = nextSibling.getNextSibling();
  }
  return textNodesToMatch;
}
var defaultConfig = {
  changeHandlers: [],
  matchers: []
};
function registerAutoLink(editor, config = defaultConfig) {
  const {
    matchers,
    changeHandlers
  } = config;
  const onChange = (url, prevUrl) => {
    for (const handler of changeHandlers) {
      handler(url, prevUrl);
    }
  };
  return mergeRegister2(editor.registerNodeTransform(TextNode2, (textNode) => {
    const parent = textNode.getParentOrThrow();
    const previous = textNode.getPreviousSibling();
    if ($isAutoLinkNode(parent) && !parent.getIsUnlinked()) {
      handleLinkEdit(parent, matchers, onChange);
    } else if (!$isLinkNode(parent)) {
      if (textNode.isSimpleText() && (startsWithSeparator(textNode.getTextContent()) || !$isAutoLinkNode(previous))) {
        const textNodesToMatch = getTextNodesToMatch(textNode);
        $handleLinkCreation(textNodesToMatch, matchers, onChange);
      }
      handleBadNeighbors(textNode, matchers, onChange);
    }
  }), editor.registerCommand(TOGGLE_LINK_COMMAND, (payload) => {
    const selection = $getSelection2();
    if (payload !== null || !$isRangeSelection2(selection)) {
      return false;
    }
    const nodes = selection.extract();
    nodes.forEach((node) => {
      const parent = node.getParent();
      if ($isAutoLinkNode(parent)) {
        parent.setIsUnlinked(!parent.getIsUnlinked());
        parent.markDirty();
      }
    });
    return false;
  }, COMMAND_PRIORITY_LOW2));
}
var AutoLinkExtension = defineExtension2({
  config: defaultConfig,
  dependencies: [LinkExtension],
  mergeConfig(config, overrides) {
    const merged = shallowMergeConfig2(config, overrides);
    for (const k of ["matchers", "changeHandlers"]) {
      const v2 = overrides[k];
      if (Array.isArray(v2)) {
        merged[k] = [...config[k], ...v2];
      }
    }
    return merged;
  },
  name: "@lexical/link/AutoLink",
  register: registerAutoLink
});
var toggleLink = $toggleLink;

// node_modules/@lexical/link/LexicalLink.mjs
var mod12 = true ? LexicalLink_dev_exports : LexicalLink_prod_exports;
var $createAutoLinkNode2 = mod12.$createAutoLinkNode;
var $createLinkNode2 = mod12.$createLinkNode;
var $isAutoLinkNode2 = mod12.$isAutoLinkNode;
var $isLinkNode2 = mod12.$isLinkNode;
var $toggleLink2 = mod12.$toggleLink;
var AutoLinkExtension2 = mod12.AutoLinkExtension;
var AutoLinkNode2 = mod12.AutoLinkNode;
var ClickableLinkExtension2 = mod12.ClickableLinkExtension;
var LinkExtension2 = mod12.LinkExtension;
var LinkNode2 = mod12.LinkNode;
var TOGGLE_LINK_COMMAND2 = mod12.TOGGLE_LINK_COMMAND;
var createLinkMatcherWithRegExp2 = mod12.createLinkMatcherWithRegExp;
var formatUrl2 = mod12.formatUrl;
var registerAutoLink2 = mod12.registerAutoLink;
var registerClickableLink2 = mod12.registerClickableLink;
var registerLink2 = mod12.registerLink;
var toggleLink2 = mod12.toggleLink;

// node_modules/@lexical/list/LexicalList.dev.mjs
var LexicalList_dev_exports = {};
__export(LexicalList_dev_exports, {
  $createListItemNode: () => $createListItemNode,
  $createListNode: () => $createListNode,
  $getListDepth: () => $getListDepth,
  $handleListInsertParagraph: () => $handleListInsertParagraph,
  $insertList: () => $insertList,
  $isListItemNode: () => $isListItemNode,
  $isListNode: () => $isListNode,
  $removeList: () => $removeList,
  CheckListExtension: () => CheckListExtension,
  INSERT_CHECK_LIST_COMMAND: () => INSERT_CHECK_LIST_COMMAND,
  INSERT_ORDERED_LIST_COMMAND: () => INSERT_ORDERED_LIST_COMMAND,
  INSERT_UNORDERED_LIST_COMMAND: () => INSERT_UNORDERED_LIST_COMMAND,
  ListExtension: () => ListExtension,
  ListItemNode: () => ListItemNode,
  ListNode: () => ListNode,
  REMOVE_LIST_COMMAND: () => REMOVE_LIST_COMMAND,
  UPDATE_LIST_START_COMMAND: () => UPDATE_LIST_START_COMMAND,
  insertList: () => insertList,
  registerCheckList: () => registerCheckList,
  registerList: () => registerList,
  registerListStrictIndentTransform: () => registerListStrictIndentTransform,
  removeList: () => removeList
});
function formatDevErrorMessage9(message) {
  throw new Error(message);
}
function $getListDepth(listNode) {
  let depth = 1;
  let parent = listNode.getParent();
  while (parent != null) {
    if ($isListItemNode(parent)) {
      const parentList = parent.getParent();
      if ($isListNode(parentList)) {
        depth++;
        parent = parentList.getParent();
        continue;
      }
      {
        formatDevErrorMessage9(`A ListItemNode must have a ListNode for a parent.`);
      }
    }
    return depth;
  }
  return depth;
}
function $getTopListNode(listItem) {
  let list = listItem.getParent();
  if (!$isListNode(list)) {
    {
      formatDevErrorMessage9(`A ListItemNode must have a ListNode for a parent.`);
    }
  }
  let parent = list;
  while (parent !== null) {
    parent = parent.getParent();
    if ($isListNode(parent)) {
      list = parent;
    }
  }
  return list;
}
function $getAllListItems(node) {
  let listItemNodes = [];
  const listChildren = node.getChildren().filter($isListItemNode);
  for (let i2 = 0; i2 < listChildren.length; i2++) {
    const listItemNode = listChildren[i2];
    const firstChild = listItemNode.getFirstChild();
    if ($isListNode(firstChild)) {
      listItemNodes = listItemNodes.concat($getAllListItems(firstChild));
    } else {
      listItemNodes.push(listItemNode);
    }
  }
  return listItemNodes;
}
function isNestedListNode(node) {
  return $isListItemNode(node) && $isListNode(node.getFirstChild());
}
function $removeHighestEmptyListParent(sublist) {
  let emptyListPtr = sublist;
  while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {
    const parent = emptyListPtr.getParent();
    if (parent == null || !($isListItemNode(parent) || $isListNode(parent))) {
      break;
    }
    emptyListPtr = parent;
  }
  emptyListPtr.remove();
}
function $wrapInListItem(node) {
  const listItemWrapper = $createListItemNode();
  return listItemWrapper.append(node);
}
function $isSelectingEmptyListItem(anchorNode, nodes) {
  return $isListItemNode(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);
}
function $insertList(listType) {
  const selection = $getSelection2();
  if (selection !== null) {
    let nodes = selection.getNodes();
    if ($isRangeSelection2(selection)) {
      const anchorAndFocus = selection.getStartEndPoints();
      if (!(anchorAndFocus !== null)) {
        formatDevErrorMessage9(`insertList: anchor should be defined`);
      }
      const [anchor] = anchorAndFocus;
      const anchorNode = anchor.getNode();
      const anchorNodeParent = anchorNode.getParent();
      if ($isRootOrShadowRoot2(anchorNode)) {
        const firstChild = anchorNode.getFirstChild();
        if (firstChild) {
          nodes = firstChild.selectStart().getNodes();
        } else {
          const paragraph = $createParagraphNode2();
          anchorNode.append(paragraph);
          nodes = paragraph.select().getNodes();
        }
      } else if ($isSelectingEmptyListItem(anchorNode, nodes)) {
        const list = $createListNode(listType);
        if ($isRootOrShadowRoot2(anchorNodeParent)) {
          anchorNode.replace(list);
          const listItem = $createListItemNode();
          if ($isElementNode2(anchorNode)) {
            listItem.setFormat(anchorNode.getFormatType());
            listItem.setIndent(anchorNode.getIndent());
          }
          list.append(listItem);
        } else if ($isListItemNode(anchorNode)) {
          const parent = anchorNode.getParentOrThrow();
          append(list, parent.getChildren());
          parent.replace(list);
        }
        return;
      }
    }
    const handled = /* @__PURE__ */ new Set();
    for (let i2 = 0; i2 < nodes.length; i2++) {
      const node = nodes[i2];
      if ($isElementNode2(node) && node.isEmpty() && !$isListItemNode(node) && !handled.has(node.getKey())) {
        $createListOrMerge(node, listType);
        continue;
      }
      let parent = $isLeafNode2(node) ? node.getParent() : $isListItemNode(node) && node.isEmpty() ? node : null;
      while (parent != null) {
        const parentKey = parent.getKey();
        if ($isListNode(parent)) {
          if (!handled.has(parentKey)) {
            const newListNode = $createListNode(listType);
            append(newListNode, parent.getChildren());
            parent.replace(newListNode);
            handled.add(parentKey);
          }
          break;
        } else {
          const nextParent = parent.getParent();
          if ($isRootOrShadowRoot2(nextParent) && !handled.has(parentKey)) {
            handled.add(parentKey);
            $createListOrMerge(parent, listType);
            break;
          }
          parent = nextParent;
        }
      }
    }
  }
}
function append(node, nodesToAppend) {
  node.splice(node.getChildrenSize(), 0, nodesToAppend);
}
function $createListOrMerge(node, listType) {
  if ($isListNode(node)) {
    return node;
  }
  const previousSibling = node.getPreviousSibling();
  const nextSibling = node.getNextSibling();
  const listItem = $createListItemNode();
  append(listItem, node.getChildren());
  let targetList;
  if ($isListNode(previousSibling) && listType === previousSibling.getListType()) {
    previousSibling.append(listItem);
    if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {
      append(previousSibling, nextSibling.getChildren());
      nextSibling.remove();
    }
    targetList = previousSibling;
  } else if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {
    nextSibling.getFirstChildOrThrow().insertBefore(listItem);
    targetList = nextSibling;
  } else {
    const list = $createListNode(listType);
    list.append(listItem);
    node.replace(list);
    targetList = list;
  }
  listItem.setFormat(node.getFormatType());
  listItem.setIndent(node.getIndent());
  node.remove();
  return targetList;
}
function mergeLists(list1, list2) {
  const listItem1 = list1.getLastChild();
  const listItem2 = list2.getFirstChild();
  if (listItem1 && listItem2 && isNestedListNode(listItem1) && isNestedListNode(listItem2)) {
    mergeLists(listItem1.getFirstChild(), listItem2.getFirstChild());
    listItem2.remove();
  }
  const toMerge = list2.getChildren();
  if (toMerge.length > 0) {
    list1.append(...toMerge);
  }
  list2.remove();
}
function $removeList() {
  const selection = $getSelection2();
  if ($isRangeSelection2(selection)) {
    const listNodes = /* @__PURE__ */ new Set();
    const nodes = selection.getNodes();
    const anchorNode = selection.anchor.getNode();
    if ($isSelectingEmptyListItem(anchorNode, nodes)) {
      listNodes.add($getTopListNode(anchorNode));
    } else {
      for (let i2 = 0; i2 < nodes.length; i2++) {
        const node = nodes[i2];
        if ($isLeafNode2(node)) {
          const listItemNode = $getNearestNodeOfType2(node, ListItemNode);
          if (listItemNode != null) {
            listNodes.add($getTopListNode(listItemNode));
          }
        }
      }
    }
    for (const listNode of listNodes) {
      let insertionPoint = listNode;
      const listItems = $getAllListItems(listNode);
      for (const listItemNode of listItems) {
        const paragraph = $createParagraphNode2().setTextStyle(selection.style).setTextFormat(selection.format);
        append(paragraph, listItemNode.getChildren());
        insertionPoint.insertAfter(paragraph);
        insertionPoint = paragraph;
        if (listItemNode.__key === selection.anchor.key) {
          $setPointFromCaret2(selection.anchor, $normalizeCaret2($getChildCaret2(paragraph, "next")));
        }
        if (listItemNode.__key === selection.focus.key) {
          $setPointFromCaret2(selection.focus, $normalizeCaret2($getChildCaret2(paragraph, "next")));
        }
        listItemNode.remove();
      }
      listNode.remove();
    }
  }
}
function updateChildrenListItemValue(list) {
  const isNotChecklist = list.getListType() !== "check";
  let value = list.getStart();
  for (const child of list.getChildren()) {
    if ($isListItemNode(child)) {
      if (child.getValue() !== value) {
        child.setValue(value);
      }
      if (isNotChecklist && child.getLatest().__checked != null) {
        child.setChecked(void 0);
      }
      if (!$isListNode(child.getFirstChild())) {
        value++;
      }
    }
  }
}
function mergeNextSiblingListIfSameType(list) {
  const nextSibling = list.getNextSibling();
  if ($isListNode(nextSibling) && list.getListType() === nextSibling.getListType()) {
    mergeLists(list, nextSibling);
  }
}
function $handleIndent(listItemNode) {
  const removed = /* @__PURE__ */ new Set();
  if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {
    return;
  }
  const parent = listItemNode.getParent();
  const nextSibling = listItemNode.getNextSibling();
  const previousSibling = listItemNode.getPreviousSibling();
  if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {
    const innerList = previousSibling.getFirstChild();
    if ($isListNode(innerList)) {
      innerList.append(listItemNode);
      const nextInnerList = nextSibling.getFirstChild();
      if ($isListNode(nextInnerList)) {
        const children = nextInnerList.getChildren();
        append(innerList, children);
        nextSibling.remove();
        removed.add(nextSibling.getKey());
      }
    }
  } else if (isNestedListNode(nextSibling)) {
    const innerList = nextSibling.getFirstChild();
    if ($isListNode(innerList)) {
      const firstChild = innerList.getFirstChild();
      if (firstChild !== null) {
        firstChild.insertBefore(listItemNode);
      }
    }
  } else if (isNestedListNode(previousSibling)) {
    const innerList = previousSibling.getFirstChild();
    if ($isListNode(innerList)) {
      innerList.append(listItemNode);
    }
  } else {
    if ($isListNode(parent)) {
      const newListItem = $createListItemNode().setTextFormat(listItemNode.getTextFormat()).setTextStyle(listItemNode.getTextStyle());
      const newList = $createListNode(parent.getListType()).setTextFormat(parent.getTextFormat()).setTextStyle(parent.getTextStyle());
      newListItem.append(newList);
      newList.append(listItemNode);
      if (previousSibling) {
        previousSibling.insertAfter(newListItem);
      } else if (nextSibling) {
        nextSibling.insertBefore(newListItem);
      } else {
        parent.append(newListItem);
      }
    }
  }
}
function $handleOutdent(listItemNode) {
  if (isNestedListNode(listItemNode)) {
    return;
  }
  const parentList = listItemNode.getParent();
  const grandparentListItem = parentList ? parentList.getParent() : void 0;
  const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : void 0;
  if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {
    const firstChild = parentList ? parentList.getFirstChild() : void 0;
    const lastChild = parentList ? parentList.getLastChild() : void 0;
    if (listItemNode.is(firstChild)) {
      grandparentListItem.insertBefore(listItemNode);
      if (parentList.isEmpty()) {
        grandparentListItem.remove();
      }
    } else if (listItemNode.is(lastChild)) {
      grandparentListItem.insertAfter(listItemNode);
      if (parentList.isEmpty()) {
        grandparentListItem.remove();
      }
    } else {
      const listType = parentList.getListType();
      const previousSiblingsListItem = $createListItemNode();
      const previousSiblingsList = $createListNode(listType);
      previousSiblingsListItem.append(previousSiblingsList);
      listItemNode.getPreviousSiblings().forEach((sibling) => previousSiblingsList.append(sibling));
      const nextSiblingsListItem = $createListItemNode();
      const nextSiblingsList = $createListNode(listType);
      nextSiblingsListItem.append(nextSiblingsList);
      append(nextSiblingsList, listItemNode.getNextSiblings());
      grandparentListItem.insertBefore(previousSiblingsListItem);
      grandparentListItem.insertAfter(nextSiblingsListItem);
      grandparentListItem.replace(listItemNode);
    }
  }
}
function $handleListInsertParagraph() {
  const selection = $getSelection2();
  if (!$isRangeSelection2(selection) || !selection.isCollapsed()) {
    return false;
  }
  const anchor = selection.anchor.getNode();
  if (!$isListItemNode(anchor) || anchor.getChildrenSize() !== 0) {
    return false;
  }
  const topListNode = $getTopListNode(anchor);
  const parent = anchor.getParent();
  if (!$isListNode(parent)) {
    formatDevErrorMessage9(`A ListItemNode must have a ListNode for a parent.`);
  }
  const grandparent = parent.getParent();
  let replacementNode;
  if ($isRootOrShadowRoot2(grandparent)) {
    replacementNode = $createParagraphNode2();
    topListNode.insertAfter(replacementNode);
  } else if ($isListItemNode(grandparent)) {
    replacementNode = $createListItemNode();
    grandparent.insertAfter(replacementNode);
  } else {
    return false;
  }
  replacementNode.setTextStyle(selection.style).setTextFormat(selection.format).select();
  const nextSiblings = anchor.getNextSiblings();
  if (nextSiblings.length > 0) {
    const newList = $createListNode(parent.getListType());
    if ($isListItemNode(replacementNode)) {
      const newListItem = $createListItemNode();
      newListItem.append(newList);
      replacementNode.insertAfter(newListItem);
    } else {
      replacementNode.insertAfter(newList);
    }
    newList.append(...nextSiblings);
  }
  $removeHighestEmptyListParent(anchor);
  return true;
}
function normalizeClassNames3(...classNames) {
  const rval = [];
  for (const className of classNames) {
    if (className && typeof className === "string") {
      for (const [s2] of className.matchAll(/\S+/g)) {
        rval.push(s2);
      }
    }
  }
  return rval;
}
function applyMarkerStyles(dom, node, prevNode) {
  const styles = getStyleObjectFromCSS2(node.__textStyle);
  for (const k in styles) {
    dom.style.setProperty(`--listitem-marker-${k}`, styles[k]);
  }
  if (prevNode) {
    for (const k in getStyleObjectFromCSS2(prevNode.__textStyle)) {
      if (!(k in styles)) {
        dom.style.removeProperty(`--listitem-marker-${k}`);
      }
    }
  }
}
var ListItemNode = class extends ElementNode2 {
  constructor(value = 1, checked = void 0, key) {
    super(key);
    /** @internal */
    __publicField(this, "__value");
    /** @internal */
    __publicField(this, "__checked");
    this.__value = value === void 0 ? 1 : value;
    this.__checked = checked;
  }
  /** @internal */
  $config() {
    return this.config("listitem", {
      $transform: (node) => {
        if (node.__checked == null) {
          return;
        }
        const parent = node.getParent();
        if ($isListNode(parent)) {
          if (parent.getListType() !== "check" && node.getChecked() != null) {
            node.setChecked(void 0);
          }
        }
      },
      extends: ElementNode2,
      importDOM: buildImportMap2({
        li: () => ({
          conversion: $convertListItemElement,
          priority: 0
        })
      })
    });
  }
  afterCloneFrom(prevNode) {
    super.afterCloneFrom(prevNode);
    this.__value = prevNode.__value;
    this.__checked = prevNode.__checked;
  }
  createDOM(config) {
    const element = document.createElement("li");
    this.updateListItemDOM(null, element, config);
    return element;
  }
  updateListItemDOM(prevNode, dom, config) {
    updateListItemChecked(dom, this, prevNode);
    dom.value = this.__value;
    $setListItemThemeClassNames(dom, config.theme, this);
    const prevStyle = prevNode ? prevNode.__style : "";
    const nextStyle = this.__style;
    if (prevStyle !== nextStyle) {
      if (nextStyle === "") {
        dom.removeAttribute("style");
      } else {
        dom.style.cssText = nextStyle;
      }
    }
    applyMarkerStyles(dom, this, prevNode);
  }
  updateDOM(prevNode, dom, config) {
    const element = dom;
    this.updateListItemDOM(prevNode, element, config);
    return false;
  }
  updateFromJSON(serializedNode) {
    return super.updateFromJSON(serializedNode).setValue(serializedNode.value).setChecked(serializedNode.checked);
  }
  exportDOM(editor) {
    const element = this.createDOM(editor._config);
    const formatType = this.getFormatType();
    if (formatType) {
      element.style.textAlign = formatType;
    }
    const direction = this.getDirection();
    if (direction) {
      element.dir = direction;
    }
    return {
      element
    };
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      checked: this.getChecked(),
      value: this.getValue()
    };
  }
  append(...nodes) {
    for (let i2 = 0; i2 < nodes.length; i2++) {
      const node = nodes[i2];
      if ($isElementNode2(node) && this.canMergeWith(node)) {
        const children = node.getChildren();
        this.append(...children);
        node.remove();
      } else {
        super.append(node);
      }
    }
    return this;
  }
  replace(replaceWithNode, includeChildren) {
    if ($isListItemNode(replaceWithNode)) {
      return super.replace(replaceWithNode);
    }
    this.setIndent(0);
    const list = this.getParentOrThrow();
    if (!$isListNode(list)) {
      return replaceWithNode;
    }
    if (list.__first === this.getKey()) {
      list.insertBefore(replaceWithNode);
    } else if (list.__last === this.getKey()) {
      list.insertAfter(replaceWithNode);
    } else {
      const newList = $createListNode(list.getListType());
      let nextSibling = this.getNextSibling();
      while (nextSibling) {
        const nodeToAppend = nextSibling;
        nextSibling = nextSibling.getNextSibling();
        newList.append(nodeToAppend);
      }
      list.insertAfter(replaceWithNode);
      replaceWithNode.insertAfter(newList);
    }
    if (includeChildren) {
      if (!$isElementNode2(replaceWithNode)) {
        formatDevErrorMessage9(`includeChildren should only be true for ElementNodes`);
      }
      this.getChildren().forEach((child) => {
        replaceWithNode.append(child);
      });
    }
    this.remove();
    if (list.getChildrenSize() === 0) {
      list.remove();
    }
    return replaceWithNode;
  }
  insertAfter(node, restoreSelection = true) {
    const listNode = this.getParentOrThrow();
    if (!$isListNode(listNode)) {
      {
        formatDevErrorMessage9(`insertAfter: list node is not parent of list item node`);
      }
    }
    if ($isListItemNode(node)) {
      return super.insertAfter(node, restoreSelection);
    }
    const siblings = this.getNextSiblings();
    listNode.insertAfter(node, restoreSelection);
    if (siblings.length !== 0) {
      const newListNode = $createListNode(listNode.getListType());
      siblings.forEach((sibling) => newListNode.append(sibling));
      node.insertAfter(newListNode, restoreSelection);
    }
    return node;
  }
  remove(preserveEmptyParent) {
    const prevSibling = this.getPreviousSibling();
    const nextSibling = this.getNextSibling();
    super.remove(preserveEmptyParent);
    if (prevSibling && nextSibling && isNestedListNode(prevSibling) && isNestedListNode(nextSibling)) {
      mergeLists(prevSibling.getFirstChild(), nextSibling.getFirstChild());
      nextSibling.remove();
    }
  }
  insertNewAfter(_2, restoreSelection = true) {
    const newElement = $createListItemNode().updateFromJSON(this.exportJSON()).setChecked(this.getChecked() ? false : void 0);
    this.insertAfter(newElement, restoreSelection);
    return newElement;
  }
  collapseAtStart(selection) {
    const paragraph = $createParagraphNode2();
    const children = this.getChildren();
    children.forEach((child) => paragraph.append(child));
    const listNode = this.getParentOrThrow();
    const listNodeParent = listNode.getParentOrThrow();
    const isIndented = $isListItemNode(listNodeParent);
    if (listNode.getChildrenSize() === 1) {
      if (isIndented) {
        listNode.remove();
        listNodeParent.select();
      } else {
        listNode.insertBefore(paragraph);
        listNode.remove();
        const anchor = selection.anchor;
        const focus = selection.focus;
        const key = paragraph.getKey();
        if (anchor.type === "element" && anchor.getNode().is(this)) {
          anchor.set(key, anchor.offset, "element");
        }
        if (focus.type === "element" && focus.getNode().is(this)) {
          focus.set(key, focus.offset, "element");
        }
      }
    } else {
      listNode.insertBefore(paragraph);
      this.remove();
    }
    return true;
  }
  getValue() {
    const self2 = this.getLatest();
    return self2.__value;
  }
  setValue(value) {
    const self2 = this.getWritable();
    self2.__value = value;
    return self2;
  }
  getChecked() {
    const self2 = this.getLatest();
    let listType;
    const parent = this.getParent();
    if ($isListNode(parent)) {
      listType = parent.getListType();
    }
    return listType === "check" ? Boolean(self2.__checked) : void 0;
  }
  setChecked(checked) {
    const self2 = this.getWritable();
    self2.__checked = checked;
    return self2;
  }
  toggleChecked() {
    const self2 = this.getWritable();
    return self2.setChecked(!self2.__checked);
  }
  getIndent() {
    const parent = this.getParent();
    if (parent === null || !this.isAttached()) {
      return this.getLatest().__indent;
    }
    let listNodeParent = parent.getParentOrThrow();
    let indentLevel = 0;
    while ($isListItemNode(listNodeParent)) {
      listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();
      indentLevel++;
    }
    return indentLevel;
  }
  setIndent(indent) {
    if (!(typeof indent === "number")) {
      formatDevErrorMessage9(`Invalid indent value.`);
    }
    indent = Math.floor(indent);
    if (!(indent >= 0)) {
      formatDevErrorMessage9(`Indent value must be non-negative.`);
    }
    let currentIndent = this.getIndent();
    while (currentIndent !== indent) {
      if (currentIndent < indent) {
        $handleIndent(this);
        currentIndent++;
      } else {
        $handleOutdent(this);
        currentIndent--;
      }
    }
    return this;
  }
  /** @deprecated @internal */
  canInsertAfter(node) {
    return $isListItemNode(node);
  }
  /** @deprecated @internal */
  canReplaceWith(replacement) {
    return $isListItemNode(replacement);
  }
  canMergeWith(node) {
    return $isListItemNode(node) || $isParagraphNode2(node);
  }
  extractWithChild(child, selection) {
    if (!$isRangeSelection2(selection)) {
      return false;
    }
    const anchorNode = selection.anchor.getNode();
    const focusNode = selection.focus.getNode();
    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection.getTextContent().length;
  }
  isParentRequired() {
    return true;
  }
  createParentElementNode() {
    return $createListNode("bullet");
  }
  canMergeWhenEmpty() {
    return true;
  }
};
function $setListItemThemeClassNames(dom, editorThemeClasses, node) {
  const classesToAdd = [];
  const classesToRemove = [];
  const listTheme = editorThemeClasses.list;
  const listItemClassName = listTheme ? listTheme.listitem : void 0;
  let nestedListItemClassName;
  if (listTheme && listTheme.nested) {
    nestedListItemClassName = listTheme.nested.listitem;
  }
  if (listItemClassName !== void 0) {
    classesToAdd.push(...normalizeClassNames3(listItemClassName));
  }
  if (listTheme) {
    const parentNode = node.getParent();
    const isCheckList = $isListNode(parentNode) && parentNode.getListType() === "check";
    const checked = node.getChecked();
    if (!isCheckList || checked) {
      classesToRemove.push(listTheme.listitemUnchecked);
    }
    if (!isCheckList || !checked) {
      classesToRemove.push(listTheme.listitemChecked);
    }
    if (isCheckList) {
      classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);
    }
  }
  if (nestedListItemClassName !== void 0) {
    const nestedListItemClasses = normalizeClassNames3(nestedListItemClassName);
    if (node.getChildren().some((child) => $isListNode(child))) {
      classesToAdd.push(...nestedListItemClasses);
    } else {
      classesToRemove.push(...nestedListItemClasses);
    }
  }
  if (classesToRemove.length > 0) {
    removeClassNamesFromElement2(dom, ...classesToRemove);
  }
  if (classesToAdd.length > 0) {
    addClassNamesToElement2(dom, ...classesToAdd);
  }
}
function updateListItemChecked(dom, listItemNode, prevListItemNode) {
  const parent = listItemNode.getParent();
  const isCheckbox = $isListNode(parent) && parent.getListType() === "check" && // Only add attributes for leaf list items
  !$isListNode(listItemNode.getFirstChild());
  if (!isCheckbox) {
    dom.removeAttribute("role");
    dom.removeAttribute("tabIndex");
    dom.removeAttribute("aria-checked");
  } else {
    dom.setAttribute("role", "checkbox");
    dom.setAttribute("tabIndex", "-1");
    if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {
      dom.setAttribute("aria-checked", listItemNode.getChecked() ? "true" : "false");
    }
  }
}
function $convertListItemElement(domNode) {
  const isGitHubCheckList = domNode.classList.contains("task-list-item");
  if (isGitHubCheckList) {
    for (const child of domNode.children) {
      if (child.tagName === "INPUT") {
        return $convertCheckboxInput(child);
      }
    }
  }
  const isJoplinCheckList = domNode.classList.contains("joplin-checkbox");
  if (isJoplinCheckList) {
    for (const child of domNode.children) {
      if (child.classList.contains("checkbox-wrapper") && child.children.length > 0 && child.children[0].tagName === "INPUT") {
        return $convertCheckboxInput(child.children[0]);
      }
    }
  }
  const ariaCheckedAttr = domNode.getAttribute("aria-checked");
  const checked = ariaCheckedAttr === "true" ? true : ariaCheckedAttr === "false" ? false : void 0;
  return {
    node: $createListItemNode(checked)
  };
}
function $convertCheckboxInput(domNode) {
  const isCheckboxInput = domNode.getAttribute("type") === "checkbox";
  if (!isCheckboxInput) {
    return {
      node: null
    };
  }
  const checked = domNode.hasAttribute("checked");
  return {
    node: $createListItemNode(checked)
  };
}
function $createListItemNode(checked) {
  return $applyNodeReplacement2(new ListItemNode(void 0, checked));
}
function $isListItemNode(node) {
  return node instanceof ListItemNode;
}
var ListNode = class extends ElementNode2 {
  constructor(listType = "number", start = 1, key) {
    super(key);
    /** @internal */
    __publicField(this, "__tag");
    /** @internal */
    __publicField(this, "__start");
    /** @internal */
    __publicField(this, "__listType");
    const _listType = TAG_TO_LIST_TYPE[listType] || listType;
    this.__listType = _listType;
    this.__tag = _listType === "number" ? "ol" : "ul";
    this.__start = start;
  }
  /** @internal */
  $config() {
    return this.config("list", {
      $transform: (node) => {
        mergeNextSiblingListIfSameType(node);
        updateChildrenListItemValue(node);
      },
      extends: ElementNode2,
      importDOM: buildImportMap2({
        ol: () => ({
          conversion: $convertListNode,
          priority: 0
        }),
        ul: () => ({
          conversion: $convertListNode,
          priority: 0
        })
      })
    });
  }
  afterCloneFrom(prevNode) {
    super.afterCloneFrom(prevNode);
    this.__listType = prevNode.__listType;
    this.__tag = prevNode.__tag;
    this.__start = prevNode.__start;
  }
  getTag() {
    return this.getLatest().__tag;
  }
  setListType(type) {
    const writable = this.getWritable();
    writable.__listType = type;
    writable.__tag = type === "number" ? "ol" : "ul";
    return writable;
  }
  getListType() {
    return this.getLatest().__listType;
  }
  getStart() {
    return this.getLatest().__start;
  }
  setStart(start) {
    const self2 = this.getWritable();
    self2.__start = start;
    return self2;
  }
  // View
  createDOM(config, _editor) {
    const tag = this.__tag;
    const dom = document.createElement(tag);
    if (this.__start !== 1) {
      dom.setAttribute("start", String(this.__start));
    }
    dom.__lexicalListType = this.__listType;
    $setListThemeClassNames(dom, config.theme, this);
    return dom;
  }
  updateDOM(prevNode, dom, config) {
    if (prevNode.__tag !== this.__tag || prevNode.__listType !== this.__listType) {
      return true;
    }
    $setListThemeClassNames(dom, config.theme, this);
    return false;
  }
  updateFromJSON(serializedNode) {
    return super.updateFromJSON(serializedNode).setListType(serializedNode.listType).setStart(serializedNode.start);
  }
  exportDOM(editor) {
    const element = this.createDOM(editor._config, editor);
    if (isHTMLElement3(element)) {
      if (this.__start !== 1) {
        element.setAttribute("start", String(this.__start));
      }
      if (this.__listType === "check") {
        element.setAttribute("__lexicalListType", "check");
      }
    }
    return {
      element
    };
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      listType: this.getListType(),
      start: this.getStart(),
      tag: this.getTag()
    };
  }
  canBeEmpty() {
    return false;
  }
  canIndent() {
    return false;
  }
  splice(start, deleteCount, nodesToInsert) {
    let listItemNodesToInsert = nodesToInsert;
    for (let i2 = 0; i2 < nodesToInsert.length; i2++) {
      const node = nodesToInsert[i2];
      if (!$isListItemNode(node)) {
        if (listItemNodesToInsert === nodesToInsert) {
          listItemNodesToInsert = [...nodesToInsert];
        }
        listItemNodesToInsert[i2] = $createListItemNode().append($isElementNode2(node) && !($isListNode(node) || node.isInline()) ? $createTextNode2(node.getTextContent()) : node);
      }
    }
    return super.splice(start, deleteCount, listItemNodesToInsert);
  }
  extractWithChild(child) {
    return $isListItemNode(child);
  }
};
function $setListThemeClassNames(dom, editorThemeClasses, node) {
  const classesToAdd = [];
  const classesToRemove = [];
  const listTheme = editorThemeClasses.list;
  if (listTheme !== void 0) {
    const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];
    const listDepth = $getListDepth(node) - 1;
    const normalizedListDepth = listDepth % listLevelsClassNames.length;
    const listLevelClassName = listLevelsClassNames[normalizedListDepth];
    const listClassName = listTheme[node.__tag];
    let nestedListClassName;
    const nestedListTheme = listTheme.nested;
    const checklistClassName = listTheme.checklist;
    if (nestedListTheme !== void 0 && nestedListTheme.list) {
      nestedListClassName = nestedListTheme.list;
    }
    if (listClassName !== void 0) {
      classesToAdd.push(listClassName);
    }
    if (checklistClassName !== void 0 && node.__listType === "check") {
      classesToAdd.push(checklistClassName);
    }
    if (listLevelClassName !== void 0) {
      classesToAdd.push(...normalizeClassNames3(listLevelClassName));
      for (let i2 = 0; i2 < listLevelsClassNames.length; i2++) {
        if (i2 !== normalizedListDepth) {
          classesToRemove.push(node.__tag + i2);
        }
      }
    }
    if (nestedListClassName !== void 0) {
      const nestedListItemClasses = normalizeClassNames3(nestedListClassName);
      if (listDepth > 1) {
        classesToAdd.push(...nestedListItemClasses);
      } else {
        classesToRemove.push(...nestedListItemClasses);
      }
    }
  }
  if (classesToRemove.length > 0) {
    removeClassNamesFromElement2(dom, ...classesToRemove);
  }
  if (classesToAdd.length > 0) {
    addClassNamesToElement2(dom, ...classesToAdd);
  }
}
function $normalizeChildren(nodes) {
  const normalizedListItems = [];
  for (let i2 = 0; i2 < nodes.length; i2++) {
    const node = nodes[i2];
    if ($isListItemNode(node)) {
      normalizedListItems.push(node);
      const children = node.getChildren();
      if (children.length > 1) {
        children.forEach((child) => {
          if ($isListNode(child)) {
            normalizedListItems.push($wrapInListItem(child));
          }
        });
      }
    } else {
      normalizedListItems.push($wrapInListItem(node));
    }
  }
  return normalizedListItems;
}
function isDomChecklist(domNode) {
  if (domNode.getAttribute("__lexicallisttype") === "check" || // is github checklist
  domNode.classList.contains("contains-task-list") || // is joplin checklist
  domNode.getAttribute("data-is-checklist") === "1") {
    return true;
  }
  for (const child of domNode.childNodes) {
    if (isHTMLElement3(child) && child.hasAttribute("aria-checked")) {
      return true;
    }
  }
  return false;
}
function $convertListNode(domNode) {
  const nodeName = domNode.nodeName.toLowerCase();
  let node = null;
  if (nodeName === "ol") {
    const start = domNode.start;
    node = $createListNode("number", start);
  } else if (nodeName === "ul") {
    if (isDomChecklist(domNode)) {
      node = $createListNode("check");
    } else {
      node = $createListNode("bullet");
    }
  }
  return {
    after: $normalizeChildren,
    node
  };
}
var TAG_TO_LIST_TYPE = {
  ol: "number",
  ul: "bullet"
};
function $createListNode(listType = "number", start = 1) {
  return $applyNodeReplacement2(new ListNode(listType, start));
}
function $isListNode(node) {
  return node instanceof ListNode;
}
var INSERT_CHECK_LIST_COMMAND = createCommand2("INSERT_CHECK_LIST_COMMAND");
function registerCheckList(editor) {
  return mergeRegister2(editor.registerCommand(INSERT_CHECK_LIST_COMMAND, () => {
    $insertList("check");
    return true;
  }, COMMAND_PRIORITY_LOW2), editor.registerCommand(KEY_ARROW_DOWN_COMMAND2, (event) => {
    return handleArrowUpOrDown(event, editor, false);
  }, COMMAND_PRIORITY_LOW2), editor.registerCommand(KEY_ARROW_UP_COMMAND2, (event) => {
    return handleArrowUpOrDown(event, editor, true);
  }, COMMAND_PRIORITY_LOW2), editor.registerCommand(KEY_ESCAPE_COMMAND2, () => {
    const activeItem = getActiveCheckListItem();
    if (activeItem != null) {
      const rootElement = editor.getRootElement();
      if (rootElement != null) {
        rootElement.focus();
      }
      return true;
    }
    return false;
  }, COMMAND_PRIORITY_LOW2), editor.registerCommand(KEY_SPACE_COMMAND2, (event) => {
    const activeItem = getActiveCheckListItem();
    if (activeItem != null && editor.isEditable()) {
      editor.update(() => {
        const listItemNode = $getNearestNodeFromDOMNode2(activeItem);
        if ($isListItemNode(listItemNode)) {
          event.preventDefault();
          listItemNode.toggleChecked();
        }
      });
      return true;
    }
    return false;
  }, COMMAND_PRIORITY_LOW2), editor.registerCommand(KEY_ARROW_LEFT_COMMAND2, (event) => {
    return editor.getEditorState().read(() => {
      const selection = $getSelection2();
      if ($isRangeSelection2(selection) && selection.isCollapsed()) {
        const {
          anchor
        } = selection;
        const isElement = anchor.type === "element";
        if (isElement || anchor.offset === 0) {
          const anchorNode = anchor.getNode();
          const elementNode = $findMatchingParent3(anchorNode, (node) => $isElementNode2(node) && !node.isInline());
          if ($isListItemNode(elementNode)) {
            const parent = elementNode.getParent();
            if ($isListNode(parent) && parent.getListType() === "check" && (isElement || elementNode.getFirstDescendant() === anchorNode)) {
              const domNode = editor.getElementByKey(elementNode.__key);
              if (domNode != null && document.activeElement !== domNode) {
                domNode.focus();
                event.preventDefault();
                return true;
              }
            }
          }
        }
      }
      return false;
    });
  }, COMMAND_PRIORITY_LOW2), editor.registerRootListener((rootElement, prevElement) => {
    if (rootElement !== null) {
      rootElement.addEventListener("click", handleClick);
      rootElement.addEventListener("pointerdown", handlePointerDown);
    }
    if (prevElement !== null) {
      prevElement.removeEventListener("click", handleClick);
      prevElement.removeEventListener("pointerdown", handlePointerDown);
    }
  }));
}
function handleCheckItemEvent(event, callback) {
  const target = event.target;
  if (!isHTMLElement3(target)) {
    return;
  }
  const firstChild = target.firstChild;
  if (isHTMLElement3(firstChild) && (firstChild.tagName === "UL" || firstChild.tagName === "OL")) {
    return;
  }
  const parentNode = target.parentNode;
  if (!parentNode || parentNode.__lexicalListType !== "check") {
    return;
  }
  const rect = target.getBoundingClientRect();
  const zoom = calculateZoomLevel2(target);
  const clientX = event.clientX / zoom;
  const beforeStyles = window.getComputedStyle ? window.getComputedStyle(target, "::before") : {
    width: "0px"
  };
  const beforeWidthInPixels = parseFloat(beforeStyles.width);
  const isTouchEvent = event.pointerType === "touch";
  const clickAreaPadding = isTouchEvent ? 32 : 0;
  if (target.dir === "rtl" ? clientX < rect.right + clickAreaPadding && clientX > rect.right - beforeWidthInPixels - clickAreaPadding : clientX > rect.left - clickAreaPadding && clientX < rect.left + beforeWidthInPixels + clickAreaPadding) {
    callback();
  }
}
function handleClick(event) {
  handleCheckItemEvent(event, () => {
    if (isHTMLElement3(event.target)) {
      const domNode = event.target;
      const editor = getNearestEditorFromDOMNode2(domNode);
      if (editor != null && editor.isEditable()) {
        editor.update(() => {
          const node = $getNearestNodeFromDOMNode2(domNode);
          if ($isListItemNode(node)) {
            domNode.focus();
            node.toggleChecked();
          }
        });
      }
    }
  });
}
function handlePointerDown(event) {
  handleCheckItemEvent(event, () => {
    event.preventDefault();
  });
}
function getActiveCheckListItem() {
  const activeElement = document.activeElement;
  return isHTMLElement3(activeElement) && activeElement.tagName === "LI" && activeElement.parentNode != null && // @ts-ignore internal field
  activeElement.parentNode.__lexicalListType === "check" ? activeElement : null;
}
function findCheckListItemSibling(node, backward) {
  let sibling = backward ? node.getPreviousSibling() : node.getNextSibling();
  let parent = node;
  while (sibling == null && $isListItemNode(parent)) {
    parent = parent.getParentOrThrow().getParent();
    if (parent != null) {
      sibling = backward ? parent.getPreviousSibling() : parent.getNextSibling();
    }
  }
  while ($isListItemNode(sibling)) {
    const firstChild = backward ? sibling.getLastChild() : sibling.getFirstChild();
    if (!$isListNode(firstChild)) {
      return sibling;
    }
    sibling = backward ? firstChild.getLastChild() : firstChild.getFirstChild();
  }
  return null;
}
function handleArrowUpOrDown(event, editor, backward) {
  const activeItem = getActiveCheckListItem();
  if (activeItem != null) {
    editor.update(() => {
      const listItem = $getNearestNodeFromDOMNode2(activeItem);
      if (!$isListItemNode(listItem)) {
        return;
      }
      const nextListItem = findCheckListItemSibling(listItem, backward);
      if (nextListItem != null) {
        nextListItem.selectStart();
        const dom = editor.getElementByKey(nextListItem.__key);
        if (dom != null) {
          event.preventDefault();
          setTimeout(() => {
            dom.focus();
          }, 0);
        }
      }
    });
  }
  return false;
}
var UPDATE_LIST_START_COMMAND = createCommand2("UPDATE_LIST_START_COMMAND");
var INSERT_UNORDERED_LIST_COMMAND = createCommand2("INSERT_UNORDERED_LIST_COMMAND");
var INSERT_ORDERED_LIST_COMMAND = createCommand2("INSERT_ORDERED_LIST_COMMAND");
var REMOVE_LIST_COMMAND = createCommand2("REMOVE_LIST_COMMAND");
function registerList(editor) {
  const removeListener = mergeRegister2(editor.registerCommand(INSERT_ORDERED_LIST_COMMAND, () => {
    $insertList("number");
    return true;
  }, COMMAND_PRIORITY_LOW2), editor.registerCommand(UPDATE_LIST_START_COMMAND, (payload) => {
    const {
      listNodeKey,
      newStart
    } = payload;
    const listNode = $getNodeByKey2(listNodeKey);
    if (!$isListNode(listNode)) {
      return false;
    }
    if (listNode.getListType() === "number") {
      listNode.setStart(newStart);
      updateChildrenListItemValue(listNode);
    }
    return true;
  }, COMMAND_PRIORITY_LOW2), editor.registerCommand(INSERT_UNORDERED_LIST_COMMAND, () => {
    $insertList("bullet");
    return true;
  }, COMMAND_PRIORITY_LOW2), editor.registerCommand(REMOVE_LIST_COMMAND, () => {
    $removeList();
    return true;
  }, COMMAND_PRIORITY_LOW2), editor.registerCommand(INSERT_PARAGRAPH_COMMAND2, () => $handleListInsertParagraph(), COMMAND_PRIORITY_LOW2), editor.registerNodeTransform(ListItemNode, (node) => {
    const firstChild = node.getFirstChild();
    if (firstChild) {
      if ($isTextNode2(firstChild)) {
        const style = firstChild.getStyle();
        const format = firstChild.getFormat();
        if (node.getTextStyle() !== style) {
          node.setTextStyle(style);
        }
        if (node.getTextFormat() !== format) {
          node.setTextFormat(format);
        }
      }
    } else {
      const selection = $getSelection2();
      if ($isRangeSelection2(selection) && (selection.style !== node.getTextStyle() || selection.format !== node.getTextFormat()) && selection.isCollapsed() && node.is(selection.anchor.getNode())) {
        node.setTextStyle(selection.style).setTextFormat(selection.format);
      }
    }
  }), editor.registerNodeTransform(TextNode2, (node) => {
    const listItemParentNode = node.getParent();
    if ($isListItemNode(listItemParentNode) && node.is(listItemParentNode.getFirstChild())) {
      const style = node.getStyle();
      const format = node.getFormat();
      if (style !== listItemParentNode.getTextStyle() || format !== listItemParentNode.getTextFormat()) {
        listItemParentNode.setTextStyle(style).setTextFormat(format);
      }
    }
  }));
  return removeListener;
}
function registerListStrictIndentTransform(editor) {
  const $formatListIndentStrict = (listItemNode) => {
    const listNode = listItemNode.getParent();
    if ($isListNode(listItemNode.getFirstChild()) || !$isListNode(listNode)) {
      return;
    }
    const startingListItemNode = $findMatchingParent3(listItemNode, (node) => $isListItemNode(node) && $isListNode(node.getParent()) && $isListItemNode(node.getPreviousSibling()));
    if (startingListItemNode === null && listItemNode.getIndent() > 0) {
      listItemNode.setIndent(0);
    } else if ($isListItemNode(startingListItemNode)) {
      const prevListItemNode = startingListItemNode.getPreviousSibling();
      if ($isListItemNode(prevListItemNode)) {
        const endListItemNode = $findChildrenEndListItemNode(prevListItemNode);
        const endListNode = endListItemNode.getParent();
        if ($isListNode(endListNode)) {
          const prevDepth = $getListDepth(endListNode);
          const depth = $getListDepth(listNode);
          if (prevDepth + 1 < depth) {
            listItemNode.setIndent(prevDepth);
          }
        }
      }
    }
  };
  const $processListWithStrictIndent = (listNode) => {
    const queue = [listNode];
    while (queue.length > 0) {
      const node = queue.shift();
      if (!$isListNode(node)) {
        continue;
      }
      for (const child of node.getChildren()) {
        if ($isListItemNode(child)) {
          $formatListIndentStrict(child);
          const firstChild = child.getFirstChild();
          if ($isListNode(firstChild)) {
            queue.push(firstChild);
          }
        }
      }
    }
  };
  return editor.registerNodeTransform(ListNode, $processListWithStrictIndent);
}
function $findChildrenEndListItemNode(listItemNode) {
  let current = listItemNode;
  let firstChild = current.getFirstChild();
  while ($isListNode(firstChild)) {
    const lastChild = firstChild.getLastChild();
    if ($isListItemNode(lastChild)) {
      current = lastChild;
      firstChild = current.getFirstChild();
    } else {
      break;
    }
  }
  return current;
}
function insertList(editor, listType) {
  editor.update(() => $insertList(listType));
}
function removeList(editor) {
  editor.update(() => $removeList());
}
var ListExtension = defineExtension2({
  build(editor, config, state) {
    return namedSignals2(config);
  },
  config: safeCast2({
    hasStrictIndent: false
  }),
  name: "@lexical/list/List",
  nodes: () => [ListNode, ListItemNode],
  register(editor, config, state) {
    const stores = state.getOutput();
    return mergeRegister2(registerList(editor), effect(() => stores.hasStrictIndent.value ? registerListStrictIndentTransform(editor) : void 0));
  }
});
var CheckListExtension = defineExtension2({
  dependencies: [ListExtension],
  name: "@lexical/list/CheckList",
  register: registerCheckList
});

// node_modules/@lexical/list/LexicalList.mjs
var mod13 = true ? LexicalList_dev_exports : LexicalList_prod_exports;
var $createListItemNode2 = mod13.$createListItemNode;
var $createListNode2 = mod13.$createListNode;
var $getListDepth2 = mod13.$getListDepth;
var $handleListInsertParagraph2 = mod13.$handleListInsertParagraph;
var $insertList2 = mod13.$insertList;
var $isListItemNode2 = mod13.$isListItemNode;
var $isListNode2 = mod13.$isListNode;
var $removeList2 = mod13.$removeList;
var CheckListExtension2 = mod13.CheckListExtension;
var INSERT_CHECK_LIST_COMMAND2 = mod13.INSERT_CHECK_LIST_COMMAND;
var INSERT_ORDERED_LIST_COMMAND2 = mod13.INSERT_ORDERED_LIST_COMMAND;
var INSERT_UNORDERED_LIST_COMMAND2 = mod13.INSERT_UNORDERED_LIST_COMMAND;
var ListExtension2 = mod13.ListExtension;
var ListItemNode2 = mod13.ListItemNode;
var ListNode2 = mod13.ListNode;
var REMOVE_LIST_COMMAND2 = mod13.REMOVE_LIST_COMMAND;
var UPDATE_LIST_START_COMMAND2 = mod13.UPDATE_LIST_START_COMMAND;
var insertList2 = mod13.insertList;
var registerCheckList2 = mod13.registerCheckList;
var registerList2 = mod13.registerList;
var registerListStrictIndentTransform2 = mod13.registerListStrictIndentTransform;
var removeList2 = mod13.removeList;

// node_modules/@lexical/history/LexicalHistory.dev.mjs
var LexicalHistory_dev_exports = {};
__export(LexicalHistory_dev_exports, {
  HistoryExtension: () => HistoryExtension,
  SharedHistoryExtension: () => SharedHistoryExtension,
  createEmptyHistoryState: () => createEmptyHistoryState,
  registerHistory: () => registerHistory
});
var HISTORY_MERGE = 0;
var HISTORY_PUSH = 1;
var DISCARD_HISTORY_CANDIDATE = 2;
var OTHER = 0;
var COMPOSING_CHARACTER = 1;
var INSERT_CHARACTER_AFTER_SELECTION = 2;
var DELETE_CHARACTER_BEFORE_SELECTION = 3;
var DELETE_CHARACTER_AFTER_SELECTION = 4;
function getDirtyNodes(editorState, dirtyLeaves, dirtyElements) {
  const nodeMap = editorState._nodeMap;
  const nodes = [];
  for (const dirtyLeafKey of dirtyLeaves) {
    const dirtyLeaf = nodeMap.get(dirtyLeafKey);
    if (dirtyLeaf !== void 0) {
      nodes.push(dirtyLeaf);
    }
  }
  for (const [dirtyElementKey, intentionallyMarkedAsDirty] of dirtyElements) {
    if (!intentionallyMarkedAsDirty) {
      continue;
    }
    const dirtyElement = nodeMap.get(dirtyElementKey);
    if (dirtyElement !== void 0 && !$isRootNode2(dirtyElement)) {
      nodes.push(dirtyElement);
    }
  }
  return nodes;
}
function getChangeType(prevEditorState, nextEditorState, dirtyLeavesSet, dirtyElementsSet, isComposing) {
  if (prevEditorState === null || dirtyLeavesSet.size === 0 && dirtyElementsSet.size === 0 && !isComposing) {
    return OTHER;
  }
  const nextSelection = nextEditorState._selection;
  const prevSelection = prevEditorState._selection;
  if (isComposing) {
    return COMPOSING_CHARACTER;
  }
  if (!$isRangeSelection2(nextSelection) || !$isRangeSelection2(prevSelection) || !prevSelection.isCollapsed() || !nextSelection.isCollapsed()) {
    return OTHER;
  }
  const dirtyNodes = getDirtyNodes(nextEditorState, dirtyLeavesSet, dirtyElementsSet);
  if (dirtyNodes.length === 0) {
    return OTHER;
  }
  if (dirtyNodes.length > 1) {
    const nextNodeMap = nextEditorState._nodeMap;
    const nextAnchorNode = nextNodeMap.get(nextSelection.anchor.key);
    const prevAnchorNode = nextNodeMap.get(prevSelection.anchor.key);
    if (nextAnchorNode && prevAnchorNode && !prevEditorState._nodeMap.has(nextAnchorNode.__key) && $isTextNode2(nextAnchorNode) && nextAnchorNode.__text.length === 1 && nextSelection.anchor.offset === 1) {
      return INSERT_CHARACTER_AFTER_SELECTION;
    }
    return OTHER;
  }
  const nextDirtyNode = dirtyNodes[0];
  const prevDirtyNode = prevEditorState._nodeMap.get(nextDirtyNode.__key);
  if (!$isTextNode2(prevDirtyNode) || !$isTextNode2(nextDirtyNode) || prevDirtyNode.__mode !== nextDirtyNode.__mode) {
    return OTHER;
  }
  const prevText = prevDirtyNode.__text;
  const nextText = nextDirtyNode.__text;
  if (prevText === nextText) {
    return OTHER;
  }
  const nextAnchor = nextSelection.anchor;
  const prevAnchor = prevSelection.anchor;
  if (nextAnchor.key !== prevAnchor.key || nextAnchor.type !== "text") {
    return OTHER;
  }
  const nextAnchorOffset = nextAnchor.offset;
  const prevAnchorOffset = prevAnchor.offset;
  const textDiff = nextText.length - prevText.length;
  if (textDiff === 1 && prevAnchorOffset === nextAnchorOffset - 1) {
    return INSERT_CHARACTER_AFTER_SELECTION;
  }
  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset + 1) {
    return DELETE_CHARACTER_BEFORE_SELECTION;
  }
  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset) {
    return DELETE_CHARACTER_AFTER_SELECTION;
  }
  return OTHER;
}
function isTextNodeUnchanged(key, prevEditorState, nextEditorState) {
  const prevNode = prevEditorState._nodeMap.get(key);
  const nextNode = nextEditorState._nodeMap.get(key);
  const prevSelection = prevEditorState._selection;
  const nextSelection = nextEditorState._selection;
  const isDeletingLine = $isRangeSelection2(prevSelection) && $isRangeSelection2(nextSelection) && prevSelection.anchor.type === "element" && prevSelection.focus.type === "element" && nextSelection.anchor.type === "text" && nextSelection.focus.type === "text";
  if (!isDeletingLine && $isTextNode2(prevNode) && $isTextNode2(nextNode) && prevNode.__parent === nextNode.__parent) {
    return JSON.stringify(prevEditorState.read(() => prevNode.exportJSON())) === JSON.stringify(nextEditorState.read(() => nextNode.exportJSON()));
  }
  return false;
}
function createMergeActionGetter(editor, delayOrStore) {
  let prevChangeTime = Date.now();
  let prevChangeType = OTHER;
  return (prevEditorState, nextEditorState, currentHistoryEntry, dirtyLeaves, dirtyElements, tags) => {
    const changeTime = Date.now();
    if (tags.has(HISTORIC_TAG2)) {
      prevChangeType = OTHER;
      prevChangeTime = changeTime;
      return DISCARD_HISTORY_CANDIDATE;
    }
    const changeType = getChangeType(prevEditorState, nextEditorState, dirtyLeaves, dirtyElements, editor.isComposing());
    const mergeAction = (() => {
      const isSameEditor = currentHistoryEntry === null || currentHistoryEntry.editor === editor;
      const shouldPushHistory = tags.has(HISTORY_PUSH_TAG2);
      const shouldMergeHistory = !shouldPushHistory && isSameEditor && tags.has(HISTORY_MERGE_TAG2);
      if (shouldMergeHistory) {
        return HISTORY_MERGE;
      }
      if (prevEditorState === null) {
        return HISTORY_PUSH;
      }
      const selection = nextEditorState._selection;
      const hasDirtyNodes = dirtyLeaves.size > 0 || dirtyElements.size > 0;
      if (!hasDirtyNodes) {
        if (selection !== null) {
          return HISTORY_MERGE;
        }
        return DISCARD_HISTORY_CANDIDATE;
      }
      const delay = typeof delayOrStore === "number" ? delayOrStore : delayOrStore.peek();
      if (shouldPushHistory === false && changeType !== OTHER && changeType === prevChangeType && changeTime < prevChangeTime + delay && isSameEditor) {
        return HISTORY_MERGE;
      }
      if (dirtyLeaves.size === 1) {
        const dirtyLeafKey = Array.from(dirtyLeaves)[0];
        if (isTextNodeUnchanged(dirtyLeafKey, prevEditorState, nextEditorState)) {
          return HISTORY_MERGE;
        }
      }
      return HISTORY_PUSH;
    })();
    prevChangeTime = changeTime;
    prevChangeType = changeType;
    return mergeAction;
  };
}
function redo(editor, historyState) {
  const redoStack = historyState.redoStack;
  const undoStack = historyState.undoStack;
  if (redoStack.length !== 0) {
    const current = historyState.current;
    if (current !== null) {
      undoStack.push(current);
      editor.dispatchCommand(CAN_UNDO_COMMAND2, true);
    }
    const historyStateEntry = redoStack.pop();
    if (redoStack.length === 0) {
      editor.dispatchCommand(CAN_REDO_COMMAND2, false);
    }
    historyState.current = historyStateEntry || null;
    if (historyStateEntry) {
      historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {
        tag: HISTORIC_TAG2
      });
    }
  }
}
function undo(editor, historyState) {
  const redoStack = historyState.redoStack;
  const undoStack = historyState.undoStack;
  const undoStackLength = undoStack.length;
  if (undoStackLength !== 0) {
    const current = historyState.current;
    const historyStateEntry = undoStack.pop();
    if (current !== null) {
      redoStack.push(current);
      editor.dispatchCommand(CAN_REDO_COMMAND2, true);
    }
    if (undoStack.length === 0) {
      editor.dispatchCommand(CAN_UNDO_COMMAND2, false);
    }
    historyState.current = historyStateEntry || null;
    if (historyStateEntry) {
      historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {
        tag: HISTORIC_TAG2
      });
    }
  }
}
function clearHistory(historyState) {
  historyState.undoStack = [];
  historyState.redoStack = [];
  historyState.current = null;
}
function registerHistory(editor, historyState, delay) {
  const getMergeAction = createMergeActionGetter(editor, delay);
  const applyChange = ({
    editorState,
    prevEditorState,
    dirtyLeaves,
    dirtyElements,
    tags
  }) => {
    const current = historyState.current;
    const redoStack = historyState.redoStack;
    const undoStack = historyState.undoStack;
    const currentEditorState = current === null ? null : current.editorState;
    if (current !== null && editorState === currentEditorState) {
      return;
    }
    const mergeAction = getMergeAction(prevEditorState, editorState, current, dirtyLeaves, dirtyElements, tags);
    if (mergeAction === HISTORY_PUSH) {
      if (redoStack.length !== 0) {
        historyState.redoStack = [];
        editor.dispatchCommand(CAN_REDO_COMMAND2, false);
      }
      if (current !== null) {
        undoStack.push({
          ...current
        });
        editor.dispatchCommand(CAN_UNDO_COMMAND2, true);
      }
    } else if (mergeAction === DISCARD_HISTORY_CANDIDATE) {
      return;
    }
    historyState.current = {
      editor,
      editorState
    };
  };
  const unregister = mergeRegister2(editor.registerCommand(UNDO_COMMAND2, () => {
    undo(editor, historyState);
    return true;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(REDO_COMMAND2, () => {
    redo(editor, historyState);
    return true;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(CLEAR_EDITOR_COMMAND2, () => {
    clearHistory(historyState);
    return false;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(CLEAR_HISTORY_COMMAND2, () => {
    clearHistory(historyState);
    editor.dispatchCommand(CAN_REDO_COMMAND2, false);
    editor.dispatchCommand(CAN_UNDO_COMMAND2, false);
    return true;
  }, COMMAND_PRIORITY_EDITOR2), editor.registerUpdateListener(applyChange));
  return unregister;
}
function createEmptyHistoryState() {
  return {
    current: null,
    redoStack: [],
    undoStack: []
  };
}
var HistoryExtension = defineExtension2({
  build: (editor, {
    delay,
    createInitialHistoryState,
    disabled
  }) => namedSignals2({
    delay,
    disabled,
    historyState: createInitialHistoryState(editor)
  }),
  config: safeCast2({
    createInitialHistoryState: createEmptyHistoryState,
    delay: 300,
    disabled: typeof window === "undefined"
  }),
  name: "@lexical/history/History",
  register: (editor, config, state) => {
    const stores = state.getOutput();
    return effect(() => stores.disabled.value ? void 0 : registerHistory(editor, stores.historyState.value, stores.delay));
  }
});
function getHistoryPeer(editor) {
  return editor ? getPeerDependencyFromEditor2(editor, HistoryExtension.name) : null;
}
var SharedHistoryExtension = defineExtension2({
  dependencies: [configExtension2(HistoryExtension, {
    createInitialHistoryState: () => {
      throw new Error("SharedHistory did not inherit parent history");
    },
    disabled: true
  })],
  name: "@lexical/history/SharedHistory",
  register(editor, _config, state) {
    const {
      output
    } = state.getDependency(HistoryExtension);
    const parentPeer = getHistoryPeer(editor._parentEditor);
    if (!parentPeer) {
      return () => {
      };
    }
    const parentOutput = parentPeer.output;
    return effect(() => batch(() => {
      output.delay.value = parentOutput.delay.value;
      output.historyState.value = parentOutput.historyState.value;
      output.disabled.value = parentOutput.disabled.value;
    }));
  }
});

// node_modules/@lexical/history/LexicalHistory.mjs
var mod14 = true ? LexicalHistory_dev_exports : LexicalHistory_prod_exports;
var HistoryExtension2 = mod14.HistoryExtension;
var SharedHistoryExtension2 = mod14.SharedHistoryExtension;
var createEmptyHistoryState2 = mod14.createEmptyHistoryState;
var registerHistory2 = mod14.registerHistory;

// node_modules/@melloware/coloris/dist/esm/coloris.js
var Coloris = (() => {
  return ((window2, document2, Math2, undefined2) => {
    const ctx = document2.createElement("canvas").getContext("2d");
    const currentColor = { r: 0, g: 0, b: 0, h: 0, s: 0, v: 0, a: 1 };
    let container, picker, colorArea, colorMarker, colorPreview, colorValue, clearButton, closeButton, hueSlider, hueMarker, alphaSlider, alphaMarker, currentEl, currentFormat, oldColor, keyboardNav, colorAreaDims = {};
    const settings = {
      el: "[data-coloris]",
      parent: "body",
      theme: "default",
      themeMode: "light",
      rtl: false,
      wrap: true,
      margin: 2,
      format: "hex",
      formatToggle: false,
      swatches: [],
      swatchesOnly: false,
      alpha: true,
      forceAlpha: false,
      focusInput: true,
      selectInput: false,
      inline: false,
      defaultColor: "#000000",
      clearButton: false,
      clearLabel: "Clear",
      closeButton: false,
      closeLabel: "Close",
      onChange: () => undefined2,
      a11y: {
        open: "Open color picker",
        close: "Close color picker",
        clear: "Clear the selected color",
        marker: "Saturation: {s}. Brightness: {v}.",
        hueSlider: "Hue slider",
        alphaSlider: "Opacity slider",
        input: "Color value field",
        format: "Color format",
        swatch: "Color swatch",
        instruction: "Saturation and brightness selector. Use up, down, left and right arrow keys to select."
      }
    };
    const instances = {};
    let currentInstanceId = "";
    let defaultInstance = {};
    let hasInstance = false;
    function configure(options) {
      if (typeof options !== "object") {
        return;
      }
      for (const key in options) {
        switch (key) {
          case "el":
            bindFields(options.el);
            if (options.wrap !== false) {
              wrapFields(options.el);
            }
            break;
          case "parent":
            container = options.parent instanceof HTMLElement ? options.parent : document2.querySelector(options.parent);
            if (container) {
              container.appendChild(picker);
              settings.parent = options.parent;
              if (container === document2.body) {
                container = undefined2;
              }
            }
            break;
          case "themeMode":
            settings.themeMode = options.themeMode;
            if (options.themeMode === "auto" && window2.matchMedia && window2.matchMedia("(prefers-color-scheme: dark)").matches) {
              settings.themeMode = "dark";
            }
          // The lack of a break statement is intentional
          case "theme":
            if (options.theme) {
              settings.theme = options.theme;
            }
            picker.className = `clr-picker clr-${settings.theme} clr-${settings.themeMode}`;
            if (settings.inline) {
              updatePickerPosition();
            }
            break;
          case "rtl":
            settings.rtl = !!options.rtl;
            Array.from(document2.getElementsByClassName("clr-field")).forEach((field) => field.classList.toggle("clr-rtl", settings.rtl));
            break;
          case "margin":
            options.margin *= 1;
            settings.margin = !isNaN(options.margin) ? options.margin : settings.margin;
            break;
          case "wrap":
            if (options.el && options.wrap) {
              wrapFields(options.el);
            }
            break;
          case "formatToggle":
            settings.formatToggle = !!options.formatToggle;
            getEl("clr-format").style.display = settings.formatToggle ? "block" : "none";
            if (settings.formatToggle) {
              settings.format = "auto";
            }
            break;
          case "swatches":
            if (Array.isArray(options.swatches)) {
              const swatchesContainer = getEl("clr-swatches");
              const swatches = document2.createElement("div");
              swatchesContainer.textContent = "";
              options.swatches.forEach((swatch, i2) => {
                const button = document2.createElement("button");
                button.setAttribute("type", `button`);
                button.setAttribute("id", `clr-swatch-${i2}`);
                button.setAttribute("aria-labelledby", `clr-swatch-label clr-swatch-${i2}`);
                button.style.color = swatch;
                button.textContent = swatch;
                swatches.appendChild(button);
              });
              if (options.swatches.length) {
                swatchesContainer.appendChild(swatches);
              }
              settings.swatches = options.swatches.slice();
            }
            break;
          case "swatchesOnly":
            settings.swatchesOnly = !!options.swatchesOnly;
            picker.setAttribute("data-minimal", settings.swatchesOnly);
            break;
          case "alpha":
            settings.alpha = !!options.alpha;
            picker.setAttribute("data-alpha", settings.alpha);
            break;
          case "inline":
            settings.inline = !!options.inline;
            picker.setAttribute("data-inline", settings.inline);
            if (settings.inline) {
              const defaultColor = options.defaultColor || settings.defaultColor;
              currentFormat = getColorFormatFromStr(defaultColor);
              updatePickerPosition();
              setColorFromStr(defaultColor);
            }
            break;
          case "clearButton":
            if (typeof options.clearButton === "object") {
              if (options.clearButton.label) {
                settings.clearLabel = options.clearButton.label;
                clearButton.innerHTML = settings.clearLabel;
              }
              options.clearButton = options.clearButton.show;
            }
            settings.clearButton = !!options.clearButton;
            clearButton.style.display = settings.clearButton ? "block" : "none";
            break;
          case "clearLabel":
            settings.clearLabel = options.clearLabel;
            clearButton.innerHTML = settings.clearLabel;
            break;
          case "closeButton":
            settings.closeButton = !!options.closeButton;
            if (settings.closeButton) {
              picker.insertBefore(closeButton, colorPreview);
            } else {
              colorPreview.appendChild(closeButton);
            }
            break;
          case "closeLabel":
            settings.closeLabel = options.closeLabel;
            closeButton.innerHTML = settings.closeLabel;
            break;
          case "a11y":
            const labels = options.a11y;
            let update = false;
            if (typeof labels === "object") {
              for (const label in labels) {
                if (labels[label] && settings.a11y[label]) {
                  settings.a11y[label] = labels[label];
                  update = true;
                }
              }
            }
            if (update) {
              const openLabel = getEl("clr-open-label");
              const swatchLabel = getEl("clr-swatch-label");
              openLabel.innerHTML = settings.a11y.open;
              swatchLabel.innerHTML = settings.a11y.swatch;
              closeButton.setAttribute("aria-label", settings.a11y.close);
              clearButton.setAttribute("aria-label", settings.a11y.clear);
              hueSlider.setAttribute("aria-label", settings.a11y.hueSlider);
              alphaSlider.setAttribute("aria-label", settings.a11y.alphaSlider);
              colorValue.setAttribute("aria-label", settings.a11y.input);
              colorArea.setAttribute("aria-label", settings.a11y.instruction);
            }
            break;
          default:
            settings[key] = options[key];
        }
      }
    }
    function setVirtualInstance(selector, options) {
      if (typeof selector === "string" && typeof options === "object") {
        instances[selector] = options;
        hasInstance = true;
      }
    }
    function removeVirtualInstance(selector) {
      delete instances[selector];
      if (Object.keys(instances).length === 0) {
        hasInstance = false;
        if (selector === currentInstanceId) {
          resetVirtualInstance();
        }
      }
    }
    function attachVirtualInstance(element) {
      if (hasInstance) {
        const unsupportedOptions = ["el", "wrap", "rtl", "inline", "defaultColor", "a11y"];
        for (let selector in instances) {
          const options = instances[selector];
          if (element.matches(selector)) {
            currentInstanceId = selector;
            defaultInstance = {};
            unsupportedOptions.forEach((option) => delete options[option]);
            for (let option in options) {
              defaultInstance[option] = Array.isArray(settings[option]) ? settings[option].slice() : settings[option];
            }
            configure(options);
            break;
          }
        }
      }
    }
    function resetVirtualInstance() {
      if (Object.keys(defaultInstance).length > 0) {
        configure(defaultInstance);
        currentInstanceId = "";
        defaultInstance = {};
      }
    }
    function bindFields(selector) {
      if (selector instanceof HTMLElement) {
        selector = [selector];
      }
      if (Array.isArray(selector)) {
        selector.forEach((field) => {
          addListener(field, "click", openPicker);
          addListener(field, "input", updateColorPreview);
        });
      } else {
        addListener(document2, "click", selector, openPicker);
        addListener(document2, "input", selector, updateColorPreview);
      }
    }
    function openPicker(event) {
      if (settings.inline) {
        return;
      }
      attachVirtualInstance(event.target);
      currentEl = event.target;
      oldColor = currentEl.value;
      currentFormat = getColorFormatFromStr(oldColor);
      picker.classList.add("clr-open");
      updatePickerPosition();
      setColorFromStr(oldColor);
      if (settings.focusInput || settings.selectInput) {
        colorValue.focus({ preventScroll: true });
        colorValue.setSelectionRange(currentEl.selectionStart, currentEl.selectionEnd);
      }
      if (settings.selectInput) {
        colorValue.select();
      }
      if (keyboardNav || settings.swatchesOnly) {
        getFocusableElements().shift().focus();
      }
      currentEl.dispatchEvent(new Event("open", { bubbles: true }));
    }
    function updatePickerPosition() {
      if (!picker || !currentEl && !settings.inline) return;
      const parent = container;
      const scrollY = window2.scrollY;
      const pickerWidth = picker.offsetWidth;
      const pickerHeight = picker.offsetHeight;
      const reposition = { left: false, top: false };
      let parentStyle, parentMarginTop, parentBorderTop;
      let offset = { x: 0, y: 0 };
      if (parent) {
        parentStyle = window2.getComputedStyle(parent);
        parentMarginTop = parseFloat(parentStyle.marginTop);
        parentBorderTop = parseFloat(parentStyle.borderTopWidth);
        offset = parent.getBoundingClientRect();
        offset.y += parentBorderTop + scrollY;
      }
      if (!settings.inline) {
        const coords = currentEl.getBoundingClientRect();
        let left = coords.x;
        let top = scrollY + coords.y + coords.height + settings.margin;
        if (parent) {
          left -= offset.x;
          top -= offset.y;
          if (left + pickerWidth > parent.clientWidth) {
            left += coords.width - pickerWidth;
            reposition.left = true;
          }
          if (top + pickerHeight > parent.clientHeight - parentMarginTop) {
            if (pickerHeight + settings.margin <= coords.top - (offset.y - scrollY)) {
              top -= coords.height + pickerHeight + settings.margin * 2;
              reposition.top = true;
            }
          }
          top += parent.scrollTop;
        } else {
          if (left + pickerWidth > document2.documentElement.clientWidth) {
            left += coords.width - pickerWidth;
            reposition.left = true;
          }
          if (top + pickerHeight - scrollY > document2.documentElement.clientHeight) {
            if (pickerHeight + settings.margin <= coords.top) {
              top = scrollY + coords.y - pickerHeight - settings.margin;
              reposition.top = true;
            }
          }
        }
        picker.classList.toggle("clr-left", reposition.left);
        picker.classList.toggle("clr-top", reposition.top);
        picker.style.left = `${left}px`;
        picker.style.top = `${top}px`;
        offset.x += picker.offsetLeft;
        offset.y += picker.offsetTop;
      }
      colorAreaDims = {
        width: colorArea.offsetWidth,
        height: colorArea.offsetHeight,
        x: colorArea.offsetLeft + offset.x,
        y: colorArea.offsetTop + offset.y
      };
    }
    function wrapFields(selector) {
      if (selector instanceof HTMLElement) {
        wrapColorField(selector);
      } else if (Array.isArray(selector)) {
        selector.forEach(wrapColorField);
      } else {
        document2.querySelectorAll(selector).forEach(wrapColorField);
      }
    }
    function wrapColorField(field) {
      const parentNode = field.parentNode;
      if (!parentNode.classList.contains("clr-field")) {
        const wrapper = document2.createElement("div");
        let classes = "clr-field";
        if (settings.rtl || field.classList.contains("clr-rtl")) {
          classes += " clr-rtl";
        }
        wrapper.innerHTML = '<button type="button" aria-labelledby="clr-open-label"></button>';
        parentNode.insertBefore(wrapper, field);
        wrapper.className = classes;
        wrapper.style.color = field.value;
        wrapper.appendChild(field);
      }
    }
    function updateColorPreview(event) {
      const parent = event.target.parentNode;
      if (parent.classList.contains("clr-field")) {
        parent.style.color = event.target.value;
      }
    }
    function closePicker(revert) {
      if (currentEl && !settings.inline) {
        const prevEl = currentEl;
        if (revert) {
          currentEl = undefined2;
          if (oldColor !== prevEl.value) {
            prevEl.value = oldColor;
            prevEl.dispatchEvent(new Event("input", { bubbles: true }));
          }
        }
        setTimeout(() => {
          if (oldColor !== prevEl.value) {
            prevEl.dispatchEvent(new Event("change", { bubbles: true }));
          }
        });
        picker.classList.remove("clr-open");
        if (hasInstance) {
          resetVirtualInstance();
        }
        prevEl.dispatchEvent(new Event("close", { bubbles: true }));
        if (settings.focusInput) {
          prevEl.focus({ preventScroll: true });
        }
        currentEl = undefined2;
      }
    }
    function setColorFromStr(str) {
      const rgba = strToRGBA(str);
      const hsva = RGBAtoHSVA(rgba);
      updateMarkerA11yLabel(hsva.s, hsva.v);
      updateColor(rgba, hsva);
      hueSlider.value = hsva.h;
      picker.style.color = `hsl(${hsva.h}, 100%, 50%)`;
      hueMarker.style.left = `${hsva.h / 360 * 100}%`;
      colorMarker.style.left = `${colorAreaDims.width * hsva.s / 100}px`;
      colorMarker.style.top = `${colorAreaDims.height - colorAreaDims.height * hsva.v / 100}px`;
      alphaSlider.value = hsva.a * 100;
      alphaMarker.style.left = `${hsva.a * 100}%`;
    }
    function getColorFormatFromStr(str) {
      const format = str.substring(0, 3).toLowerCase();
      if (format === "rgb" || format === "hsl") {
        return format;
      }
      return "hex";
    }
    function pickColor(color) {
      color = color !== undefined2 ? color : colorValue.value;
      if (currentEl) {
        currentEl.value = color;
        currentEl.dispatchEvent(new Event("input", { bubbles: true }));
      }
      if (settings.onChange) {
        settings.onChange.call(window2, color, currentEl);
      }
      document2.dispatchEvent(new CustomEvent("coloris:pick", { detail: { color, currentEl } }));
    }
    function setColorAtPosition(x, y2) {
      const hsva = {
        h: hueSlider.value * 1,
        s: x / colorAreaDims.width * 100,
        v: 100 - y2 / colorAreaDims.height * 100,
        a: alphaSlider.value / 100
      };
      const rgba = HSVAtoRGBA(hsva);
      updateMarkerA11yLabel(hsva.s, hsva.v);
      updateColor(rgba, hsva);
      pickColor();
    }
    function updateMarkerA11yLabel(saturation, value) {
      let label = settings.a11y.marker;
      saturation = saturation.toFixed(1) * 1;
      value = value.toFixed(1) * 1;
      label = label.replace("{s}", saturation);
      label = label.replace("{v}", value);
      colorMarker.setAttribute("aria-label", label);
    }
    function getPointerPosition(event) {
      return {
        pageX: event.changedTouches ? event.changedTouches[0].pageX : event.pageX,
        pageY: event.changedTouches ? event.changedTouches[0].pageY : event.pageY
      };
    }
    function moveMarker(event) {
      const pointer = getPointerPosition(event);
      let x = pointer.pageX - colorAreaDims.x;
      let y2 = pointer.pageY - colorAreaDims.y;
      if (container) {
        y2 += container.scrollTop;
      }
      setMarkerPosition(x, y2);
      event.preventDefault();
      event.stopPropagation();
    }
    function moveMarkerOnKeydown(offsetX, offsetY) {
      let x = colorMarker.style.left.replace("px", "") * 1 + offsetX;
      let y2 = colorMarker.style.top.replace("px", "") * 1 + offsetY;
      setMarkerPosition(x, y2);
    }
    function setMarkerPosition(x, y2) {
      x = x < 0 ? 0 : x > colorAreaDims.width ? colorAreaDims.width : x;
      y2 = y2 < 0 ? 0 : y2 > colorAreaDims.height ? colorAreaDims.height : y2;
      colorMarker.style.left = `${x}px`;
      colorMarker.style.top = `${y2}px`;
      setColorAtPosition(x, y2);
      colorMarker.focus();
    }
    function updateColor(rgba, hsva) {
      if (rgba === void 0) {
        rgba = {};
      }
      if (hsva === void 0) {
        hsva = {};
      }
      let format = settings.format;
      for (const key in rgba) {
        currentColor[key] = rgba[key];
      }
      for (const key in hsva) {
        currentColor[key] = hsva[key];
      }
      const hex = RGBAToHex(currentColor);
      const opaqueHex = hex.substring(0, 7);
      colorMarker.style.color = opaqueHex;
      alphaMarker.parentNode.style.color = opaqueHex;
      alphaMarker.style.color = hex;
      colorPreview.style.color = hex;
      colorArea.style.display = "none";
      colorArea.offsetHeight;
      colorArea.style.display = "";
      alphaMarker.nextElementSibling.style.display = "none";
      alphaMarker.nextElementSibling.offsetHeight;
      alphaMarker.nextElementSibling.style.display = "";
      if (format === "mixed") {
        format = currentColor.a === 1 ? "hex" : "rgb";
      } else if (format === "auto") {
        format = currentFormat;
      }
      switch (format) {
        case "hex":
          colorValue.value = hex;
          break;
        case "rgb":
          colorValue.value = RGBAToStr(currentColor);
          break;
        case "hsl":
          colorValue.value = HSLAToStr(HSVAtoHSLA(currentColor));
          break;
      }
      document2.querySelector(`.clr-format [value="${format}"]`).checked = true;
    }
    function setHue() {
      const hue = hueSlider.value * 1;
      const x = colorMarker.style.left.replace("px", "") * 1;
      const y2 = colorMarker.style.top.replace("px", "") * 1;
      picker.style.color = `hsl(${hue}, 100%, 50%)`;
      hueMarker.style.left = `${hue / 360 * 100}%`;
      setColorAtPosition(x, y2);
    }
    function setAlpha() {
      const alpha = alphaSlider.value / 100;
      alphaMarker.style.left = `${alpha * 100}%`;
      updateColor({ a: alpha });
      pickColor();
    }
    function HSVAtoRGBA(hsva) {
      const saturation = hsva.s / 100;
      const value = hsva.v / 100;
      let chroma = saturation * value;
      let hueBy60 = hsva.h / 60;
      let x = chroma * (1 - Math2.abs(hueBy60 % 2 - 1));
      let m = value - chroma;
      chroma = chroma + m;
      x = x + m;
      const index = Math2.floor(hueBy60) % 6;
      const red = [chroma, x, m, m, x, chroma][index];
      const green = [x, chroma, chroma, x, m, m][index];
      const blue = [m, m, x, chroma, chroma, x][index];
      return {
        r: Math2.round(red * 255),
        g: Math2.round(green * 255),
        b: Math2.round(blue * 255),
        a: hsva.a
      };
    }
    function HSVAtoHSLA(hsva) {
      const value = hsva.v / 100;
      const lightness = value * (1 - hsva.s / 100 / 2);
      let saturation;
      if (lightness > 0 && lightness < 1) {
        saturation = Math2.round((value - lightness) / Math2.min(lightness, 1 - lightness) * 100);
      }
      return {
        h: hsva.h,
        s: saturation || 0,
        l: Math2.round(lightness * 100),
        a: hsva.a
      };
    }
    function RGBAtoHSVA(rgba) {
      const red = rgba.r / 255;
      const green = rgba.g / 255;
      const blue = rgba.b / 255;
      const xmax = Math2.max(red, green, blue);
      const xmin = Math2.min(red, green, blue);
      const chroma = xmax - xmin;
      const value = xmax;
      let hue = 0;
      let saturation = 0;
      if (chroma) {
        if (xmax === red) {
          hue = (green - blue) / chroma;
        }
        if (xmax === green) {
          hue = 2 + (blue - red) / chroma;
        }
        if (xmax === blue) {
          hue = 4 + (red - green) / chroma;
        }
        if (xmax) {
          saturation = chroma / xmax;
        }
      }
      hue = Math2.floor(hue * 60);
      return {
        h: hue < 0 ? hue + 360 : hue,
        s: Math2.round(saturation * 100),
        v: Math2.round(value * 100),
        a: rgba.a
      };
    }
    function strToRGBA(str) {
      const regex = /^((rgba)|rgb)[\D]+([\d.]+)[\D]+([\d.]+)[\D]+([\d.]+)[\D]*?([\d.]+|$)/i;
      let match, rgba;
      ctx.fillStyle = "#000";
      ctx.fillStyle = str;
      match = regex.exec(ctx.fillStyle);
      if (match) {
        rgba = {
          r: match[3] * 1,
          g: match[4] * 1,
          b: match[5] * 1,
          a: match[6] * 1
        };
      } else {
        match = ctx.fillStyle.replace("#", "").match(/.{2}/g).map((h2) => parseInt(h2, 16));
        rgba = {
          r: match[0],
          g: match[1],
          b: match[2],
          a: 1
        };
      }
      return rgba;
    }
    function RGBAToHex(rgba) {
      let R2 = rgba.r.toString(16);
      let G2 = rgba.g.toString(16);
      let B = rgba.b.toString(16);
      let A = "";
      if (rgba.r < 16) {
        R2 = "0" + R2;
      }
      if (rgba.g < 16) {
        G2 = "0" + G2;
      }
      if (rgba.b < 16) {
        B = "0" + B;
      }
      if (settings.alpha && (rgba.a < 1 || settings.forceAlpha)) {
        const alpha = rgba.a * 255 | 0;
        A = alpha.toString(16);
        if (alpha < 16) {
          A = "0" + A;
        }
      }
      return "#" + R2 + G2 + B + A;
    }
    function RGBAToStr(rgba) {
      if (!settings.alpha || rgba.a === 1 && !settings.forceAlpha) {
        return `rgb(${rgba.r}, ${rgba.g}, ${rgba.b})`;
      } else {
        return `rgba(${rgba.r}, ${rgba.g}, ${rgba.b}, ${rgba.a})`;
      }
    }
    function HSLAToStr(hsla) {
      if (!settings.alpha || hsla.a === 1 && !settings.forceAlpha) {
        return `hsl(${hsla.h}, ${hsla.s}%, ${hsla.l}%)`;
      } else {
        return `hsla(${hsla.h}, ${hsla.s}%, ${hsla.l}%, ${hsla.a})`;
      }
    }
    function init() {
      if (document2.getElementById("clr-picker")) return;
      container = undefined2;
      picker = document2.createElement("div");
      picker.setAttribute("id", "clr-picker");
      picker.className = "clr-picker";
      picker.innerHTML = `<input id="clr-color-value" name="clr-color-value" class="clr-color" type="text" value="" spellcheck="false" aria-label="${settings.a11y.input}"><div id="clr-color-area" class="clr-gradient" role="application" aria-label="${settings.a11y.instruction}"><div id="clr-color-marker" class="clr-marker" tabindex="0"></div></div><div class="clr-hue"><input id="clr-hue-slider" name="clr-hue-slider" type="range" min="0" max="360" step="1" aria-label="${settings.a11y.hueSlider}"><div id="clr-hue-marker"></div></div><div class="clr-alpha"><input id="clr-alpha-slider" name="clr-alpha-slider" type="range" min="0" max="100" step="1" aria-label="${settings.a11y.alphaSlider}"><div id="clr-alpha-marker"></div><span></span></div><div id="clr-format" class="clr-format"><fieldset class="clr-segmented"><legend>${settings.a11y.format}</legend><input id="clr-f1" type="radio" name="clr-format" value="hex"><label for="clr-f1">Hex</label><input id="clr-f2" type="radio" name="clr-format" value="rgb"><label for="clr-f2">RGB</label><input id="clr-f3" type="radio" name="clr-format" value="hsl"><label for="clr-f3">HSL</label><span></span></fieldset></div><div id="clr-swatches" class="clr-swatches"></div><button type="button" id="clr-clear" class="clr-clear" aria-label="${settings.a11y.clear}">${settings.clearLabel}</button><div id="clr-color-preview" class="clr-preview"><button type="button" id="clr-close" class="clr-close" aria-label="${settings.a11y.close}">${settings.closeLabel}</button></div><span id="clr-open-label" hidden>${settings.a11y.open}</span><span id="clr-swatch-label" hidden>${settings.a11y.swatch}</span>`;
      document2.body.appendChild(picker);
      colorArea = getEl("clr-color-area");
      colorMarker = getEl("clr-color-marker");
      clearButton = getEl("clr-clear");
      closeButton = getEl("clr-close");
      colorPreview = getEl("clr-color-preview");
      colorValue = getEl("clr-color-value");
      hueSlider = getEl("clr-hue-slider");
      hueMarker = getEl("clr-hue-marker");
      alphaSlider = getEl("clr-alpha-slider");
      alphaMarker = getEl("clr-alpha-marker");
      bindFields(settings.el);
      wrapFields(settings.el);
      addListener(picker, "mousedown", (event) => {
        picker.classList.remove("clr-keyboard-nav");
        event.stopPropagation();
      });
      addListener(colorArea, "mousedown", (event) => {
        addListener(document2, "mousemove", moveMarker);
      });
      addListener(colorArea, "contextmenu", (event) => {
        event.preventDefault();
      });
      addListener(colorArea, "touchstart", (event) => {
        document2.addEventListener("touchmove", moveMarker, { passive: false });
      });
      addListener(colorMarker, "mousedown", (event) => {
        addListener(document2, "mousemove", moveMarker);
      });
      addListener(colorMarker, "touchstart", (event) => {
        document2.addEventListener("touchmove", moveMarker, { passive: false });
      });
      addListener(colorValue, "change", (event) => {
        const value = colorValue.value;
        if (currentEl || settings.inline) {
          const color = value === "" ? value : setColorFromStr(value);
          pickColor(color);
        }
      });
      addListener(clearButton, "click", (event) => {
        pickColor("");
        closePicker();
      });
      addListener(closeButton, "click", (event) => {
        pickColor();
        closePicker();
      });
      addListener(getEl("clr-format"), "click", ".clr-format input", (event) => {
        currentFormat = event.target.value;
        updateColor();
        pickColor();
      });
      addListener(picker, "click", ".clr-swatches button", (event) => {
        setColorFromStr(event.target.textContent);
        pickColor();
        if (settings.swatchesOnly) {
          closePicker();
        }
      });
      addListener(document2, "mouseup", (event) => {
        document2.removeEventListener("mousemove", moveMarker);
      });
      addListener(document2, "touchend", (event) => {
        document2.removeEventListener("touchmove", moveMarker);
      });
      addListener(document2, "mousedown", (event) => {
        keyboardNav = false;
        picker.classList.remove("clr-keyboard-nav");
        closePicker();
      });
      addListener(document2, "keydown", (event) => {
        const key = event.key;
        const target = event.target;
        const shiftKey = event.shiftKey;
        const navKeys = ["Tab", "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
        if (key === "Escape") {
          closePicker(true);
        } else if (navKeys.includes(key)) {
          keyboardNav = true;
          picker.classList.add("clr-keyboard-nav");
        }
        if (key === "Tab" && target.matches(".clr-picker *")) {
          const focusables = getFocusableElements();
          const firstFocusable = focusables.shift();
          const lastFocusable = focusables.pop();
          if (shiftKey && target === firstFocusable) {
            lastFocusable.focus();
            event.preventDefault();
          } else if (!shiftKey && target === lastFocusable) {
            firstFocusable.focus();
            event.preventDefault();
          }
        }
      });
      addListener(document2, "click", ".clr-field button", (event) => {
        if (hasInstance) {
          resetVirtualInstance();
        }
        event.target.nextElementSibling.dispatchEvent(new Event("click", { bubbles: true }));
      });
      addListener(colorMarker, "keydown", (event) => {
        const movements = {
          ArrowUp: [0, -1],
          ArrowDown: [0, 1],
          ArrowLeft: [-1, 0],
          ArrowRight: [1, 0]
        };
        if (Object.keys(movements).includes(event.key)) {
          moveMarkerOnKeydown(...movements[event.key]);
          event.preventDefault();
        }
      });
      addListener(colorArea, "click", moveMarker);
      addListener(hueSlider, "input", setHue);
      addListener(alphaSlider, "input", setAlpha);
    }
    function getFocusableElements() {
      const controls = Array.from(picker.querySelectorAll("input, button"));
      const focusables = controls.filter((node) => !!node.offsetWidth);
      return focusables;
    }
    function getEl(id) {
      return document2.getElementById(id);
    }
    function addListener(context, type, selector, fn) {
      const matches = Element.prototype.matches || Element.prototype.msMatchesSelector;
      if (typeof selector === "string") {
        context.addEventListener(type, (event) => {
          if (matches.call(event.target, selector)) {
            fn.call(event.target, event);
          }
        });
      } else {
        fn = selector;
        context.addEventListener(type, fn);
      }
    }
    function DOMReady(fn, args) {
      args = args !== undefined2 ? args : [];
      if (document2.readyState !== "loading") {
        fn(...args);
      } else {
        document2.addEventListener("DOMContentLoaded", () => {
          fn(...args);
        });
      }
    }
    if (NodeList !== undefined2 && NodeList.prototype && !NodeList.prototype.forEach) {
      NodeList.prototype.forEach = Array.prototype.forEach;
    }
    function setColor(color, target) {
      currentEl = target;
      oldColor = currentEl.value;
      attachVirtualInstance(target);
      currentFormat = getColorFormatFromStr(color);
      updatePickerPosition();
      setColorFromStr(color);
      pickColor();
      if (oldColor !== color) {
        currentEl.dispatchEvent(new Event("change", { bubbles: true }));
      }
    }
    const Coloris2 = (() => {
      const methods = {
        init,
        set: configure,
        wrap: wrapFields,
        close: closePicker,
        setInstance: setVirtualInstance,
        setColor,
        removeInstance: removeVirtualInstance,
        updatePosition: updatePickerPosition,
        ready: DOMReady
      };
      function Coloris3(options) {
        DOMReady(() => {
          if (options) {
            if (typeof options === "string") {
              bindFields(options);
            } else {
              configure(options);
            }
          }
        });
      }
      for (const key in methods) {
        Coloris3[key] = function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          DOMReady(methods[key], args);
        };
      }
      DOMReady(() => {
        window2.addEventListener("resize", (event) => {
          Coloris3.updatePosition();
        });
        window2.addEventListener("scroll", (event) => {
          Coloris3.updatePosition();
        });
      });
      return Coloris3;
    })();
    Coloris2.coloris = Coloris2;
    return Coloris2;
  })(window, document, Math);
})();
var _coloris = Coloris.coloris;
var _init = Coloris.init;
var _set = Coloris.set;
var _wrap = Coloris.wrap;
var _close = Coloris.close;
var _setInstance = Coloris.setInstance;
var _removeInstance = Coloris.removeInstance;
var _updatePosition = Coloris.updatePosition;
var coloris_default = Coloris;

// resources/js/lexical-hashtag-plugin.ts
function getHashtagRegexStringChars2() {
  const latinAccents = "\xC0-\xD6\xD8-\xF6\xF8-\xFF\u0100-\u024F\u0253-\u0254\u0256-\u0257\u0259\u025B\u0263\u0268\u026F\u0272\u0289\u028B\u02BB\u0300-\u036F\u1E00-\u1EFF";
  const nonLatinChars = "\u0400-\u04FF\u0500-\u0527\u2DE0-\u2DFF\uA640-\uA69F\u0591-\u05BF\u05C1-\u05C2\u05C4-\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F4\uFB12-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40-\uFB41\uFB43-\uFB44\uFB46-\uFB4F\u0610-\u061A\u0620-\u065F\u066E-\u06D3\u06D5-\u06DC\u06DE-\u06E8\u06EA-\u06EF\u06FA-\u06FC\u06FF\u0750-\u077F\u08A0\u08A2-\u08AC\u08E4-\u08FE\uFB50-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\u200C-\u200C\u0E01-\u0E3A\u0E40-\u0E4E\u1100-\u11FF\u3130-\u3185\uA960-\uA97F\uAC00-\uD7AF\uD7B0-\uD7FF\uFFA1-\uFFDC";
  const charCode = String.fromCharCode;
  const cjkChars = "\u30A1-\u30FA\u30FC-\u30FE\uFF66-\uFF9F\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\u3041-\u3096\u3099-\u309E\u3400-\u4DBF\u4E00-\u9FFF" + // Kanji (Unified)
  // Disabled as it breaks the Regex.
  // charCode(0x20000) + '-' + charCode(0x2A6DF) + // Kanji (CJK Extension B)
  charCode(173824) + "-" + charCode(177983) + // Kanji (CJK Extension C)
  charCode(177984) + "-" + charCode(178207) + // Kanji (CJK Extension D)
  charCode(194560) + "-" + charCode(195103) + "\u3003\u3005\u303B";
  const otherChars = latinAccents + nonLatinChars + cjkChars;
  const unicodeLetters = "A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u0241\u0250-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EE\u037A\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03CE\u03D0-\u03F5\u03F7-\u0481\u048A-\u04CE\u04D0-\u04F9\u0500-\u050F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0621-\u063A\u0640-\u064A\u066E-\u066F\u0671-\u06D3\u06D5\u06E5-\u06E6\u06EE-\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u076D\u0780-\u07A5\u07B1\u0904-\u0939\u093D\u0950\u0958-\u0961\u097D\u0985-\u098C\u098F-\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC-\u09DD\u09DF-\u09E1\u09F0-\u09F1\u0A05-\u0A0A\u0A0F-\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32-\u0A33\u0A35-\u0A36\u0A38-\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2-\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0-\u0AE1\u0B05-\u0B0C\u0B0F-\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32-\u0B33\u0B35-\u0B39\u0B3D\u0B5C-\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99-\u0B9A\u0B9C\u0B9E-\u0B9F\u0BA3-\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C60-\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0-\u0CE1\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D28\u0D2A-\u0D39\u0D60-\u0D61\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32-\u0E33\u0E40-\u0E46\u0E81-\u0E82\u0E84\u0E87-\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA-\u0EAB\u0EAD-\u0EB0\u0EB2-\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDD\u0F00\u0F40-\u0F47\u0F49-\u0F6A\u0F88-\u0F8B\u1000-\u1021\u1023-\u1027\u1029-\u102A\u1050-\u1055\u10A0-\u10C5\u10D0-\u10FA\u10FC\u1100-\u1159\u115F-\u11A2\u11A8-\u11F9\u1200-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u1676\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19A9\u19C1-\u19C7\u1A00-\u1A16\u1D00-\u1DBF\u1E00-\u1E9B\u1EA0-\u1EF9\u1F00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u2094\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2131\u2133-\u2139\u213C-\u213F\u2145-\u2149\u2C00-\u2C2E\u2C30-\u2C5E\u2C80-\u2CE4\u2D00-\u2D25\u2D30-\u2D65\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3006\u3031-\u3035\u303B-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312C\u3131-\u318E\u31A0-\u31B7\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FBB\uA000-\uA48C\uA800-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uAC00-\uD7A3\uF900-\uFA2D\uFA30-\uFA6A\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40-\uFB41\uFB43-\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
  const unicodeAccents = "\u0300-\u036F\u0483-\u0486\u0591-\u05B9\u05BB-\u05BD\u05BF\u05C1-\u05C2\u05C4-\u05C5\u05C7\u0610-\u0615\u064B-\u065E\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7-\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u0901-\u0903\u093C\u093E-\u094D\u0951-\u0954\u0962-\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7-\u09C8\u09CB-\u09CD\u09D7\u09E2-\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47-\u0A48\u0A4B-\u0A4D\u0A70-\u0A71\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2-\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B43\u0B47-\u0B48\u0B4B-\u0B4D\u0B56-\u0B57\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C01-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55-\u0C56\u0C82-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5-\u0CD6\u0D02-\u0D03\u0D3E-\u0D43\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D82-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2-\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB-\u0EBC\u0EC8-\u0ECD\u0F18-\u0F19\u0F35\u0F37\u0F39\u0F3E-\u0F3F\u0F71-\u0F84\u0F86-\u0F87\u0F90-\u0F97\u0F99-\u0FBC\u0FC6\u102C-\u1032\u1036-\u1039\u1056-\u1059\u135F\u1712-\u1714\u1732-\u1734\u1752-\u1753\u1772-\u1773\u17B6-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8-\u19C9\u1A17-\u1A1B\u1DC0-\u1DC3\u20D0-\u20DC\u20E1\u20E5-\u20EB\u302A-\u302F\u3099-\u309A\uA802\uA806\uA80B\uA823-\uA827\uFB1E\uFE00-\uFE0F\uFE20-\uFE23";
  const unicodeDigits = "0-9\u0660-\u0669\u06F0-\u06F9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\uFF10-\uFF19";
  const alpha = unicodeLetters + unicodeAccents + otherChars;
  const numeric = unicodeDigits + "_";
  const alphanumeric = alpha + numeric;
  const hashChars = "#\\uFF03";
  return {
    alpha,
    alphanumeric,
    hashChars
  };
}
function getHashtagRegexString2() {
  const { alpha, alphanumeric, hashChars } = getHashtagRegexStringChars2();
  const hashtagAlpha = "[" + alpha + "]";
  const hashtagAlphanumeric = "[" + alphanumeric + "]";
  const hashtagBoundary = "^|$|[^&/" + alphanumeric + "]";
  const hashCharList = "[" + hashChars + "]";
  const hashtag = "(" + hashtagBoundary + ")(" + hashCharList + ")(" + hashtagAlphanumeric + "*" + hashtagAlpha + hashtagAlphanumeric + "*)";
  return hashtag;
}
var REGEX2 = new RegExp(getHashtagRegexString2(), "i");
var $createHashtagNode_ = function(textNode) {
  return $createHashtagNode2(textNode.getTextContent());
};
var getHashtagMatch2 = function(text) {
  const matchArr = REGEX2.exec(text);
  if (matchArr === null) {
    return null;
  }
  const hashtagLength = matchArr[3].length + 1;
  const startOffset = matchArr.index + matchArr[1].length;
  const endOffset = startOffset + hashtagLength;
  return {
    end: endOffset,
    start: startOffset
  };
};

// resources/js/lexical-horizontal-rule-plugin.ts
var INSERT_HORIZONTAL_RULE_COMMAND3 = createCommand2("INSERT_HORIZONTAL_RULE_COMMAND");
var HorizontalRuleNode3 = class _HorizontalRuleNode extends DecoratorNode2 {
  static getType() {
    return "horizontalrule";
  }
  static clone(node) {
    return new _HorizontalRuleNode(node.__key);
  }
  static importJSON(serializedNode) {
    return $createHorizontalRuleNode3();
  }
  static importDOM() {
    return {
      hr: () => ({
        conversion: $convertHorizontalRuleElement2,
        priority: 0
      })
    };
  }
  exportDOM() {
    return { element: document.createElement("hr") };
  }
  createDOM(config) {
    const element = document.createElement("hr");
    addClassNamesToElement2(element, config.theme.hr);
    const isSelectedClassName = "selected";
    element?.addEventListener("click", () => {
      element.classList.toggle(isSelectedClassName);
    });
    element?.setAttribute("x-on:click.outside", '$el.classList.remove("' + isSelectedClassName + '")');
    return element;
  }
  getTextContent() {
    return "\n";
  }
  isInline() {
    return false;
  }
  updateDOM() {
    return false;
  }
  decorate() {
    return $getEditor2().getElementByKey(this.__key);
  }
};
function $convertHorizontalRuleElement2() {
  return { node: $createHorizontalRuleNode3() };
}
function $createHorizontalRuleNode3() {
  return $applyNodeReplacement2(new HorizontalRuleNode3());
}
function registerHorizontalRule(editor) {
  return editor.registerCommand(
    INSERT_HORIZONTAL_RULE_COMMAND3,
    (type) => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection)) {
        return false;
      }
      const focusNode = selection.focus.getNode();
      if (focusNode !== null) {
        const horizontalRuleNode = $createHorizontalRuleNode3();
        $insertNodeToNearestRoot2(horizontalRuleNode);
      }
      return true;
    },
    COMMAND_PRIORITY_EDITOR2
  );
}

// node_modules/@lexical/table/LexicalTable.dev.mjs
var LexicalTable_dev_exports = {};
__export(LexicalTable_dev_exports, {
  $computeTableMap: () => $computeTableMap,
  $computeTableMapSkipCellCheck: () => $computeTableMapSkipCellCheck,
  $createTableCellNode: () => $createTableCellNode,
  $createTableNode: () => $createTableNode,
  $createTableNodeWithDimensions: () => $createTableNodeWithDimensions,
  $createTableRowNode: () => $createTableRowNode,
  $createTableSelection: () => $createTableSelection,
  $createTableSelectionFrom: () => $createTableSelectionFrom,
  $deleteTableColumn: () => $deleteTableColumn,
  $deleteTableColumnAtSelection: () => $deleteTableColumnAtSelection,
  $deleteTableColumn__EXPERIMENTAL: () => $deleteTableColumn__EXPERIMENTAL,
  $deleteTableRowAtSelection: () => $deleteTableRowAtSelection,
  $deleteTableRow__EXPERIMENTAL: () => $deleteTableRow__EXPERIMENTAL,
  $findCellNode: () => $findCellNode,
  $findTableNode: () => $findTableNode,
  $getElementForTableNode: () => $getElementForTableNode,
  $getNodeTriplet: () => $getNodeTriplet,
  $getTableAndElementByKey: () => $getTableAndElementByKey,
  $getTableCellNodeFromLexicalNode: () => $getTableCellNodeFromLexicalNode,
  $getTableCellNodeRect: () => $getTableCellNodeRect,
  $getTableColumnIndexFromTableCellNode: () => $getTableColumnIndexFromTableCellNode,
  $getTableNodeFromLexicalNodeOrThrow: () => $getTableNodeFromLexicalNodeOrThrow,
  $getTableRowIndexFromTableCellNode: () => $getTableRowIndexFromTableCellNode,
  $getTableRowNodeFromTableCellNodeOrThrow: () => $getTableRowNodeFromTableCellNodeOrThrow,
  $insertTableColumn: () => $insertTableColumn,
  $insertTableColumnAtSelection: () => $insertTableColumnAtSelection,
  $insertTableColumn__EXPERIMENTAL: () => $insertTableColumn__EXPERIMENTAL,
  $insertTableRow: () => $insertTableRow,
  $insertTableRowAtSelection: () => $insertTableRowAtSelection,
  $insertTableRow__EXPERIMENTAL: () => $insertTableRow__EXPERIMENTAL,
  $isScrollableTablesActive: () => $isScrollableTablesActive,
  $isTableCellNode: () => $isTableCellNode,
  $isTableNode: () => $isTableNode,
  $isTableRowNode: () => $isTableRowNode,
  $isTableSelection: () => $isTableSelection,
  $mergeCells: () => $mergeCells,
  $removeTableRowAtIndex: () => $removeTableRowAtIndex,
  $unmergeCell: () => $unmergeCell,
  INSERT_TABLE_COMMAND: () => INSERT_TABLE_COMMAND,
  TableCellHeaderStates: () => TableCellHeaderStates,
  TableCellNode: () => TableCellNode,
  TableExtension: () => TableExtension,
  TableNode: () => TableNode,
  TableObserver: () => TableObserver,
  TableRowNode: () => TableRowNode,
  applyTableHandlers: () => applyTableHandlers,
  getDOMCellFromTarget: () => getDOMCellFromTarget,
  getTableElement: () => getTableElement,
  getTableObserverFromTableElement: () => getTableObserverFromTableElement,
  registerTableCellUnmergeTransform: () => registerTableCellUnmergeTransform,
  registerTablePlugin: () => registerTablePlugin,
  registerTableSelectionObserver: () => registerTableSelectionObserver,
  setScrollableTablesActive: () => setScrollableTablesActive
});
var PIXEL_VALUE_REG_EXP = /^(\d+(?:\.\d+)?)px$/;
var COLUMN_WIDTH = 75;
var TableCellHeaderStates = {
  BOTH: 3,
  COLUMN: 2,
  NO_STATUS: 0,
  ROW: 1
};
var TableCellNode = class _TableCellNode extends ElementNode2 {
  constructor(headerState = TableCellHeaderStates.NO_STATUS, colSpan = 1, width, key) {
    super(key);
    /** @internal */
    __publicField(this, "__colSpan");
    /** @internal */
    __publicField(this, "__rowSpan");
    /** @internal */
    __publicField(this, "__headerState");
    /** @internal */
    __publicField(this, "__width");
    /** @internal */
    __publicField(this, "__backgroundColor");
    /** @internal */
    __publicField(this, "__verticalAlign");
    this.__colSpan = colSpan;
    this.__rowSpan = 1;
    this.__headerState = headerState;
    this.__width = width;
    this.__backgroundColor = null;
    this.__verticalAlign = void 0;
  }
  static getType() {
    return "tablecell";
  }
  static clone(node) {
    return new _TableCellNode(node.__headerState, node.__colSpan, node.__width, node.__key);
  }
  afterCloneFrom(node) {
    super.afterCloneFrom(node);
    this.__rowSpan = node.__rowSpan;
    this.__backgroundColor = node.__backgroundColor;
    this.__verticalAlign = node.__verticalAlign;
  }
  static importDOM() {
    return {
      td: (node) => ({
        conversion: $convertTableCellNodeElement,
        priority: 0
      }),
      th: (node) => ({
        conversion: $convertTableCellNodeElement,
        priority: 0
      })
    };
  }
  static importJSON(serializedNode) {
    return $createTableCellNode().updateFromJSON(serializedNode);
  }
  updateFromJSON(serializedNode) {
    return super.updateFromJSON(serializedNode).setHeaderStyles(serializedNode.headerState).setColSpan(serializedNode.colSpan || 1).setRowSpan(serializedNode.rowSpan || 1).setWidth(serializedNode.width || void 0).setBackgroundColor(serializedNode.backgroundColor || null).setVerticalAlign(serializedNode.verticalAlign || void 0);
  }
  createDOM(config) {
    const element = document.createElement(this.getTag());
    if (this.__width) {
      element.style.width = `${this.__width}px`;
    }
    if (this.__colSpan > 1) {
      element.colSpan = this.__colSpan;
    }
    if (this.__rowSpan > 1) {
      element.rowSpan = this.__rowSpan;
    }
    if (this.__backgroundColor !== null) {
      element.style.backgroundColor = this.__backgroundColor;
    }
    if (isValidVerticalAlign(this.__verticalAlign)) {
      element.style.verticalAlign = this.__verticalAlign;
    }
    addClassNamesToElement2(element, config.theme.tableCell, this.hasHeader() && config.theme.tableCellHeader);
    return element;
  }
  exportDOM(editor) {
    const output = super.exportDOM(editor);
    if (isHTMLElement2(output.element)) {
      const element = output.element;
      element.setAttribute("data-temporary-table-cell-lexical-key", this.getKey());
      element.style.border = "1px solid black";
      if (this.__colSpan > 1) {
        element.colSpan = this.__colSpan;
      }
      if (this.__rowSpan > 1) {
        element.rowSpan = this.__rowSpan;
      }
      element.style.width = `${this.getWidth() || COLUMN_WIDTH}px`;
      element.style.verticalAlign = this.getVerticalAlign() || "top";
      element.style.textAlign = "start";
      if (this.__backgroundColor === null && this.hasHeader()) {
        element.style.backgroundColor = "#f2f3f5";
      }
    }
    return output;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      ...isValidVerticalAlign(this.__verticalAlign) && {
        verticalAlign: this.__verticalAlign
      },
      backgroundColor: this.getBackgroundColor(),
      colSpan: this.__colSpan,
      headerState: this.__headerState,
      rowSpan: this.__rowSpan,
      width: this.getWidth()
    };
  }
  getColSpan() {
    return this.getLatest().__colSpan;
  }
  setColSpan(colSpan) {
    const self2 = this.getWritable();
    self2.__colSpan = colSpan;
    return self2;
  }
  getRowSpan() {
    return this.getLatest().__rowSpan;
  }
  setRowSpan(rowSpan) {
    const self2 = this.getWritable();
    self2.__rowSpan = rowSpan;
    return self2;
  }
  getTag() {
    return this.hasHeader() ? "th" : "td";
  }
  setHeaderStyles(headerState, mask = TableCellHeaderStates.BOTH) {
    const self2 = this.getWritable();
    self2.__headerState = headerState & mask | self2.__headerState & ~mask;
    return self2;
  }
  getHeaderStyles() {
    return this.getLatest().__headerState;
  }
  setWidth(width) {
    const self2 = this.getWritable();
    self2.__width = width;
    return self2;
  }
  getWidth() {
    return this.getLatest().__width;
  }
  getBackgroundColor() {
    return this.getLatest().__backgroundColor;
  }
  setBackgroundColor(newBackgroundColor) {
    const self2 = this.getWritable();
    self2.__backgroundColor = newBackgroundColor;
    return self2;
  }
  getVerticalAlign() {
    return this.getLatest().__verticalAlign;
  }
  setVerticalAlign(newVerticalAlign) {
    const self2 = this.getWritable();
    self2.__verticalAlign = newVerticalAlign || void 0;
    return self2;
  }
  toggleHeaderStyle(headerStateToToggle) {
    const self2 = this.getWritable();
    if ((self2.__headerState & headerStateToToggle) === headerStateToToggle) {
      self2.__headerState -= headerStateToToggle;
    } else {
      self2.__headerState += headerStateToToggle;
    }
    return self2;
  }
  hasHeaderState(headerState) {
    return (this.getHeaderStyles() & headerState) === headerState;
  }
  hasHeader() {
    return this.getLatest().__headerState !== TableCellHeaderStates.NO_STATUS;
  }
  updateDOM(prevNode) {
    return prevNode.__headerState !== this.__headerState || prevNode.__width !== this.__width || prevNode.__colSpan !== this.__colSpan || prevNode.__rowSpan !== this.__rowSpan || prevNode.__backgroundColor !== this.__backgroundColor || prevNode.__verticalAlign !== this.__verticalAlign;
  }
  isShadowRoot() {
    return true;
  }
  collapseAtStart() {
    return true;
  }
  canBeEmpty() {
    return false;
  }
  canIndent() {
    return false;
  }
};
function isValidVerticalAlign(verticalAlign) {
  return verticalAlign === "middle" || verticalAlign === "bottom";
}
function $convertTableCellNodeElement(domNode) {
  const domNode_ = domNode;
  const nodeName = domNode.nodeName.toLowerCase();
  let width = void 0;
  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.width)) {
    width = parseFloat(domNode_.style.width);
  }
  const tableCellNode = $createTableCellNode(nodeName === "th" ? TableCellHeaderStates.ROW : TableCellHeaderStates.NO_STATUS, domNode_.colSpan, width);
  tableCellNode.__rowSpan = domNode_.rowSpan;
  const backgroundColor = domNode_.style.backgroundColor;
  if (backgroundColor !== "") {
    tableCellNode.__backgroundColor = backgroundColor;
  }
  const verticalAlign = domNode_.style.verticalAlign;
  if (isValidVerticalAlign(verticalAlign)) {
    tableCellNode.__verticalAlign = verticalAlign;
  }
  const style = domNode_.style;
  const textDecoration = (style && style.textDecoration || "").split(" ");
  const hasBoldFontWeight = style.fontWeight === "700" || style.fontWeight === "bold";
  const hasLinethroughTextDecoration = textDecoration.includes("line-through");
  const hasItalicFontStyle = style.fontStyle === "italic";
  const hasUnderlineTextDecoration = textDecoration.includes("underline");
  return {
    after: (childLexicalNodes) => {
      const result = [];
      let paragraphNode = null;
      const removeSingleLineBreakNode = () => {
        if (paragraphNode) {
          const firstChild = paragraphNode.getFirstChild();
          if ($isLineBreakNode2(firstChild) && paragraphNode.getChildrenSize() === 1) {
            firstChild.remove();
          }
        }
      };
      for (const child of childLexicalNodes) {
        if ($isInlineElementOrDecoratorNode2(child) || $isTextNode2(child) || $isLineBreakNode2(child)) {
          if ($isTextNode2(child)) {
            if (hasBoldFontWeight) {
              child.toggleFormat("bold");
            }
            if (hasLinethroughTextDecoration) {
              child.toggleFormat("strikethrough");
            }
            if (hasItalicFontStyle) {
              child.toggleFormat("italic");
            }
            if (hasUnderlineTextDecoration) {
              child.toggleFormat("underline");
            }
          }
          if (paragraphNode) {
            paragraphNode.append(child);
          } else {
            paragraphNode = $createParagraphNode2().append(child);
            result.push(paragraphNode);
          }
        } else {
          result.push(child);
          removeSingleLineBreakNode();
          paragraphNode = null;
        }
      }
      removeSingleLineBreakNode();
      if (result.length === 0) {
        result.push($createParagraphNode2());
      }
      return result;
    },
    node: tableCellNode
  };
}
function $createTableCellNode(headerState = TableCellHeaderStates.NO_STATUS, colSpan = 1, width) {
  return $applyNodeReplacement2(new TableCellNode(headerState, colSpan, width));
}
function $isTableCellNode(node) {
  return node instanceof TableCellNode;
}
var INSERT_TABLE_COMMAND = createCommand2("INSERT_TABLE_COMMAND");
function formatDevErrorMessage10(message) {
  throw new Error(message);
}
var TableRowNode = class _TableRowNode extends ElementNode2 {
  constructor(height, key) {
    super(key);
    /** @internal */
    __publicField(this, "__height");
    this.__height = height;
  }
  static getType() {
    return "tablerow";
  }
  static clone(node) {
    return new _TableRowNode(node.__height, node.__key);
  }
  static importDOM() {
    return {
      tr: (node) => ({
        conversion: $convertTableRowElement,
        priority: 0
      })
    };
  }
  static importJSON(serializedNode) {
    return $createTableRowNode().updateFromJSON(serializedNode);
  }
  updateFromJSON(serializedNode) {
    return super.updateFromJSON(serializedNode).setHeight(serializedNode.height);
  }
  exportJSON() {
    const height = this.getHeight();
    return {
      ...super.exportJSON(),
      ...height === void 0 ? void 0 : {
        height
      }
    };
  }
  createDOM(config) {
    const element = document.createElement("tr");
    if (this.__height) {
      element.style.height = `${this.__height}px`;
    }
    addClassNamesToElement2(element, config.theme.tableRow);
    return element;
  }
  extractWithChild(child, selection, destination) {
    return destination === "html";
  }
  isShadowRoot() {
    return true;
  }
  setHeight(height) {
    const self2 = this.getWritable();
    self2.__height = height;
    return self2;
  }
  getHeight() {
    return this.getLatest().__height;
  }
  updateDOM(prevNode) {
    return prevNode.__height !== this.__height;
  }
  canBeEmpty() {
    return false;
  }
  canIndent() {
    return false;
  }
};
function $convertTableRowElement(domNode) {
  const domNode_ = domNode;
  let height = void 0;
  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.height)) {
    height = parseFloat(domNode_.style.height);
  }
  return {
    after: (children) => $descendantsMatching2(children, $isTableCellNode),
    node: $createTableRowNode(height)
  };
}
function $createTableRowNode(height) {
  return $applyNodeReplacement2(new TableRowNode(height));
}
function $isTableRowNode(node) {
  return node instanceof TableRowNode;
}
var CAN_USE_DOM5 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
var documentMode4 = CAN_USE_DOM5 && "documentMode" in document ? document.documentMode : null;
var IS_FIREFOX4 = CAN_USE_DOM5 && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
CAN_USE_DOM5 && "InputEvent" in window && !documentMode4 ? "getTargetRanges" in new window.InputEvent("input") : false;
function $createTableNodeWithDimensions(rowCount, columnCount, includeHeaders = true) {
  const tableNode = $createTableNode();
  for (let iRow = 0; iRow < rowCount; iRow++) {
    const tableRowNode = $createTableRowNode();
    for (let iColumn = 0; iColumn < columnCount; iColumn++) {
      let headerState = TableCellHeaderStates.NO_STATUS;
      if (typeof includeHeaders === "object") {
        if (iRow === 0 && includeHeaders.rows) {
          headerState |= TableCellHeaderStates.ROW;
        }
        if (iColumn === 0 && includeHeaders.columns) {
          headerState |= TableCellHeaderStates.COLUMN;
        }
      } else if (includeHeaders) {
        if (iRow === 0) {
          headerState |= TableCellHeaderStates.ROW;
        }
        if (iColumn === 0) {
          headerState |= TableCellHeaderStates.COLUMN;
        }
      }
      const tableCellNode = $createTableCellNode(headerState);
      const paragraphNode = $createParagraphNode2();
      paragraphNode.append($createTextNode2());
      tableCellNode.append(paragraphNode);
      tableRowNode.append(tableCellNode);
    }
    tableNode.append(tableRowNode);
  }
  return tableNode;
}
function $getTableCellNodeFromLexicalNode(startingNode) {
  const node = $findMatchingParent3(startingNode, (n2) => $isTableCellNode(n2));
  if ($isTableCellNode(node)) {
    return node;
  }
  return null;
}
function $getTableRowNodeFromTableCellNodeOrThrow(startingNode) {
  const node = $findMatchingParent3(startingNode, (n2) => $isTableRowNode(n2));
  if ($isTableRowNode(node)) {
    return node;
  }
  throw new Error("Expected table cell to be inside of table row.");
}
function $getTableNodeFromLexicalNodeOrThrow(startingNode) {
  const node = $findMatchingParent3(startingNode, (n2) => $isTableNode(n2));
  if ($isTableNode(node)) {
    return node;
  }
  throw new Error("Expected table cell to be inside of table.");
}
function $getTableRowIndexFromTableCellNode(tableCellNode) {
  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);
  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableRowNode);
  return tableNode.getChildren().findIndex((n2) => n2.is(tableRowNode));
}
function $getTableColumnIndexFromTableCellNode(tableCellNode) {
  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);
  return tableRowNode.getChildren().findIndex((n2) => n2.is(tableCellNode));
}
function $getTableCellSiblingsFromTableCellNode(tableCellNode, table) {
  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode);
  const {
    x,
    y: y2
  } = tableNode.getCordsFromCellNode(tableCellNode, table);
  return {
    above: tableNode.getCellNodeFromCords(x, y2 - 1, table),
    below: tableNode.getCellNodeFromCords(x, y2 + 1, table),
    left: tableNode.getCellNodeFromCords(x - 1, y2, table),
    right: tableNode.getCellNodeFromCords(x + 1, y2, table)
  };
}
function $removeTableRowAtIndex(tableNode, indexToDelete) {
  const tableRows = tableNode.getChildren();
  if (indexToDelete >= tableRows.length || indexToDelete < 0) {
    throw new Error("Expected table cell to be inside of table row.");
  }
  const targetRowNode = tableRows[indexToDelete];
  targetRowNode.remove();
  return tableNode;
}
function $insertTableRow(tableNode, targetIndex, shouldInsertAfter = true, rowCount, table) {
  const tableRows = tableNode.getChildren();
  if (targetIndex >= tableRows.length || targetIndex < 0) {
    throw new Error("Table row target index out of range");
  }
  const targetRowNode = tableRows[targetIndex];
  if ($isTableRowNode(targetRowNode)) {
    for (let r2 = 0; r2 < rowCount; r2++) {
      const tableRowCells = targetRowNode.getChildren();
      const tableColumnCount = tableRowCells.length;
      const newTableRowNode = $createTableRowNode();
      for (let c2 = 0; c2 < tableColumnCount; c2++) {
        const tableCellFromTargetRow = tableRowCells[c2];
        if (!$isTableCellNode(tableCellFromTargetRow)) {
          formatDevErrorMessage10(`Expected table cell`);
        }
        const {
          above,
          below
        } = $getTableCellSiblingsFromTableCellNode(tableCellFromTargetRow, table);
        let headerState = TableCellHeaderStates.NO_STATUS;
        const width = above && above.getWidth() || below && below.getWidth() || void 0;
        if (above && above.hasHeaderState(TableCellHeaderStates.COLUMN) || below && below.hasHeaderState(TableCellHeaderStates.COLUMN)) {
          headerState |= TableCellHeaderStates.COLUMN;
        }
        const tableCellNode = $createTableCellNode(headerState, 1, width);
        tableCellNode.append($createParagraphNode2());
        newTableRowNode.append(tableCellNode);
      }
      if (shouldInsertAfter) {
        targetRowNode.insertAfter(newTableRowNode);
      } else {
        targetRowNode.insertBefore(newTableRowNode);
      }
    }
  } else {
    throw new Error("Row before insertion index does not exist.");
  }
  return tableNode;
}
var getHeaderState = (currentState, possibleState) => {
  if (currentState === TableCellHeaderStates.BOTH || currentState === possibleState) {
    return possibleState;
  }
  return TableCellHeaderStates.NO_STATUS;
};
function $insertTableRowAtSelection(insertAfter = true) {
  const selection = $getSelection2();
  if (!($isRangeSelection2(selection) || $isTableSelection(selection))) {
    formatDevErrorMessage10(`Expected a RangeSelection or TableSelection`);
  }
  const anchor = selection.anchor.getNode();
  const focus = selection.focus.getNode();
  const [anchorCell] = $getNodeTriplet(anchor);
  const [focusCell, , grid] = $getNodeTriplet(focus);
  const [, focusCellMap, anchorCellMap] = $computeTableMap(grid, focusCell, anchorCell);
  const {
    startRow: anchorStartRow
  } = anchorCellMap;
  const {
    startRow: focusStartRow
  } = focusCellMap;
  if (insertAfter) {
    return $insertTableRowAtNode(anchorStartRow + anchorCell.__rowSpan > focusStartRow + focusCell.__rowSpan ? anchorCell : focusCell, true);
  } else {
    return $insertTableRowAtNode(focusStartRow < anchorStartRow ? focusCell : anchorCell, false);
  }
}
var $insertTableRow__EXPERIMENTAL = $insertTableRowAtSelection;
function $insertTableRowAtNode(cellNode, insertAfter = true) {
  const [, , grid] = $getNodeTriplet(cellNode);
  const [gridMap, cellMap] = $computeTableMap(grid, cellNode, cellNode);
  const columnCount = gridMap[0].length;
  const {
    startRow: cellStartRow
  } = cellMap;
  let insertedRow = null;
  if (insertAfter) {
    const insertAfterEndRow = cellStartRow + cellNode.__rowSpan - 1;
    const insertAfterEndRowMap = gridMap[insertAfterEndRow];
    const newRow = $createTableRowNode();
    for (let i2 = 0; i2 < columnCount; i2++) {
      const {
        cell,
        startRow
      } = insertAfterEndRowMap[i2];
      if (startRow + cell.__rowSpan - 1 <= insertAfterEndRow) {
        const currentCell = insertAfterEndRowMap[i2].cell;
        const currentCellHeaderState = currentCell.__headerState;
        const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.COLUMN);
        newRow.append($createTableCellNode(headerState).append($createParagraphNode2()));
      } else {
        cell.setRowSpan(cell.__rowSpan + 1);
      }
    }
    const insertAfterEndRowNode = grid.getChildAtIndex(insertAfterEndRow);
    if (!$isTableRowNode(insertAfterEndRowNode)) {
      formatDevErrorMessage10(`insertAfterEndRow is not a TableRowNode`);
    }
    insertAfterEndRowNode.insertAfter(newRow);
    insertedRow = newRow;
  } else {
    const insertBeforeStartRow = cellStartRow;
    const insertBeforeStartRowMap = gridMap[insertBeforeStartRow];
    const newRow = $createTableRowNode();
    for (let i2 = 0; i2 < columnCount; i2++) {
      const {
        cell,
        startRow
      } = insertBeforeStartRowMap[i2];
      if (startRow === insertBeforeStartRow) {
        const currentCell = insertBeforeStartRowMap[i2].cell;
        const currentCellHeaderState = currentCell.__headerState;
        const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.COLUMN);
        newRow.append($createTableCellNode(headerState).append($createParagraphNode2()));
      } else {
        cell.setRowSpan(cell.__rowSpan + 1);
      }
    }
    const insertBeforeStartRowNode = grid.getChildAtIndex(insertBeforeStartRow);
    if (!$isTableRowNode(insertBeforeStartRowNode)) {
      formatDevErrorMessage10(`insertBeforeStartRow is not a TableRowNode`);
    }
    insertBeforeStartRowNode.insertBefore(newRow);
    insertedRow = newRow;
  }
  return insertedRow;
}
function $insertTableColumn(tableNode, targetIndex, shouldInsertAfter = true, columnCount, table) {
  const tableRows = tableNode.getChildren();
  const tableCellsToBeInserted = [];
  for (let r2 = 0; r2 < tableRows.length; r2++) {
    const currentTableRowNode = tableRows[r2];
    if ($isTableRowNode(currentTableRowNode)) {
      for (let c2 = 0; c2 < columnCount; c2++) {
        const tableRowChildren = currentTableRowNode.getChildren();
        if (targetIndex >= tableRowChildren.length || targetIndex < 0) {
          throw new Error("Table column target index out of range");
        }
        const targetCell = tableRowChildren[targetIndex];
        if (!$isTableCellNode(targetCell)) {
          formatDevErrorMessage10(`Expected table cell`);
        }
        const {
          left,
          right
        } = $getTableCellSiblingsFromTableCellNode(targetCell, table);
        let headerState = TableCellHeaderStates.NO_STATUS;
        if (left && left.hasHeaderState(TableCellHeaderStates.ROW) || right && right.hasHeaderState(TableCellHeaderStates.ROW)) {
          headerState |= TableCellHeaderStates.ROW;
        }
        const newTableCell = $createTableCellNode(headerState);
        newTableCell.append($createParagraphNode2());
        tableCellsToBeInserted.push({
          newTableCell,
          targetCell
        });
      }
    }
  }
  tableCellsToBeInserted.forEach(({
    newTableCell,
    targetCell
  }) => {
    if (shouldInsertAfter) {
      targetCell.insertAfter(newTableCell);
    } else {
      targetCell.insertBefore(newTableCell);
    }
  });
  return tableNode;
}
function $insertTableColumnAtSelection(insertAfter = true) {
  const selection = $getSelection2();
  if (!($isRangeSelection2(selection) || $isTableSelection(selection))) {
    formatDevErrorMessage10(`Expected a RangeSelection or TableSelection`);
  }
  const anchor = selection.anchor.getNode();
  const focus = selection.focus.getNode();
  const [anchorCell] = $getNodeTriplet(anchor);
  const [focusCell, , grid] = $getNodeTriplet(focus);
  const [, focusCellMap, anchorCellMap] = $computeTableMap(grid, focusCell, anchorCell);
  const {
    startColumn: anchorStartColumn
  } = anchorCellMap;
  const {
    startColumn: focusStartColumn
  } = focusCellMap;
  if (insertAfter) {
    return $insertTableColumnAtNode(anchorStartColumn + anchorCell.__colSpan > focusStartColumn + focusCell.__colSpan ? anchorCell : focusCell, true);
  } else {
    return $insertTableColumnAtNode(focusStartColumn < anchorStartColumn ? focusCell : anchorCell, false);
  }
}
var $insertTableColumn__EXPERIMENTAL = $insertTableColumnAtSelection;
function $insertTableColumnAtNode(cellNode, insertAfter = true, shouldSetSelection = true) {
  const [, , grid] = $getNodeTriplet(cellNode);
  const [gridMap, cellMap] = $computeTableMap(grid, cellNode, cellNode);
  const rowCount = gridMap.length;
  const {
    startColumn
  } = cellMap;
  const insertAfterColumn = insertAfter ? startColumn + cellNode.__colSpan - 1 : startColumn - 1;
  const gridFirstChild = grid.getFirstChild();
  if (!$isTableRowNode(gridFirstChild)) {
    formatDevErrorMessage10(`Expected firstTable child to be a row`);
  }
  let firstInsertedCell = null;
  function $createTableCellNodeForInsertTableColumn(headerState = TableCellHeaderStates.NO_STATUS) {
    const cell = $createTableCellNode(headerState).append($createParagraphNode2());
    if (firstInsertedCell === null) {
      firstInsertedCell = cell;
    }
    return cell;
  }
  let loopRow = gridFirstChild;
  rowLoop: for (let i2 = 0; i2 < rowCount; i2++) {
    if (i2 !== 0) {
      const currentRow = loopRow.getNextSibling();
      if (!$isTableRowNode(currentRow)) {
        formatDevErrorMessage10(`Expected row nextSibling to be a row`);
      }
      loopRow = currentRow;
    }
    const rowMap = gridMap[i2];
    const currentCellHeaderState = rowMap[insertAfterColumn < 0 ? 0 : insertAfterColumn].cell.__headerState;
    const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.ROW);
    if (insertAfterColumn < 0) {
      $insertFirst3(loopRow, $createTableCellNodeForInsertTableColumn(headerState));
      continue;
    }
    const {
      cell: currentCell,
      startColumn: currentStartColumn,
      startRow: currentStartRow
    } = rowMap[insertAfterColumn];
    if (currentStartColumn + currentCell.__colSpan - 1 <= insertAfterColumn) {
      let insertAfterCell = currentCell;
      let insertAfterCellRowStart = currentStartRow;
      let prevCellIndex = insertAfterColumn;
      while (insertAfterCellRowStart !== i2 && insertAfterCell.__rowSpan > 1) {
        prevCellIndex -= currentCell.__colSpan;
        if (prevCellIndex >= 0) {
          const {
            cell: cell_,
            startRow: startRow_
          } = rowMap[prevCellIndex];
          insertAfterCell = cell_;
          insertAfterCellRowStart = startRow_;
        } else {
          loopRow.append($createTableCellNodeForInsertTableColumn(headerState));
          continue rowLoop;
        }
      }
      insertAfterCell.insertAfter($createTableCellNodeForInsertTableColumn(headerState));
    } else {
      currentCell.setColSpan(currentCell.__colSpan + 1);
    }
  }
  if (firstInsertedCell !== null && shouldSetSelection) {
    $moveSelectionToCell(firstInsertedCell);
  }
  const colWidths = grid.getColWidths();
  if (colWidths) {
    const newColWidths = [...colWidths];
    const columnIndex = insertAfterColumn < 0 ? 0 : insertAfterColumn;
    const newWidth = newColWidths[columnIndex];
    newColWidths.splice(columnIndex, 0, newWidth);
    grid.setColWidths(newColWidths);
  }
  return firstInsertedCell;
}
function $deleteTableColumn(tableNode, targetIndex) {
  const tableRows = tableNode.getChildren();
  for (let i2 = 0; i2 < tableRows.length; i2++) {
    const currentTableRowNode = tableRows[i2];
    if ($isTableRowNode(currentTableRowNode)) {
      const tableRowChildren = currentTableRowNode.getChildren();
      if (targetIndex >= tableRowChildren.length || targetIndex < 0) {
        throw new Error("Table column target index out of range");
      }
      tableRowChildren[targetIndex].remove();
    }
  }
  return tableNode;
}
function $deleteTableRowAtSelection() {
  const selection = $getSelection2();
  if (!($isRangeSelection2(selection) || $isTableSelection(selection))) {
    formatDevErrorMessage10(`Expected a RangeSelection or TableSelection`);
  }
  const [anchor, focus] = selection.isBackward() ? [selection.focus.getNode(), selection.anchor.getNode()] : [selection.anchor.getNode(), selection.focus.getNode()];
  const [anchorCell, , grid] = $getNodeTriplet(anchor);
  const [focusCell] = $getNodeTriplet(focus);
  const [gridMap, anchorCellMap, focusCellMap] = $computeTableMap(grid, anchorCell, focusCell);
  const {
    startRow: anchorStartRow
  } = anchorCellMap;
  const {
    startRow: focusStartRow
  } = focusCellMap;
  const focusEndRow = focusStartRow + focusCell.__rowSpan - 1;
  if (gridMap.length === focusEndRow - anchorStartRow + 1) {
    grid.remove();
    return;
  }
  const columnCount = gridMap[0].length;
  const nextRow = gridMap[focusEndRow + 1];
  const nextRowNode = grid.getChildAtIndex(focusEndRow + 1);
  for (let row = focusEndRow; row >= anchorStartRow; row--) {
    for (let column = columnCount - 1; column >= 0; column--) {
      const {
        cell,
        startRow: cellStartRow,
        startColumn: cellStartColumn
      } = gridMap[row][column];
      if (cellStartColumn !== column) {
        continue;
      }
      if (cellStartRow < anchorStartRow || cellStartRow + cell.__rowSpan - 1 > focusEndRow) {
        const intersectionStart = Math.max(cellStartRow, anchorStartRow);
        const intersectionEnd = Math.min(cell.__rowSpan + cellStartRow - 1, focusEndRow);
        const overflowRowsCount = intersectionStart <= intersectionEnd ? intersectionEnd - intersectionStart + 1 : 0;
        cell.setRowSpan(cell.__rowSpan - overflowRowsCount);
      }
      if (cellStartRow >= anchorStartRow && cellStartRow + cell.__rowSpan - 1 > focusEndRow && // Handle overflow only once
      row === focusEndRow) {
        if (!(nextRowNode !== null)) {
          formatDevErrorMessage10(`Expected nextRowNode not to be null`);
        }
        let insertAfterCell = null;
        for (let columnIndex = 0; columnIndex < column; columnIndex++) {
          const currentCellMap = nextRow[columnIndex];
          const currentCell = currentCellMap.cell;
          if (currentCellMap.startRow === row + 1) {
            insertAfterCell = currentCell;
          }
          if (currentCell.__colSpan > 1) {
            columnIndex += currentCell.__colSpan - 1;
          }
        }
        if (insertAfterCell === null) {
          $insertFirst3(nextRowNode, cell);
        } else {
          insertAfterCell.insertAfter(cell);
        }
      }
    }
    const rowNode = grid.getChildAtIndex(row);
    if (!$isTableRowNode(rowNode)) {
      formatDevErrorMessage10(`Expected TableNode childAtIndex(${String(row)}) to be RowNode`);
    }
    rowNode.remove();
  }
  if (nextRow !== void 0) {
    const {
      cell
    } = nextRow[0];
    $moveSelectionToCell(cell);
  } else {
    const previousRow = gridMap[anchorStartRow - 1];
    const {
      cell
    } = previousRow[0];
    $moveSelectionToCell(cell);
  }
}
var $deleteTableRow__EXPERIMENTAL = $deleteTableRowAtSelection;
function $deleteTableColumnAtSelection() {
  const selection = $getSelection2();
  if (!($isRangeSelection2(selection) || $isTableSelection(selection))) {
    formatDevErrorMessage10(`Expected a RangeSelection or TableSelection`);
  }
  const anchor = selection.anchor.getNode();
  const focus = selection.focus.getNode();
  const [anchorCell, , grid] = $getNodeTriplet(anchor);
  const [focusCell] = $getNodeTriplet(focus);
  const [gridMap, anchorCellMap, focusCellMap] = $computeTableMap(grid, anchorCell, focusCell);
  const {
    startColumn: anchorStartColumn
  } = anchorCellMap;
  const {
    startRow: focusStartRow,
    startColumn: focusStartColumn
  } = focusCellMap;
  const startColumn = Math.min(anchorStartColumn, focusStartColumn);
  const endColumn = Math.max(anchorStartColumn + anchorCell.__colSpan - 1, focusStartColumn + focusCell.__colSpan - 1);
  const selectedColumnCount = endColumn - startColumn + 1;
  const columnCount = gridMap[0].length;
  if (columnCount === endColumn - startColumn + 1) {
    grid.selectPrevious();
    grid.remove();
    return;
  }
  const rowCount = gridMap.length;
  for (let row = 0; row < rowCount; row++) {
    for (let column = startColumn; column <= endColumn; column++) {
      const {
        cell,
        startColumn: cellStartColumn
      } = gridMap[row][column];
      if (cellStartColumn < startColumn) {
        if (column === startColumn) {
          const overflowLeft = startColumn - cellStartColumn;
          cell.setColSpan(cell.__colSpan - // Possible overflow right too
          Math.min(selectedColumnCount, cell.__colSpan - overflowLeft));
        }
      } else if (cellStartColumn + cell.__colSpan - 1 > endColumn) {
        if (column === endColumn) {
          const inSelectedArea = endColumn - cellStartColumn + 1;
          cell.setColSpan(cell.__colSpan - inSelectedArea);
        }
      } else {
        cell.remove();
      }
    }
  }
  const focusRowMap = gridMap[focusStartRow];
  const nextColumn = anchorStartColumn > focusStartColumn ? focusRowMap[anchorStartColumn + anchorCell.__colSpan] : focusRowMap[focusStartColumn + focusCell.__colSpan];
  if (nextColumn !== void 0) {
    const {
      cell
    } = nextColumn;
    $moveSelectionToCell(cell);
  } else {
    const previousRow = focusStartColumn < anchorStartColumn ? focusRowMap[focusStartColumn - 1] : focusRowMap[anchorStartColumn - 1];
    const {
      cell
    } = previousRow;
    $moveSelectionToCell(cell);
  }
  const colWidths = grid.getColWidths();
  if (colWidths) {
    const newColWidths = [...colWidths];
    newColWidths.splice(startColumn, selectedColumnCount);
    grid.setColWidths(newColWidths);
  }
}
var $deleteTableColumn__EXPERIMENTAL = $deleteTableColumnAtSelection;
function $moveSelectionToCell(cell) {
  const firstDescendant = cell.getFirstDescendant();
  if (firstDescendant == null) {
    cell.selectStart();
  } else {
    firstDescendant.getParentOrThrow().selectStart();
  }
}
function $insertFirst3(parent, node) {
  const firstChild = parent.getFirstChild();
  if (firstChild !== null) {
    firstChild.insertBefore(node);
  } else {
    parent.append(node);
  }
}
function $mergeCells(cellNodes) {
  if (cellNodes.length === 0) {
    return null;
  }
  const tableNode = $getTableNodeFromLexicalNodeOrThrow(cellNodes[0]);
  const [gridMap] = $computeTableMapSkipCellCheck(tableNode, null, null);
  let minRow = Infinity;
  let maxRow = -Infinity;
  let minCol = Infinity;
  let maxCol = -Infinity;
  const processedCells = /* @__PURE__ */ new Set();
  for (const row of gridMap) {
    for (const mapCell of row) {
      if (!mapCell || !mapCell.cell) {
        continue;
      }
      const cellKey = mapCell.cell.getKey();
      if (processedCells.has(cellKey)) {
        continue;
      }
      if (cellNodes.some((cell) => cell.is(mapCell.cell))) {
        processedCells.add(cellKey);
        const cellStartRow = mapCell.startRow;
        const cellStartCol = mapCell.startColumn;
        const cellRowSpan = mapCell.cell.__rowSpan || 1;
        const cellColSpan = mapCell.cell.__colSpan || 1;
        minRow = Math.min(minRow, cellStartRow);
        maxRow = Math.max(maxRow, cellStartRow + cellRowSpan - 1);
        minCol = Math.min(minCol, cellStartCol);
        maxCol = Math.max(maxCol, cellStartCol + cellColSpan - 1);
      }
    }
  }
  if (minRow === Infinity || minCol === Infinity) {
    return null;
  }
  const totalRowSpan = maxRow - minRow + 1;
  const totalColSpan = maxCol - minCol + 1;
  const targetCellMap = gridMap[minRow][minCol];
  if (!targetCellMap.cell) {
    return null;
  }
  const targetCell = targetCellMap.cell;
  targetCell.setColSpan(totalColSpan);
  targetCell.setRowSpan(totalRowSpan);
  const seenCells = /* @__PURE__ */ new Set([targetCell.getKey()]);
  for (let row = minRow; row <= maxRow; row++) {
    for (let col = minCol; col <= maxCol; col++) {
      const mapCell = gridMap[row][col];
      if (!mapCell.cell) {
        continue;
      }
      const currentCell = mapCell.cell;
      const key = currentCell.getKey();
      if (!seenCells.has(key)) {
        seenCells.add(key);
        const isEmpty = $cellContainsEmptyParagraph(currentCell);
        if (!isEmpty) {
          targetCell.append(...currentCell.getChildren());
        }
        currentCell.remove();
      }
    }
  }
  if (targetCell.getChildrenSize() === 0) {
    targetCell.append($createParagraphNode2());
  }
  return targetCell;
}
function $cellContainsEmptyParagraph(cell) {
  if (cell.getChildrenSize() !== 1) {
    return false;
  }
  const firstChild = cell.getFirstChildOrThrow();
  if (!$isParagraphNode2(firstChild) || !firstChild.isEmpty()) {
    return false;
  }
  return true;
}
function $unmergeCell() {
  const selection = $getSelection2();
  if (!($isRangeSelection2(selection) || $isTableSelection(selection))) {
    formatDevErrorMessage10(`Expected a RangeSelection or TableSelection`);
  }
  const anchor = selection.anchor.getNode();
  const cellNode = $findMatchingParent3(anchor, $isTableCellNode);
  if (!$isTableCellNode(cellNode)) {
    formatDevErrorMessage10(`Expected to find a parent TableCellNode`);
  }
  return $unmergeCellNode(cellNode);
}
function $unmergeCellNode(cellNode) {
  const [cell, row, grid] = $getNodeTriplet(cellNode);
  const colSpan = cell.__colSpan;
  const rowSpan = cell.__rowSpan;
  if (colSpan === 1 && rowSpan === 1) {
    return;
  }
  const [map, cellMap] = $computeTableMap(grid, cell, cell);
  const {
    startColumn,
    startRow
  } = cellMap;
  const baseColStyle = cell.__headerState & TableCellHeaderStates.COLUMN;
  const colStyles = Array.from({
    length: colSpan
  }, (_v, i2) => {
    let colStyle = baseColStyle;
    for (let rowIdx = 0; colStyle !== 0 && rowIdx < map.length; rowIdx++) {
      colStyle &= map[rowIdx][i2 + startColumn].cell.__headerState;
    }
    return colStyle;
  });
  const baseRowStyle = cell.__headerState & TableCellHeaderStates.ROW;
  const rowStyles = Array.from({
    length: rowSpan
  }, (_v, i2) => {
    let rowStyle = baseRowStyle;
    for (let colIdx = 0; rowStyle !== 0 && colIdx < map[0].length; colIdx++) {
      rowStyle &= map[i2 + startRow][colIdx].cell.__headerState;
    }
    return rowStyle;
  });
  if (colSpan > 1) {
    for (let i2 = 1; i2 < colSpan; i2++) {
      cell.insertAfter($createTableCellNode(colStyles[i2] | rowStyles[0]).append($createParagraphNode2()));
    }
    cell.setColSpan(1);
  }
  if (rowSpan > 1) {
    let currentRowNode;
    for (let i2 = 1; i2 < rowSpan; i2++) {
      const currentRow = startRow + i2;
      const currentRowMap = map[currentRow];
      currentRowNode = (currentRowNode || row).getNextSibling();
      if (!$isTableRowNode(currentRowNode)) {
        formatDevErrorMessage10(`Expected row next sibling to be a row`);
      }
      let insertAfterCell = null;
      for (let column = 0; column < startColumn; column++) {
        const currentCellMap = currentRowMap[column];
        const currentCell = currentCellMap.cell;
        if (currentCellMap.startRow === currentRow) {
          insertAfterCell = currentCell;
        }
        if (currentCell.__colSpan > 1) {
          column += currentCell.__colSpan - 1;
        }
      }
      if (insertAfterCell === null) {
        for (let j = colSpan - 1; j >= 0; j--) {
          $insertFirst3(currentRowNode, $createTableCellNode(colStyles[j] | rowStyles[i2]).append($createParagraphNode2()));
        }
      } else {
        for (let j = colSpan - 1; j >= 0; j--) {
          insertAfterCell.insertAfter($createTableCellNode(colStyles[j] | rowStyles[i2]).append($createParagraphNode2()));
        }
      }
    }
    cell.setRowSpan(1);
  }
}
function $computeTableMap(tableNode, cellA, cellB) {
  const [tableMap, cellAValue, cellBValue] = $computeTableMapSkipCellCheck(tableNode, cellA, cellB);
  if (!(cellAValue !== null)) {
    formatDevErrorMessage10(`Anchor not found in Table`);
  }
  if (!(cellBValue !== null)) {
    formatDevErrorMessage10(`Focus not found in Table`);
  }
  return [tableMap, cellAValue, cellBValue];
}
function $computeTableMapSkipCellCheck(tableNode, cellA, cellB) {
  const tableMap = [];
  let cellAValue = null;
  let cellBValue = null;
  function getMapRow(i2) {
    let row = tableMap[i2];
    if (row === void 0) {
      tableMap[i2] = row = [];
    }
    return row;
  }
  const gridChildren = tableNode.getChildren();
  for (let rowIdx = 0; rowIdx < gridChildren.length; rowIdx++) {
    const row = gridChildren[rowIdx];
    if (!$isTableRowNode(row)) {
      formatDevErrorMessage10(`Expected TableNode children to be TableRowNode`);
    }
    const startMapRow = getMapRow(rowIdx);
    for (let cell = row.getFirstChild(), colIdx = 0; cell != null; cell = cell.getNextSibling()) {
      if (!$isTableCellNode(cell)) {
        formatDevErrorMessage10(`Expected TableRowNode children to be TableCellNode`);
      }
      while (startMapRow[colIdx] !== void 0) {
        colIdx++;
      }
      const value = {
        cell,
        startColumn: colIdx,
        startRow: rowIdx
      };
      const {
        __rowSpan: rowSpan,
        __colSpan: colSpan
      } = cell;
      for (let j = 0; j < rowSpan; j++) {
        if (rowIdx + j >= gridChildren.length) {
          break;
        }
        const mapRow = getMapRow(rowIdx + j);
        for (let i2 = 0; i2 < colSpan; i2++) {
          mapRow[colIdx + i2] = value;
        }
      }
      if (cellA !== null && cellAValue === null && cellA.is(cell)) {
        cellAValue = value;
      }
      if (cellB !== null && cellBValue === null && cellB.is(cell)) {
        cellBValue = value;
      }
    }
  }
  return [tableMap, cellAValue, cellBValue];
}
function $getNodeTriplet(source) {
  let cell;
  if (source instanceof TableCellNode) {
    cell = source;
  } else if ("__type" in source) {
    const cell_ = $findMatchingParent3(source, $isTableCellNode);
    if (!$isTableCellNode(cell_)) {
      formatDevErrorMessage10(`Expected to find a parent TableCellNode`);
    }
    cell = cell_;
  } else {
    const cell_ = $findMatchingParent3(source.getNode(), $isTableCellNode);
    if (!$isTableCellNode(cell_)) {
      formatDevErrorMessage10(`Expected to find a parent TableCellNode`);
    }
    cell = cell_;
  }
  const row = cell.getParent();
  if (!$isTableRowNode(row)) {
    formatDevErrorMessage10(`Expected TableCellNode to have a parent TableRowNode`);
  }
  const grid = row.getParent();
  if (!$isTableNode(grid)) {
    formatDevErrorMessage10(`Expected TableRowNode to have a parent TableNode`);
  }
  return [cell, row, grid];
}
function $computeTableCellRectSpans(map, boundary) {
  const {
    minColumn,
    maxColumn,
    minRow,
    maxRow
  } = boundary;
  let topSpan = 1;
  let leftSpan = 1;
  let rightSpan = 1;
  let bottomSpan = 1;
  const topRow = map[minRow];
  const bottomRow = map[maxRow];
  for (let col = minColumn; col <= maxColumn; col++) {
    topSpan = Math.max(topSpan, topRow[col].cell.__rowSpan);
    bottomSpan = Math.max(bottomSpan, bottomRow[col].cell.__rowSpan);
  }
  for (let row = minRow; row <= maxRow; row++) {
    leftSpan = Math.max(leftSpan, map[row][minColumn].cell.__colSpan);
    rightSpan = Math.max(rightSpan, map[row][maxColumn].cell.__colSpan);
  }
  return {
    bottomSpan,
    leftSpan,
    rightSpan,
    topSpan
  };
}
function $computeTableCellRectBoundary(map, cellAMap, cellBMap) {
  let minColumn = Math.min(cellAMap.startColumn, cellBMap.startColumn);
  let minRow = Math.min(cellAMap.startRow, cellBMap.startRow);
  let maxColumn = Math.max(cellAMap.startColumn + cellAMap.cell.__colSpan - 1, cellBMap.startColumn + cellBMap.cell.__colSpan - 1);
  let maxRow = Math.max(cellAMap.startRow + cellAMap.cell.__rowSpan - 1, cellBMap.startRow + cellBMap.cell.__rowSpan - 1);
  let hasChanges;
  do {
    hasChanges = false;
    for (let row = 0; row < map.length; row++) {
      for (let col = 0; col < map[0].length; col++) {
        const cell = map[row][col];
        if (!cell) {
          continue;
        }
        const cellEndCol = cell.startColumn + cell.cell.__colSpan - 1;
        const cellEndRow = cell.startRow + cell.cell.__rowSpan - 1;
        const intersectsHorizontally = cell.startColumn <= maxColumn && cellEndCol >= minColumn;
        const intersectsVertically = cell.startRow <= maxRow && cellEndRow >= minRow;
        if (intersectsHorizontally && intersectsVertically) {
          const newMinColumn = Math.min(minColumn, cell.startColumn);
          const newMaxColumn = Math.max(maxColumn, cellEndCol);
          const newMinRow = Math.min(minRow, cell.startRow);
          const newMaxRow = Math.max(maxRow, cellEndRow);
          if (newMinColumn !== minColumn || newMaxColumn !== maxColumn || newMinRow !== minRow || newMaxRow !== maxRow) {
            minColumn = newMinColumn;
            maxColumn = newMaxColumn;
            minRow = newMinRow;
            maxRow = newMaxRow;
            hasChanges = true;
          }
        }
      }
    }
  } while (hasChanges);
  return {
    maxColumn,
    maxRow,
    minColumn,
    minRow
  };
}
function $getTableCellNodeRect(tableCellNode) {
  const [cellNode, , gridNode] = $getNodeTriplet(tableCellNode);
  const rows = gridNode.getChildren();
  const rowCount = rows.length;
  const columnCount = rows[0].getChildren().length;
  const cellMatrix = new Array(rowCount);
  for (let i2 = 0; i2 < rowCount; i2++) {
    cellMatrix[i2] = new Array(columnCount);
  }
  for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {
    const row = rows[rowIndex];
    const cells = row.getChildren();
    let columnIndex = 0;
    for (let cellIndex = 0; cellIndex < cells.length; cellIndex++) {
      while (cellMatrix[rowIndex][columnIndex]) {
        columnIndex++;
      }
      const cell = cells[cellIndex];
      const rowSpan = cell.__rowSpan || 1;
      const colSpan = cell.__colSpan || 1;
      for (let i2 = 0; i2 < rowSpan; i2++) {
        for (let j = 0; j < colSpan; j++) {
          cellMatrix[rowIndex + i2][columnIndex + j] = cell;
        }
      }
      if (cellNode === cell) {
        return {
          colSpan,
          columnIndex,
          rowIndex,
          rowSpan
        };
      }
      columnIndex += colSpan;
    }
  }
  return null;
}
function $getCellNodes(tableSelection) {
  const [[anchorNode, anchorCell, anchorRow, anchorTable], [focusNode, focusCell, focusRow, focusTable]] = ["anchor", "focus"].map((k) => {
    const node = tableSelection[k].getNode();
    const cellNode = $findMatchingParent3(node, $isTableCellNode);
    if (!$isTableCellNode(cellNode)) {
      formatDevErrorMessage10(`Expected TableSelection ${k} to be (or a child of) TableCellNode, got key ${node.getKey()} of type ${node.getType()}`);
    }
    const rowNode = cellNode.getParent();
    if (!$isTableRowNode(rowNode)) {
      formatDevErrorMessage10(`Expected TableSelection ${k} cell parent to be a TableRowNode`);
    }
    const tableNode = rowNode.getParent();
    if (!$isTableNode(tableNode)) {
      formatDevErrorMessage10(`Expected TableSelection ${k} row parent to be a TableNode`);
    }
    return [node, cellNode, rowNode, tableNode];
  });
  if (!anchorTable.is(focusTable)) {
    formatDevErrorMessage10(`Expected TableSelection anchor and focus to be in the same table`);
  }
  return {
    anchorCell,
    anchorNode,
    anchorRow,
    anchorTable,
    focusCell,
    focusNode,
    focusRow,
    focusTable
  };
}
var TableSelection = class _TableSelection {
  constructor(tableKey, anchor, focus) {
    __publicField(this, "tableKey");
    __publicField(this, "anchor");
    __publicField(this, "focus");
    __publicField(this, "_cachedNodes");
    __publicField(this, "dirty");
    this.anchor = anchor;
    this.focus = focus;
    anchor._selection = this;
    focus._selection = this;
    this._cachedNodes = null;
    this.dirty = false;
    this.tableKey = tableKey;
  }
  getStartEndPoints() {
    return [this.anchor, this.focus];
  }
  /**
   * {@link $createTableSelection} unfortunately makes it very easy to create
   * nonsense selections, so we have a method to see if the selection probably
   * makes sense.
   *
   * @returns true if the TableSelection is (probably) valid
   */
  isValid() {
    if (this.tableKey === "root" || this.anchor.key === "root" || this.anchor.type !== "element" || this.focus.key === "root" || this.focus.type !== "element") {
      return false;
    }
    const tableNode = $getNodeByKey2(this.tableKey);
    const anchorNode = $getNodeByKey2(this.anchor.key);
    const focusNode = $getNodeByKey2(this.focus.key);
    return tableNode !== null && anchorNode !== null && focusNode !== null;
  }
  /**
   * Returns whether the Selection is "backwards", meaning the focus
   * logically precedes the anchor in the EditorState.
   * @returns true if the Selection is backwards, false otherwise.
   */
  isBackward() {
    return this.focus.isBefore(this.anchor);
  }
  getCachedNodes() {
    return this._cachedNodes;
  }
  setCachedNodes(nodes) {
    this._cachedNodes = nodes;
  }
  is(selection) {
    return $isTableSelection(selection) && this.tableKey === selection.tableKey && this.anchor.is(selection.anchor) && this.focus.is(selection.focus);
  }
  set(tableKey, anchorCellKey, focusCellKey) {
    this.dirty = this.dirty || tableKey !== this.tableKey || anchorCellKey !== this.anchor.key || focusCellKey !== this.focus.key;
    this.tableKey = tableKey;
    this.anchor.key = anchorCellKey;
    this.focus.key = focusCellKey;
    this._cachedNodes = null;
  }
  clone() {
    return new _TableSelection(this.tableKey, $createPoint2(this.anchor.key, this.anchor.offset, this.anchor.type), $createPoint2(this.focus.key, this.focus.offset, this.focus.type));
  }
  isCollapsed() {
    return false;
  }
  extract() {
    return this.getNodes();
  }
  insertRawText(text) {
  }
  insertText() {
  }
  /**
   * Returns whether the provided TextFormatType is present on the Selection.
   * This will be true if any paragraph in table cells has the specified format.
   *
   * @param type the TextFormatType to check for.
   * @returns true if the provided format is currently toggled on on the Selection, false otherwise.
   */
  hasFormat(type) {
    let format = 0;
    const cellNodes = this.getNodes().filter($isTableCellNode);
    cellNodes.forEach((cellNode) => {
      const paragraph = cellNode.getFirstChild();
      if ($isParagraphNode2(paragraph)) {
        format |= paragraph.getTextFormat();
      }
    });
    const formatFlag = TEXT_TYPE_TO_FORMAT2[type];
    return (format & formatFlag) !== 0;
  }
  insertNodes(nodes) {
    const focusNode = this.focus.getNode();
    if (!$isElementNode2(focusNode)) {
      formatDevErrorMessage10(`Expected TableSelection focus to be an ElementNode`);
    }
    const selection = $normalizeSelection__EXPERIMENTAL(focusNode.select(0, focusNode.getChildrenSize()));
    selection.insertNodes(nodes);
  }
  // TODO Deprecate this method. It's confusing when used with colspan|rowspan
  getShape() {
    const {
      anchorCell,
      focusCell
    } = $getCellNodes(this);
    const anchorCellNodeRect = $getTableCellNodeRect(anchorCell);
    if (!(anchorCellNodeRect !== null)) {
      formatDevErrorMessage10(`getCellRect: expected to find AnchorNode`);
    }
    const focusCellNodeRect = $getTableCellNodeRect(focusCell);
    if (!(focusCellNodeRect !== null)) {
      formatDevErrorMessage10(`getCellRect: expected to find focusCellNode`);
    }
    const startX = Math.min(anchorCellNodeRect.columnIndex, focusCellNodeRect.columnIndex);
    const stopX = Math.max(anchorCellNodeRect.columnIndex + anchorCellNodeRect.colSpan - 1, focusCellNodeRect.columnIndex + focusCellNodeRect.colSpan - 1);
    const startY = Math.min(anchorCellNodeRect.rowIndex, focusCellNodeRect.rowIndex);
    const stopY = Math.max(anchorCellNodeRect.rowIndex + anchorCellNodeRect.rowSpan - 1, focusCellNodeRect.rowIndex + focusCellNodeRect.rowSpan - 1);
    return {
      fromX: Math.min(startX, stopX),
      fromY: Math.min(startY, stopY),
      toX: Math.max(startX, stopX),
      toY: Math.max(startY, stopY)
    };
  }
  getNodes() {
    if (!this.isValid()) {
      return [];
    }
    const cachedNodes = this._cachedNodes;
    if (cachedNodes !== null) {
      return cachedNodes;
    }
    const {
      anchorTable: tableNode,
      anchorCell,
      focusCell
    } = $getCellNodes(this);
    const focusCellGrid = focusCell.getParents()[1];
    if (focusCellGrid !== tableNode) {
      if (!tableNode.isParentOf(focusCell)) {
        const gridParent = tableNode.getParent();
        if (!(gridParent != null)) {
          formatDevErrorMessage10(`Expected gridParent to have a parent`);
        }
        this.set(this.tableKey, gridParent.getKey(), focusCell.getKey());
      } else {
        const focusCellParent = focusCellGrid.getParent();
        if (!(focusCellParent != null)) {
          formatDevErrorMessage10(`Expected focusCellParent to have a parent`);
        }
        this.set(this.tableKey, focusCell.getKey(), focusCellParent.getKey());
      }
      return this.getNodes();
    }
    const [map, cellAMap, cellBMap] = $computeTableMap(tableNode, anchorCell, focusCell);
    const {
      minColumn,
      maxColumn,
      minRow,
      maxRow
    } = $computeTableCellRectBoundary(map, cellAMap, cellBMap);
    const nodeMap = /* @__PURE__ */ new Map([[tableNode.getKey(), tableNode]]);
    let lastRow = null;
    for (let i2 = minRow; i2 <= maxRow; i2++) {
      for (let j = minColumn; j <= maxColumn; j++) {
        const {
          cell
        } = map[i2][j];
        const currentRow = cell.getParent();
        if (!$isTableRowNode(currentRow)) {
          formatDevErrorMessage10(`Expected TableCellNode parent to be a TableRowNode`);
        }
        if (currentRow !== lastRow) {
          nodeMap.set(currentRow.getKey(), currentRow);
          lastRow = currentRow;
        }
        if (!nodeMap.has(cell.getKey())) {
          $visitRecursively(cell, (childNode) => {
            nodeMap.set(childNode.getKey(), childNode);
          });
        }
      }
    }
    const nodes = Array.from(nodeMap.values());
    if (!isCurrentlyReadOnlyMode2()) {
      this._cachedNodes = nodes;
    }
    return nodes;
  }
  getTextContent() {
    const nodes = this.getNodes().filter((node) => $isTableCellNode(node));
    let textContent = "";
    for (let i2 = 0; i2 < nodes.length; i2++) {
      const node = nodes[i2];
      const row = node.__parent;
      const nextRow = (nodes[i2 + 1] || {}).__parent;
      textContent += node.getTextContent() + (nextRow !== row ? "\n" : "	");
    }
    return textContent;
  }
};
function $isTableSelection(x) {
  return x instanceof TableSelection;
}
function $createTableSelection() {
  const anchor = $createPoint2("root", 0, "element");
  const focus = $createPoint2("root", 0, "element");
  return new TableSelection("root", anchor, focus);
}
function $createTableSelectionFrom(tableNode, anchorCell, focusCell) {
  const tableNodeKey = tableNode.getKey();
  const anchorCellKey = anchorCell.getKey();
  const focusCellKey = focusCell.getKey();
  {
    if (!tableNode.isAttached()) {
      formatDevErrorMessage10(`$createTableSelectionFrom: tableNode ${tableNodeKey} is not attached`);
    }
    if (!tableNode.is($findTableNode(anchorCell))) {
      formatDevErrorMessage10(`$createTableSelectionFrom: anchorCell ${anchorCellKey} is not in table ${tableNodeKey}`);
    }
    if (!tableNode.is($findTableNode(focusCell))) {
      formatDevErrorMessage10(`$createTableSelectionFrom: focusCell ${focusCellKey} is not in table ${tableNodeKey}`);
    }
  }
  const prevSelection = $getSelection2();
  const nextSelection = $isTableSelection(prevSelection) ? prevSelection.clone() : $createTableSelection();
  nextSelection.set(tableNode.getKey(), anchorCell.getKey(), focusCell.getKey());
  return nextSelection;
}
function $visitRecursively(node, $visit) {
  const stack = [[node]];
  for (let currentArray = stack.at(-1); currentArray !== void 0 && stack.length > 0; currentArray = stack.at(-1)) {
    const currentNode = currentArray.pop();
    if (currentNode === void 0) {
      stack.pop();
    } else if ($visit(currentNode) !== false && $isElementNode2(currentNode)) {
      stack.push(currentNode.getChildren());
    }
  }
}
function $getTableAndElementByKey(tableNodeKey, editor = $getEditor2()) {
  const tableNode = $getNodeByKey2(tableNodeKey);
  if (!$isTableNode(tableNode)) {
    formatDevErrorMessage10(`TableObserver: Expected tableNodeKey ${tableNodeKey} to be a TableNode`);
  }
  const tableElement = getTableElement(tableNode, editor.getElementByKey(tableNodeKey));
  if (!(tableElement !== null)) {
    formatDevErrorMessage10(`TableObserver: Expected to find TableElement in DOM for key ${tableNodeKey}`);
  }
  return {
    tableElement,
    tableNode
  };
}
var TableObserver = class {
  constructor(editor, tableNodeKey) {
    __publicField(this, "focusX");
    __publicField(this, "focusY");
    __publicField(this, "listenersToRemove");
    __publicField(this, "table");
    __publicField(this, "isHighlightingCells");
    __publicField(this, "anchorX");
    __publicField(this, "anchorY");
    __publicField(this, "tableNodeKey");
    __publicField(this, "anchorCell");
    __publicField(this, "focusCell");
    __publicField(this, "anchorCellNodeKey");
    __publicField(this, "focusCellNodeKey");
    __publicField(this, "editor");
    __publicField(this, "tableSelection");
    __publicField(this, "hasHijackedSelectionStyles");
    __publicField(this, "isSelecting");
    __publicField(this, "pointerType");
    __publicField(this, "shouldCheckSelection");
    __publicField(this, "abortController");
    __publicField(this, "listenerOptions");
    __publicField(this, "nextFocus");
    this.isHighlightingCells = false;
    this.anchorX = -1;
    this.anchorY = -1;
    this.focusX = -1;
    this.focusY = -1;
    this.listenersToRemove = /* @__PURE__ */ new Set();
    this.tableNodeKey = tableNodeKey;
    this.editor = editor;
    this.table = {
      columns: 0,
      domRows: [],
      rows: 0
    };
    this.tableSelection = null;
    this.anchorCellNodeKey = null;
    this.focusCellNodeKey = null;
    this.anchorCell = null;
    this.focusCell = null;
    this.hasHijackedSelectionStyles = false;
    this.isSelecting = false;
    this.pointerType = null;
    this.shouldCheckSelection = false;
    this.abortController = new AbortController();
    this.listenerOptions = {
      signal: this.abortController.signal
    };
    this.nextFocus = null;
    this.trackTable();
  }
  getTable() {
    return this.table;
  }
  removeListeners() {
    this.abortController.abort("removeListeners");
    Array.from(this.listenersToRemove).forEach((removeListener) => removeListener());
    this.listenersToRemove.clear();
  }
  $lookup() {
    return $getTableAndElementByKey(this.tableNodeKey, this.editor);
  }
  trackTable() {
    const observer = new MutationObserver((records) => {
      this.editor.getEditorState().read(() => {
        let gridNeedsRedraw = false;
        for (let i2 = 0; i2 < records.length; i2++) {
          const record = records[i2];
          const target = record.target;
          const nodeName = target.nodeName;
          if (nodeName === "TABLE" || nodeName === "TBODY" || nodeName === "THEAD" || nodeName === "TR") {
            gridNeedsRedraw = true;
            break;
          }
        }
        if (!gridNeedsRedraw) {
          return;
        }
        const {
          tableNode,
          tableElement
        } = this.$lookup();
        this.table = getTable(tableNode, tableElement);
      }, {
        editor: this.editor
      });
    });
    this.editor.getEditorState().read(() => {
      const {
        tableNode,
        tableElement
      } = this.$lookup();
      this.table = getTable(tableNode, tableElement);
      observer.observe(tableElement, {
        attributes: true,
        childList: true,
        subtree: true
      });
    }, {
      editor: this.editor
    });
  }
  $clearHighlight() {
    const editor = this.editor;
    this.isHighlightingCells = false;
    this.anchorX = -1;
    this.anchorY = -1;
    this.focusX = -1;
    this.focusY = -1;
    this.tableSelection = null;
    this.anchorCellNodeKey = null;
    this.focusCellNodeKey = null;
    this.anchorCell = null;
    this.focusCell = null;
    this.hasHijackedSelectionStyles = false;
    this.$enableHighlightStyle();
    const {
      tableNode,
      tableElement
    } = this.$lookup();
    const grid = getTable(tableNode, tableElement);
    $updateDOMForSelection(editor, grid, null);
    if ($getSelection2() !== null) {
      $setSelection2(null);
      editor.dispatchCommand(SELECTION_CHANGE_COMMAND2, void 0);
    }
  }
  $enableHighlightStyle() {
    const editor = this.editor;
    const {
      tableElement
    } = this.$lookup();
    removeClassNamesFromElement2(tableElement, editor._config.theme.tableSelection);
    tableElement.classList.remove("disable-selection");
    this.hasHijackedSelectionStyles = false;
  }
  $disableHighlightStyle() {
    const {
      tableElement
    } = this.$lookup();
    addClassNamesToElement2(tableElement, this.editor._config.theme.tableSelection);
    this.hasHijackedSelectionStyles = true;
  }
  $updateTableTableSelection(selection) {
    if (selection !== null) {
      if (!(selection.tableKey === this.tableNodeKey)) {
        formatDevErrorMessage10(`TableObserver.$updateTableTableSelection: selection.tableKey !== this.tableNodeKey ('${selection.tableKey}' !== '${this.tableNodeKey}')`);
      }
      const editor = this.editor;
      this.tableSelection = selection;
      this.isHighlightingCells = true;
      this.$disableHighlightStyle();
      this.updateDOMSelection();
      $updateDOMForSelection(editor, this.table, this.tableSelection);
    } else {
      this.$clearHighlight();
    }
  }
  /**
   * @internal
   * Firefox has a strange behavior where pressing the down arrow key from
   * above the table will move the caret after the table and then lexical
   * will select the last cell instead of the first.
   * We do still want to let the browser handle caret movement but we will
   * use this property to "tag" the update so that we can recheck the
   * selection after the event is processed.
   */
  setShouldCheckSelection() {
    this.shouldCheckSelection = true;
  }
  /**
   * @internal
   */
  getAndClearShouldCheckSelection() {
    if (this.shouldCheckSelection) {
      this.shouldCheckSelection = false;
      return true;
    }
    return false;
  }
  /**
   * @internal
   * When handling mousemove events we track what the focus cell should be, but
   * the DOM selection may end up somewhere else entirely. We don't have an elegant
   * way to handle this after the DOM selection has been resolved in a
   * SELECTION_CHANGE_COMMAND callback.
   */
  setNextFocus(nextFocus) {
    this.nextFocus = nextFocus;
  }
  /** @internal */
  getAndClearNextFocus() {
    const {
      nextFocus
    } = this;
    if (nextFocus !== null) {
      this.nextFocus = null;
    }
    return nextFocus;
  }
  /** @internal */
  updateDOMSelection() {
    if (this.anchorCell !== null && this.focusCell !== null) {
      const domSelection = getDOMSelection2(this.editor._window);
      if (domSelection && domSelection.rangeCount > 0) {
        domSelection.removeAllRanges();
      }
    }
  }
  $setFocusCellForSelection(cell, ignoreStart = false) {
    const editor = this.editor;
    const {
      tableNode
    } = this.$lookup();
    const cellX = cell.x;
    const cellY = cell.y;
    this.focusCell = cell;
    if (!this.isHighlightingCells && (this.anchorX !== cellX || this.anchorY !== cellY || ignoreStart)) {
      this.isHighlightingCells = true;
      this.$disableHighlightStyle();
    } else if (cellX === this.focusX && cellY === this.focusY) {
      return false;
    }
    this.focusX = cellX;
    this.focusY = cellY;
    if (this.isHighlightingCells) {
      const focusTableCellNode = $getNearestTableCellInTableFromDOMNode(tableNode, cell.elem);
      if (this.tableSelection != null && this.anchorCellNodeKey != null && focusTableCellNode !== null) {
        this.focusCellNodeKey = focusTableCellNode.getKey();
        this.tableSelection = $createTableSelectionFrom(tableNode, this.$getAnchorTableCellOrThrow(), focusTableCellNode);
        $setSelection2(this.tableSelection);
        editor.dispatchCommand(SELECTION_CHANGE_COMMAND2, void 0);
        $updateDOMForSelection(editor, this.table, this.tableSelection);
        return true;
      }
    }
    return false;
  }
  $getAnchorTableCell() {
    return this.anchorCellNodeKey ? $getNodeByKey2(this.anchorCellNodeKey) : null;
  }
  $getAnchorTableCellOrThrow() {
    const anchorTableCell = this.$getAnchorTableCell();
    if (!(anchorTableCell !== null)) {
      formatDevErrorMessage10(`TableObserver anchorTableCell is null`);
    }
    return anchorTableCell;
  }
  $getFocusTableCell() {
    return this.focusCellNodeKey ? $getNodeByKey2(this.focusCellNodeKey) : null;
  }
  $getFocusTableCellOrThrow() {
    const focusTableCell = this.$getFocusTableCell();
    if (!(focusTableCell !== null)) {
      formatDevErrorMessage10(`TableObserver focusTableCell is null`);
    }
    return focusTableCell;
  }
  $setAnchorCellForSelection(cell) {
    this.isHighlightingCells = false;
    this.anchorCell = cell;
    this.anchorX = cell.x;
    this.anchorY = cell.y;
    const {
      tableNode
    } = this.$lookup();
    const anchorTableCellNode = $getNearestTableCellInTableFromDOMNode(tableNode, cell.elem);
    if (anchorTableCellNode !== null) {
      const anchorNodeKey = anchorTableCellNode.getKey();
      this.tableSelection = this.tableSelection != null ? this.tableSelection.clone() : $createTableSelection();
      this.anchorCellNodeKey = anchorNodeKey;
    }
  }
  $formatCells(type) {
    const selection = $getSelection2();
    if (!$isTableSelection(selection)) {
      formatDevErrorMessage10(`Expected Table selection`);
    }
    const formatSelection = $createRangeSelection2();
    const anchor = formatSelection.anchor;
    const focus = formatSelection.focus;
    const cellNodes = selection.getNodes().filter($isTableCellNode);
    if (!(cellNodes.length > 0)) {
      formatDevErrorMessage10(`No table cells present`);
    }
    const paragraph = cellNodes[0].getFirstChild();
    const alignFormatWith = $isParagraphNode2(paragraph) ? paragraph.getFormatFlags(type, null) : null;
    cellNodes.forEach((cellNode) => {
      anchor.set(cellNode.getKey(), 0, "element");
      focus.set(cellNode.getKey(), cellNode.getChildrenSize(), "element");
      formatSelection.formatText(type, alignFormatWith);
    });
    $setSelection2(selection);
    this.editor.dispatchCommand(SELECTION_CHANGE_COMMAND2, void 0);
  }
  $clearText() {
    const {
      editor
    } = this;
    const tableNode = $getNodeByKey2(this.tableNodeKey);
    if (!$isTableNode(tableNode)) {
      throw new Error("Expected TableNode.");
    }
    const selection = $getSelection2();
    if (!$isTableSelection(selection)) {
      formatDevErrorMessage10(`Expected TableSelection`);
    }
    const selectedNodes = selection.getNodes().filter($isTableCellNode);
    const firstRow = tableNode.getFirstChild();
    const lastRow = tableNode.getLastChild();
    const isEntireTableSelected = selectedNodes.length > 0 && firstRow !== null && lastRow !== null && $isTableRowNode(firstRow) && $isTableRowNode(lastRow) && selectedNodes[0] === firstRow.getFirstChild() && selectedNodes[selectedNodes.length - 1] === lastRow.getLastChild();
    if (isEntireTableSelected) {
      tableNode.selectPrevious();
      const parent = tableNode.getParent();
      tableNode.remove();
      if ($isRootNode2(parent) && parent.isEmpty()) {
        editor.dispatchCommand(INSERT_PARAGRAPH_COMMAND2, void 0);
      }
      return;
    }
    selectedNodes.forEach((cellNode) => {
      if ($isElementNode2(cellNode)) {
        const paragraphNode = $createParagraphNode2();
        const textNode = $createTextNode2();
        paragraphNode.append(textNode);
        cellNode.append(paragraphNode);
        cellNode.getChildren().forEach((child) => {
          if (child !== paragraphNode) {
            child.remove();
          }
        });
      }
    });
    $updateDOMForSelection(editor, this.table, null);
    $setSelection2(null);
    editor.dispatchCommand(SELECTION_CHANGE_COMMAND2, void 0);
  }
};
var LEXICAL_ELEMENT_KEY = "__lexicalTableSelection";
var isPointerDownOnEvent = (event) => {
  return (event.buttons & 1) === 1;
};
function isHTMLTableElement(el) {
  return isHTMLElement2(el) && el.nodeName === "TABLE";
}
function getTableElement(tableNode, dom) {
  if (!dom) {
    return dom;
  }
  const element = isHTMLTableElement(dom) ? dom : tableNode.getDOMSlot(dom).element;
  if (!(element.nodeName === "TABLE")) {
    formatDevErrorMessage10(`getTableElement: Expecting table in as DOM node for TableNode, not ${dom.nodeName}`);
  }
  return element;
}
function getEditorWindow(editor) {
  return editor._window;
}
function $findParentTableCellNodeInTable(tableNode, node) {
  for (let currentNode = node, lastTableCellNode = null; currentNode !== null; currentNode = currentNode.getParent()) {
    if (tableNode.is(currentNode)) {
      return lastTableCellNode;
    } else if ($isTableCellNode(currentNode)) {
      lastTableCellNode = currentNode;
    }
  }
  return null;
}
var ARROW_KEY_COMMANDS_WITH_DIRECTION = [[KEY_ARROW_DOWN_COMMAND2, "down"], [KEY_ARROW_UP_COMMAND2, "up"], [KEY_ARROW_LEFT_COMMAND2, "backward"], [KEY_ARROW_RIGHT_COMMAND2, "forward"]];
var DELETE_TEXT_COMMANDS = [DELETE_WORD_COMMAND2, DELETE_LINE_COMMAND2, DELETE_CHARACTER_COMMAND2];
var DELETE_KEY_COMMANDS = [KEY_BACKSPACE_COMMAND2, KEY_DELETE_COMMAND2];
function applyTableHandlers(tableNode, element, editor, hasTabHandler) {
  const rootElement = editor.getRootElement();
  const editorWindow = getEditorWindow(editor);
  if (!(rootElement !== null && editorWindow !== null)) {
    formatDevErrorMessage10(`applyTableHandlers: editor has no root element set`);
  }
  const tableObserver = new TableObserver(editor, tableNode.getKey());
  const tableElement = getTableElement(tableNode, element);
  attachTableObserverToTableElement(tableElement, tableObserver);
  tableObserver.listenersToRemove.add(() => detachTableObserverFromTableElement(tableElement, tableObserver));
  const createPointerHandlers = () => {
    if (tableObserver.isSelecting) {
      return;
    }
    const onPointerUp = () => {
      tableObserver.isSelecting = false;
      editorWindow.removeEventListener("pointerup", onPointerUp);
      editorWindow.removeEventListener("pointermove", onPointerMove);
    };
    const onPointerMove = (moveEvent) => {
      if (!isPointerDownOnEvent(moveEvent) && tableObserver.isSelecting) {
        tableObserver.isSelecting = false;
        editorWindow.removeEventListener("pointerup", onPointerUp);
        editorWindow.removeEventListener("pointermove", onPointerMove);
        return;
      }
      if (!isDOMNode2(moveEvent.target)) {
        return;
      }
      let focusCell = null;
      const override = !(IS_FIREFOX4 || tableElement.contains(moveEvent.target));
      if (override) {
        focusCell = getDOMCellInTableFromTarget(tableElement, moveEvent.target);
      } else {
        for (const el of document.elementsFromPoint(moveEvent.clientX, moveEvent.clientY)) {
          focusCell = getDOMCellInTableFromTarget(tableElement, el);
          if (focusCell) {
            break;
          }
        }
      }
      if (focusCell && (tableObserver.focusCell === null || focusCell.elem !== tableObserver.focusCell.elem)) {
        tableObserver.setNextFocus({
          focusCell,
          override
        });
        editor.dispatchCommand(SELECTION_CHANGE_COMMAND2, void 0);
      }
    };
    tableObserver.isSelecting = true;
    editorWindow.addEventListener("pointerup", onPointerUp, tableObserver.listenerOptions);
    editorWindow.addEventListener("pointermove", onPointerMove, tableObserver.listenerOptions);
  };
  const onPointerDown2 = (event) => {
    tableObserver.pointerType = event.pointerType;
    if (event.button !== 0 || !isDOMNode2(event.target) || !editorWindow) {
      return;
    }
    const targetCell = getDOMCellFromTarget(event.target);
    if (targetCell !== null) {
      editor.update(() => {
        const prevSelection = $getPreviousSelection2();
        if (IS_FIREFOX4 && event.shiftKey && $isSelectionInTable(prevSelection, tableNode) && ($isRangeSelection2(prevSelection) || $isTableSelection(prevSelection))) {
          const prevAnchorNode = prevSelection.anchor.getNode();
          const prevAnchorCell = $findParentTableCellNodeInTable(tableNode, prevSelection.anchor.getNode());
          if (prevAnchorCell) {
            tableObserver.$setAnchorCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, prevAnchorCell));
            tableObserver.$setFocusCellForSelection(targetCell);
            stopEvent(event);
          } else {
            const newSelection = tableNode.isBefore(prevAnchorNode) ? tableNode.selectStart() : tableNode.selectEnd();
            newSelection.anchor.set(prevSelection.anchor.key, prevSelection.anchor.offset, prevSelection.anchor.type);
          }
        } else {
          if (event.pointerType !== "touch") {
            tableObserver.$setAnchorCellForSelection(targetCell);
          }
        }
      });
    }
    createPointerHandlers();
  };
  tableElement.addEventListener("pointerdown", onPointerDown2, tableObserver.listenerOptions);
  tableObserver.listenersToRemove.add(() => {
    tableElement.removeEventListener("pointerdown", onPointerDown2);
  });
  const onTripleClick = (event) => {
    if (event.detail >= 3 && isDOMNode2(event.target)) {
      const targetCell = getDOMCellFromTarget(event.target);
      if (targetCell !== null) {
        event.preventDefault();
      }
    }
  };
  tableElement.addEventListener("mousedown", onTripleClick, tableObserver.listenerOptions);
  tableObserver.listenersToRemove.add(() => {
    tableElement.removeEventListener("mousedown", onTripleClick);
  });
  const pointerDownCallback = (event) => {
    const target = event.target;
    if (event.button !== 0 || !isDOMNode2(target)) {
      return;
    }
    editor.update(() => {
      const selection = $getSelection2();
      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey && rootElement.contains(target)) {
        tableObserver.$clearHighlight();
      }
    });
  };
  editorWindow.addEventListener("pointerdown", pointerDownCallback, tableObserver.listenerOptions);
  tableObserver.listenersToRemove.add(() => {
    editorWindow.removeEventListener("pointerdown", pointerDownCallback);
  });
  for (const [command, direction] of ARROW_KEY_COMMANDS_WITH_DIRECTION) {
    tableObserver.listenersToRemove.add(editor.registerCommand(command, (event) => $handleArrowKey(editor, event, direction, tableNode, tableObserver), COMMAND_PRIORITY_HIGH2));
  }
  tableObserver.listenersToRemove.add(editor.registerCommand(KEY_ESCAPE_COMMAND2, (event) => {
    const selection = $getSelection2();
    if ($isTableSelection(selection)) {
      const focusCellNode = $findParentTableCellNodeInTable(tableNode, selection.focus.getNode());
      if (focusCellNode !== null) {
        stopEvent(event);
        focusCellNode.selectEnd();
        return true;
      }
    }
    return false;
  }, COMMAND_PRIORITY_HIGH2));
  const deleteTextHandler = (command) => () => {
    const selection = $getSelection2();
    if (!$isSelectionInTable(selection, tableNode)) {
      return false;
    }
    if ($isTableSelection(selection)) {
      tableObserver.$clearText();
      return true;
    } else if ($isRangeSelection2(selection)) {
      const tableCellNode = $findParentTableCellNodeInTable(tableNode, selection.anchor.getNode());
      if (!$isTableCellNode(tableCellNode)) {
        return false;
      }
      const anchorNode = selection.anchor.getNode();
      const focusNode = selection.focus.getNode();
      const isAnchorInside = tableNode.isParentOf(anchorNode);
      const isFocusInside = tableNode.isParentOf(focusNode);
      const selectionContainsPartialTable = isAnchorInside && !isFocusInside || isFocusInside && !isAnchorInside;
      if (selectionContainsPartialTable) {
        tableObserver.$clearText();
        return true;
      }
      const nearestElementNode = $findMatchingParent3(selection.anchor.getNode(), (n2) => $isElementNode2(n2));
      const topLevelCellElementNode = nearestElementNode && $findMatchingParent3(nearestElementNode, (n2) => $isElementNode2(n2) && $isTableCellNode(n2.getParent()));
      if (!$isElementNode2(topLevelCellElementNode) || !$isElementNode2(nearestElementNode)) {
        return false;
      }
      if (command === DELETE_LINE_COMMAND2 && topLevelCellElementNode.getPreviousSibling() === null) {
        return true;
      }
    }
    return false;
  };
  for (const command of DELETE_TEXT_COMMANDS) {
    tableObserver.listenersToRemove.add(editor.registerCommand(command, deleteTextHandler(command), COMMAND_PRIORITY_HIGH2));
  }
  const $deleteCellHandler = (event) => {
    const selection = $getSelection2();
    if (!($isTableSelection(selection) || $isRangeSelection2(selection))) {
      return false;
    }
    const isAnchorInside = tableNode.isParentOf(selection.anchor.getNode());
    const isFocusInside = tableNode.isParentOf(selection.focus.getNode());
    if (isAnchorInside !== isFocusInside) {
      const tablePoint = isAnchorInside ? "anchor" : "focus";
      const outerPoint = isAnchorInside ? "focus" : "anchor";
      const {
        key,
        offset,
        type
      } = selection[outerPoint];
      const newSelection = tableNode[selection[tablePoint].isBefore(selection[outerPoint]) ? "selectPrevious" : "selectNext"]();
      newSelection[outerPoint].set(key, offset, type);
      return false;
    }
    if (!$isSelectionInTable(selection, tableNode)) {
      return false;
    }
    if ($isTableSelection(selection)) {
      if (event) {
        event.preventDefault();
        event.stopPropagation();
      }
      tableObserver.$clearText();
      return true;
    }
    return false;
  };
  for (const command of DELETE_KEY_COMMANDS) {
    tableObserver.listenersToRemove.add(editor.registerCommand(command, $deleteCellHandler, COMMAND_PRIORITY_HIGH2));
  }
  tableObserver.listenersToRemove.add(editor.registerCommand(CUT_COMMAND2, (event) => {
    const selection = $getSelection2();
    if (selection) {
      if (!($isTableSelection(selection) || $isRangeSelection2(selection))) {
        return false;
      }
      void copyToClipboard2(editor, objectKlassEquals2(event, ClipboardEvent) ? event : null, $getClipboardDataFromSelection2(selection));
      const intercepted = $deleteCellHandler(event);
      if ($isRangeSelection2(selection)) {
        selection.removeText();
        return true;
      }
      return intercepted;
    }
    return false;
  }, COMMAND_PRIORITY_HIGH2));
  tableObserver.listenersToRemove.add(editor.registerCommand(FORMAT_TEXT_COMMAND2, (payload) => {
    const selection = $getSelection2();
    if (!$isSelectionInTable(selection, tableNode)) {
      return false;
    }
    if ($isTableSelection(selection)) {
      tableObserver.$formatCells(payload);
      return true;
    } else if ($isRangeSelection2(selection)) {
      const tableCellNode = $findMatchingParent3(selection.anchor.getNode(), (n2) => $isTableCellNode(n2));
      if (!$isTableCellNode(tableCellNode)) {
        return false;
      }
    }
    return false;
  }, COMMAND_PRIORITY_HIGH2));
  tableObserver.listenersToRemove.add(editor.registerCommand(FORMAT_ELEMENT_COMMAND2, (formatType) => {
    const selection = $getSelection2();
    if (!$isTableSelection(selection) || !$isSelectionInTable(selection, tableNode)) {
      return false;
    }
    const anchorNode = selection.anchor.getNode();
    const focusNode = selection.focus.getNode();
    if (!$isTableCellNode(anchorNode) || !$isTableCellNode(focusNode)) {
      return false;
    }
    if ($isFullTableSelection(selection, tableNode)) {
      tableNode.setFormat(formatType);
      return true;
    }
    const [tableMap, anchorCell, focusCell] = $computeTableMap(tableNode, anchorNode, focusNode);
    const maxRow = Math.max(anchorCell.startRow + anchorCell.cell.__rowSpan - 1, focusCell.startRow + focusCell.cell.__rowSpan - 1);
    const maxColumn = Math.max(anchorCell.startColumn + anchorCell.cell.__colSpan - 1, focusCell.startColumn + focusCell.cell.__colSpan - 1);
    const minRow = Math.min(anchorCell.startRow, focusCell.startRow);
    const minColumn = Math.min(anchorCell.startColumn, focusCell.startColumn);
    const visited = /* @__PURE__ */ new Set();
    for (let i2 = minRow; i2 <= maxRow; i2++) {
      for (let j = minColumn; j <= maxColumn; j++) {
        const cell = tableMap[i2][j].cell;
        if (visited.has(cell)) {
          continue;
        }
        visited.add(cell);
        cell.setFormat(formatType);
        const cellChildren = cell.getChildren();
        for (let k = 0; k < cellChildren.length; k++) {
          const child = cellChildren[k];
          if ($isElementNode2(child) && !child.isInline()) {
            child.setFormat(formatType);
          }
        }
      }
    }
    return true;
  }, COMMAND_PRIORITY_HIGH2));
  tableObserver.listenersToRemove.add(editor.registerCommand(CONTROLLED_TEXT_INSERTION_COMMAND2, (payload) => {
    const selection = $getSelection2();
    if (!$isSelectionInTable(selection, tableNode)) {
      return false;
    }
    if ($isTableSelection(selection)) {
      tableObserver.$clearHighlight();
      return false;
    } else if ($isRangeSelection2(selection)) {
      const tableCellNode = $findMatchingParent3(selection.anchor.getNode(), (n2) => $isTableCellNode(n2));
      if (!$isTableCellNode(tableCellNode)) {
        return false;
      }
      if (typeof payload === "string") {
        const edgePosition = $getTableEdgeCursorPosition(editor, selection, tableNode);
        if (edgePosition) {
          $insertParagraphAtTableEdge(edgePosition, tableNode, [$createTextNode2(payload)]);
          return true;
        }
      }
    }
    return false;
  }, COMMAND_PRIORITY_HIGH2));
  if (hasTabHandler) {
    tableObserver.listenersToRemove.add(editor.registerCommand(KEY_TAB_COMMAND2, (event) => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection) || !selection.isCollapsed() || !$isSelectionInTable(selection, tableNode)) {
        return false;
      }
      const tableCellNode = $findCellNode(selection.anchor.getNode());
      if (tableCellNode === null || !tableNode.is($findTableNode(tableCellNode))) {
        return false;
      }
      stopEvent(event);
      $selectAdjacentCell(tableCellNode, event.shiftKey ? "previous" : "next");
      return true;
    }, COMMAND_PRIORITY_HIGH2));
  }
  tableObserver.listenersToRemove.add(editor.registerCommand(FOCUS_COMMAND2, (payload) => {
    return tableNode.isSelected();
  }, COMMAND_PRIORITY_HIGH2));
  tableObserver.listenersToRemove.add(editor.registerCommand(SELECTION_INSERT_CLIPBOARD_NODES_COMMAND2, (selectionPayload, dispatchEditor) => {
    if (editor !== dispatchEditor) {
      return false;
    }
    const {
      nodes,
      selection
    } = selectionPayload;
    const anchorAndFocus = selection.getStartEndPoints();
    const isTableSelection = $isTableSelection(selection);
    const isRangeSelection = $isRangeSelection2(selection);
    const isSelectionInsideOfGrid = isRangeSelection && $findMatchingParent3(selection.anchor.getNode(), (n2) => $isTableCellNode(n2)) !== null && $findMatchingParent3(selection.focus.getNode(), (n2) => $isTableCellNode(n2)) !== null || isTableSelection;
    if (nodes.length !== 1 || !$isTableNode(nodes[0]) || !isSelectionInsideOfGrid || anchorAndFocus === null) {
      return false;
    }
    const [anchor, focus] = anchorAndFocus;
    const [anchorCellNode, anchorRowNode, gridNode] = $getNodeTriplet(anchor);
    const focusCellNode = $findMatchingParent3(focus.getNode(), (n2) => $isTableCellNode(n2));
    if (!$isTableCellNode(anchorCellNode) || !$isTableCellNode(focusCellNode) || !$isTableRowNode(anchorRowNode) || !$isTableNode(gridNode)) {
      return false;
    }
    const templateGrid = nodes[0];
    const [initialGridMap, anchorCellMap, focusCellMap] = $computeTableMap(gridNode, anchorCellNode, focusCellNode);
    const [templateGridMap] = $computeTableMapSkipCellCheck(templateGrid, null, null);
    const initialRowCount = initialGridMap.length;
    const initialColCount = initialRowCount > 0 ? initialGridMap[0].length : 0;
    let startRow = anchorCellMap.startRow;
    let startCol = anchorCellMap.startColumn;
    let affectedRowCount = templateGridMap.length;
    let affectedColCount = affectedRowCount > 0 ? templateGridMap[0].length : 0;
    if (isTableSelection) {
      const selectionBoundary = $computeTableCellRectBoundary(initialGridMap, anchorCellMap, focusCellMap);
      const selectionRowCount = selectionBoundary.maxRow - selectionBoundary.minRow + 1;
      const selectionColCount = selectionBoundary.maxColumn - selectionBoundary.minColumn + 1;
      startRow = selectionBoundary.minRow;
      startCol = selectionBoundary.minColumn;
      affectedRowCount = Math.min(affectedRowCount, selectionRowCount);
      affectedColCount = Math.min(affectedColCount, selectionColCount);
    }
    let didPerformMergeOperations = false;
    const lastRowForUnmerge = Math.min(initialRowCount, startRow + affectedRowCount) - 1;
    const lastColForUnmerge = Math.min(initialColCount, startCol + affectedColCount) - 1;
    const unmergedKeys = /* @__PURE__ */ new Set();
    for (let row = startRow; row <= lastRowForUnmerge; row++) {
      for (let col = startCol; col <= lastColForUnmerge; col++) {
        const cellMap = initialGridMap[row][col];
        if (unmergedKeys.has(cellMap.cell.getKey())) {
          continue;
        }
        if (cellMap.cell.__rowSpan === 1 && cellMap.cell.__colSpan === 1) {
          continue;
        }
        $unmergeCellNode(cellMap.cell);
        unmergedKeys.add(cellMap.cell.getKey());
        didPerformMergeOperations = true;
      }
    }
    let [interimGridMap] = $computeTableMapSkipCellCheck(gridNode.getWritable(), null, null);
    const rowsToInsert = affectedRowCount - initialRowCount + startRow;
    for (let i2 = 0; i2 < rowsToInsert; i2++) {
      const cellMap = interimGridMap[initialRowCount - 1][0];
      $insertTableRowAtNode(cellMap.cell);
    }
    const colsToInsert = affectedColCount - initialColCount + startCol;
    for (let i2 = 0; i2 < colsToInsert; i2++) {
      const cellMap = interimGridMap[0][initialColCount - 1];
      $insertTableColumnAtNode(cellMap.cell, true, false);
    }
    [interimGridMap] = $computeTableMapSkipCellCheck(gridNode.getWritable(), null, null);
    for (let row = startRow; row < startRow + affectedRowCount; row++) {
      for (let col = startCol; col < startCol + affectedColCount; col++) {
        const templateRow = row - startRow;
        const templateCol = col - startCol;
        const templateCellMap = templateGridMap[templateRow][templateCol];
        if (templateCellMap.startRow !== templateRow || templateCellMap.startColumn !== templateCol) {
          continue;
        }
        const templateCell = templateCellMap.cell;
        if (templateCell.__rowSpan !== 1 || templateCell.__colSpan !== 1) {
          const cellsToMerge = [];
          const lastRowForMerge = Math.min(row + templateCell.__rowSpan, startRow + affectedRowCount) - 1;
          const lastColForMerge = Math.min(col + templateCell.__colSpan, startCol + affectedColCount) - 1;
          for (let r2 = row; r2 <= lastRowForMerge; r2++) {
            for (let c2 = col; c2 <= lastColForMerge; c2++) {
              const cellMap = interimGridMap[r2][c2];
              cellsToMerge.push(cellMap.cell);
            }
          }
          $mergeCells(cellsToMerge);
          didPerformMergeOperations = true;
        }
        const {
          cell
        } = interimGridMap[row][col];
        const originalChildren = cell.getChildren();
        templateCell.getChildren().forEach((child) => {
          if ($isTextNode2(child)) {
            const paragraphNode = $createParagraphNode2();
            paragraphNode.append(child);
            cell.append(child);
          } else {
            cell.append(child);
          }
        });
        originalChildren.forEach((n2) => n2.remove());
      }
    }
    if (isTableSelection && didPerformMergeOperations) {
      const [finalGridMap] = $computeTableMapSkipCellCheck(gridNode.getWritable(), null, null);
      const newAnchorCellMap = finalGridMap[anchorCellMap.startRow][anchorCellMap.startColumn];
      newAnchorCellMap.cell.selectEnd();
    }
    return true;
  }, COMMAND_PRIORITY_HIGH2));
  tableObserver.listenersToRemove.add(editor.registerCommand(SELECTION_CHANGE_COMMAND2, () => {
    const selection = $getSelection2();
    const prevSelection = $getPreviousSelection2();
    const nextFocus = tableObserver.getAndClearNextFocus();
    if (nextFocus !== null) {
      const {
        focusCell
      } = nextFocus;
      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey) {
        if (focusCell.x === tableObserver.focusX && focusCell.y === tableObserver.focusY) {
          return false;
        } else {
          tableObserver.$setFocusCellForSelection(focusCell);
          return true;
        }
      } else if (focusCell !== tableObserver.anchorCell && $isSelectionInTable(selection, tableNode)) {
        tableObserver.$setFocusCellForSelection(focusCell);
        return true;
      }
    }
    const shouldCheckSelection = tableObserver.getAndClearShouldCheckSelection();
    if (shouldCheckSelection && $isRangeSelection2(prevSelection) && $isRangeSelection2(selection) && selection.isCollapsed()) {
      const anchor = selection.anchor.getNode();
      const firstRow = tableNode.getFirstChild();
      const anchorCell = $findCellNode(anchor);
      if (anchorCell !== null && $isTableRowNode(firstRow)) {
        const firstCell = firstRow.getFirstChild();
        if ($isTableCellNode(firstCell) && tableNode.is($findMatchingParent3(anchorCell, (node) => node.is(tableNode) || node.is(firstCell)))) {
          firstCell.selectStart();
          return true;
        }
      }
    }
    if ($isRangeSelection2(selection)) {
      const {
        anchor,
        focus
      } = selection;
      const anchorNode = anchor.getNode();
      const focusNode = focus.getNode();
      const anchorCellNode = $findCellNode(anchorNode);
      const focusCellNode = $findCellNode(focusNode);
      const isAnchorInside = !!(anchorCellNode && tableNode.is($findTableNode(anchorCellNode)));
      const isFocusInside = !!(focusCellNode && tableNode.is($findTableNode(focusCellNode)));
      const isPartiallyWithinTable = isAnchorInside !== isFocusInside;
      const isWithinTable = isAnchorInside && isFocusInside;
      const isBackward = selection.isBackward();
      if (isPartiallyWithinTable) {
        const newSelection = selection.clone();
        if (isFocusInside) {
          const [tableMap] = $computeTableMap(tableNode, focusCellNode, focusCellNode);
          const firstCell = tableMap[0][0].cell;
          const lastCell = tableMap[tableMap.length - 1].at(-1).cell;
          newSelection.focus.set(isBackward ? firstCell.getKey() : lastCell.getKey(), isBackward ? 0 : lastCell.getChildrenSize(), "element");
        } else if (isAnchorInside) {
          const [tableMap] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);
          const firstCell = tableMap[0][0].cell;
          const lastCell = tableMap[tableMap.length - 1].at(-1).cell;
          newSelection.anchor.set(isBackward ? lastCell.getKey() : firstCell.getKey(), isBackward ? lastCell.getChildrenSize() : 0, "element");
        }
        $setSelection2(newSelection);
        $addHighlightStyleToTable(editor, tableObserver);
      } else if (isWithinTable) {
        if (!anchorCellNode.is(focusCellNode)) {
          tableObserver.$setAnchorCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, anchorCellNode));
          tableObserver.$setFocusCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, focusCellNode), true);
        }
        if (tableObserver.pointerType === "touch" && tableObserver.isSelecting && selection.isCollapsed() && $isRangeSelection2(prevSelection) && prevSelection.isCollapsed()) {
          const prevAnchorCellNode = $findCellNode(prevSelection.anchor.getNode());
          if (prevAnchorCellNode && !prevAnchorCellNode.is(focusCellNode)) {
            tableObserver.$setAnchorCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, prevAnchorCellNode));
            tableObserver.$setFocusCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, focusCellNode), true);
            tableObserver.pointerType = null;
          }
        }
      }
    } else if (selection && $isTableSelection(selection) && selection.is(prevSelection) && selection.tableKey === tableNode.getKey()) {
      const domSelection = getDOMSelection2(editorWindow);
      if (domSelection && domSelection.anchorNode && domSelection.focusNode) {
        const focusNode = $getNearestNodeFromDOMNode2(domSelection.focusNode);
        const isFocusOutside = focusNode && !tableNode.isParentOf(focusNode);
        const anchorNode = $getNearestNodeFromDOMNode2(domSelection.anchorNode);
        const isAnchorInside = anchorNode && tableNode.isParentOf(anchorNode);
        if (isFocusOutside && isAnchorInside && domSelection.rangeCount > 0) {
          const newSelection = $createRangeSelectionFromDom2(domSelection, editor);
          if (newSelection) {
            newSelection.anchor.set(tableNode.getKey(), selection.isBackward() ? tableNode.getChildrenSize() : 0, "element");
            domSelection.removeAllRanges();
            $setSelection2(newSelection);
          }
        }
      }
    }
    if (selection && !selection.is(prevSelection) && ($isTableSelection(selection) || $isTableSelection(prevSelection)) && tableObserver.tableSelection && !tableObserver.tableSelection.is(prevSelection)) {
      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey) {
        tableObserver.$updateTableTableSelection(selection);
      } else if (!$isTableSelection(selection) && $isTableSelection(prevSelection) && prevSelection.tableKey === tableObserver.tableNodeKey) {
        tableObserver.$updateTableTableSelection(null);
      }
      return false;
    }
    if (tableObserver.hasHijackedSelectionStyles && !tableNode.isSelected()) {
      $removeHighlightStyleToTable(editor, tableObserver);
    } else if (!tableObserver.hasHijackedSelectionStyles && tableNode.isSelected()) {
      $addHighlightStyleToTable(editor, tableObserver);
    }
    return false;
  }, COMMAND_PRIORITY_HIGH2));
  tableObserver.listenersToRemove.add(editor.registerCommand(INSERT_PARAGRAPH_COMMAND2, () => {
    const selection = $getSelection2();
    if (!$isRangeSelection2(selection) || !selection.isCollapsed() || !$isSelectionInTable(selection, tableNode)) {
      return false;
    }
    const edgePosition = $getTableEdgeCursorPosition(editor, selection, tableNode);
    if (edgePosition) {
      $insertParagraphAtTableEdge(edgePosition, tableNode);
      return true;
    }
    return false;
  }, COMMAND_PRIORITY_HIGH2));
  return tableObserver;
}
function detachTableObserverFromTableElement(tableElement, tableObserver) {
  if (getTableObserverFromTableElement(tableElement) === tableObserver) {
    delete tableElement[LEXICAL_ELEMENT_KEY];
  }
}
function attachTableObserverToTableElement(tableElement, tableObserver) {
  if (!(getTableObserverFromTableElement(tableElement) === null)) {
    formatDevErrorMessage10(`tableElement already has an attached TableObserver`);
  }
  tableElement[LEXICAL_ELEMENT_KEY] = tableObserver;
}
function getTableObserverFromTableElement(tableElement) {
  return tableElement[LEXICAL_ELEMENT_KEY] || null;
}
function getDOMCellFromTarget(node) {
  let currentNode = node;
  while (currentNode != null) {
    const nodeName = currentNode.nodeName;
    if (nodeName === "TD" || nodeName === "TH") {
      const cell = currentNode._cell;
      if (cell === void 0) {
        return null;
      }
      return cell;
    }
    currentNode = currentNode.parentNode;
  }
  return null;
}
function getDOMCellInTableFromTarget(table, node) {
  if (!table.contains(node)) {
    return null;
  }
  let cell = null;
  for (let currentNode = node; currentNode != null; currentNode = currentNode.parentNode) {
    if (currentNode === table) {
      return cell;
    }
    const nodeName = currentNode.nodeName;
    if (nodeName === "TD" || nodeName === "TH") {
      cell = currentNode._cell || null;
    }
  }
  return null;
}
function getTable(tableNode, dom) {
  const tableElement = getTableElement(tableNode, dom);
  const domRows = [];
  const grid = {
    columns: 0,
    domRows,
    rows: 0
  };
  let currentNode = tableElement.querySelector("tr");
  let x = 0;
  let y2 = 0;
  domRows.length = 0;
  while (currentNode != null) {
    const nodeMame = currentNode.nodeName;
    if (nodeMame === "TD" || nodeMame === "TH") {
      const elem = currentNode;
      const cell = {
        elem,
        hasBackgroundColor: elem.style.backgroundColor !== "",
        highlighted: false,
        x,
        y: y2
      };
      currentNode._cell = cell;
      let row = domRows[y2];
      if (row === void 0) {
        row = domRows[y2] = [];
      }
      row[x] = cell;
    } else {
      const child = currentNode.firstChild;
      if (child != null) {
        currentNode = child;
        continue;
      }
    }
    const sibling = currentNode.nextSibling;
    if (sibling != null) {
      x++;
      currentNode = sibling;
      continue;
    }
    const parent = currentNode.parentNode;
    if (parent != null) {
      const parentSibling = parent.nextSibling;
      if (parentSibling == null) {
        break;
      }
      y2++;
      x = 0;
      currentNode = parentSibling;
    }
  }
  grid.columns = x + 1;
  grid.rows = y2 + 1;
  return grid;
}
function $updateDOMForSelection(editor, table, selection) {
  const selectedCellNodes = new Set(selection ? selection.getNodes() : []);
  $forEachTableCell(table, (cell, lexicalNode) => {
    const elem = cell.elem;
    if (selectedCellNodes.has(lexicalNode)) {
      cell.highlighted = true;
      $addHighlightToDOM(editor, cell);
    } else {
      cell.highlighted = false;
      $removeHighlightFromDOM(editor, cell);
      if (!elem.getAttribute("style")) {
        elem.removeAttribute("style");
      }
    }
  });
}
function $forEachTableCell(grid, cb) {
  const {
    domRows
  } = grid;
  for (let y2 = 0; y2 < domRows.length; y2++) {
    const row = domRows[y2];
    if (!row) {
      continue;
    }
    for (let x = 0; x < row.length; x++) {
      const cell = row[x];
      if (!cell) {
        continue;
      }
      const lexicalNode = $getNearestNodeFromDOMNode2(cell.elem);
      if (lexicalNode !== null) {
        cb(cell, lexicalNode, {
          x,
          y: y2
        });
      }
    }
  }
}
function $addHighlightStyleToTable(editor, tableSelection) {
  tableSelection.$disableHighlightStyle();
  $forEachTableCell(tableSelection.table, (cell) => {
    cell.highlighted = true;
    $addHighlightToDOM(editor, cell);
  });
}
function $removeHighlightStyleToTable(editor, tableObserver) {
  tableObserver.$enableHighlightStyle();
  $forEachTableCell(tableObserver.table, (cell) => {
    const elem = cell.elem;
    cell.highlighted = false;
    $removeHighlightFromDOM(editor, cell);
    if (!elem.getAttribute("style")) {
      elem.removeAttribute("style");
    }
  });
}
function $selectAdjacentCell(tableCellNode, direction) {
  const siblingMethod = direction === "next" ? "getNextSibling" : "getPreviousSibling";
  const childMethod = direction === "next" ? "getFirstChild" : "getLastChild";
  const sibling = tableCellNode[siblingMethod]();
  if ($isElementNode2(sibling)) {
    return sibling.selectEnd();
  }
  const parentRow = $findMatchingParent3(tableCellNode, $isTableRowNode);
  if (!(parentRow !== null)) {
    formatDevErrorMessage10(`selectAdjacentCell: Cell not in table row`);
  }
  for (let nextRow = parentRow[siblingMethod](); $isTableRowNode(nextRow); nextRow = nextRow[siblingMethod]()) {
    const child = nextRow[childMethod]();
    if ($isElementNode2(child)) {
      return child.selectEnd();
    }
  }
  const parentTable = $findMatchingParent3(parentRow, $isTableNode);
  if (!(parentTable !== null)) {
    formatDevErrorMessage10(`selectAdjacentCell: Row not in table`);
  }
  return direction === "next" ? parentTable.selectNext() : parentTable.selectPrevious();
}
var selectTableNodeInDirection = (tableObserver, tableNode, x, y2, direction) => {
  const isForward = direction === "forward";
  switch (direction) {
    case "backward":
    case "forward":
      if (x !== (isForward ? tableObserver.table.columns - 1 : 0)) {
        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x + (isForward ? 1 : -1), y2, tableObserver.table), isForward);
      } else {
        if (y2 !== (isForward ? tableObserver.table.rows - 1 : 0)) {
          selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(isForward ? 0 : tableObserver.table.columns - 1, y2 + (isForward ? 1 : -1), tableObserver.table), isForward);
        } else if (!isForward) {
          tableNode.selectPrevious();
        } else {
          tableNode.selectNext();
        }
      }
      return true;
    case "up":
      if (y2 !== 0) {
        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y2 - 1, tableObserver.table), false);
      } else {
        tableNode.selectPrevious();
      }
      return true;
    case "down":
      if (y2 !== tableObserver.table.rows - 1) {
        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y2 + 1, tableObserver.table), true);
      } else {
        tableNode.selectNext();
      }
      return true;
    default:
      return false;
  }
};
function getCorner(rect, cellValue) {
  let colName;
  let rowName;
  if (cellValue.startColumn === rect.minColumn) {
    colName = "minColumn";
  } else if (cellValue.startColumn + cellValue.cell.__colSpan - 1 === rect.maxColumn) {
    colName = "maxColumn";
  } else {
    return null;
  }
  if (cellValue.startRow === rect.minRow) {
    rowName = "minRow";
  } else if (cellValue.startRow + cellValue.cell.__rowSpan - 1 === rect.maxRow) {
    rowName = "maxRow";
  } else {
    return null;
  }
  return [colName, rowName];
}
function getCornerOrThrow(rect, cellValue) {
  const corner = getCorner(rect, cellValue);
  if (!(corner !== null)) {
    formatDevErrorMessage10(`getCornerOrThrow: cell ${cellValue.cell.getKey()} is not at a corner of rect`);
  }
  return corner;
}
function oppositeCorner([colName, rowName]) {
  return [colName === "minColumn" ? "maxColumn" : "minColumn", rowName === "minRow" ? "maxRow" : "minRow"];
}
function cellAtCornerOrThrow(tableMap, rect, [colName, rowName]) {
  const rowNum = rect[rowName];
  const rowMap = tableMap[rowNum];
  if (!(rowMap !== void 0)) {
    formatDevErrorMessage10(`cellAtCornerOrThrow: ${rowName} = ${String(rowNum)} missing in tableMap`);
  }
  const colNum = rect[colName];
  const cell = rowMap[colNum];
  if (!(cell !== void 0)) {
    formatDevErrorMessage10(`cellAtCornerOrThrow: ${colName} = ${String(colNum)} missing in tableMap`);
  }
  return cell;
}
function $extractRectCorners(tableMap, anchorCellValue, newFocusCellValue) {
  const rect = $computeTableCellRectBoundary(tableMap, anchorCellValue, newFocusCellValue);
  const anchorCorner = getCorner(rect, anchorCellValue);
  if (anchorCorner) {
    return [cellAtCornerOrThrow(tableMap, rect, anchorCorner), cellAtCornerOrThrow(tableMap, rect, oppositeCorner(anchorCorner))];
  }
  const newFocusCorner = getCorner(rect, newFocusCellValue);
  if (newFocusCorner) {
    return [cellAtCornerOrThrow(tableMap, rect, oppositeCorner(newFocusCorner)), cellAtCornerOrThrow(tableMap, rect, newFocusCorner)];
  }
  const newAnchorCorner = ["minColumn", "minRow"];
  return [cellAtCornerOrThrow(tableMap, rect, newAnchorCorner), cellAtCornerOrThrow(tableMap, rect, oppositeCorner(newAnchorCorner))];
}
function $adjustFocusInDirection(tableObserver, tableMap, anchorCellValue, focusCellValue, direction) {
  const rect = $computeTableCellRectBoundary(tableMap, anchorCellValue, focusCellValue);
  const spans = $computeTableCellRectSpans(tableMap, rect);
  const {
    topSpan,
    leftSpan,
    bottomSpan,
    rightSpan
  } = spans;
  const anchorCorner = getCornerOrThrow(rect, anchorCellValue);
  const [focusColumn, focusRow] = oppositeCorner(anchorCorner);
  let fCol = rect[focusColumn];
  let fRow = rect[focusRow];
  if (direction === "forward") {
    fCol += focusColumn === "maxColumn" ? 1 : leftSpan;
  } else if (direction === "backward") {
    fCol -= focusColumn === "minColumn" ? 1 : rightSpan;
  } else if (direction === "down") {
    fRow += focusRow === "maxRow" ? 1 : topSpan;
  } else if (direction === "up") {
    fRow -= focusRow === "minRow" ? 1 : bottomSpan;
  }
  const targetRowMap = tableMap[fRow];
  if (targetRowMap === void 0) {
    return false;
  }
  const newFocusCellValue = targetRowMap[fCol];
  if (newFocusCellValue === void 0) {
    return false;
  }
  const [finalAnchorCell, finalFocusCell] = $extractRectCorners(tableMap, anchorCellValue, newFocusCellValue);
  const anchorDOM = $getObserverCellFromCellNodeOrThrow(tableObserver, finalAnchorCell.cell);
  const focusDOM = $getObserverCellFromCellNodeOrThrow(tableObserver, finalFocusCell.cell);
  tableObserver.$setAnchorCellForSelection(anchorDOM);
  tableObserver.$setFocusCellForSelection(focusDOM, true);
  return true;
}
function $isSelectionInTable(selection, tableNode) {
  if ($isRangeSelection2(selection) || $isTableSelection(selection)) {
    const isAnchorInside = tableNode.isParentOf(selection.anchor.getNode());
    const isFocusInside = tableNode.isParentOf(selection.focus.getNode());
    return isAnchorInside && isFocusInside;
  }
  return false;
}
function $isFullTableSelection(selection, tableNode) {
  if ($isTableSelection(selection)) {
    const anchorNode = selection.anchor.getNode();
    const focusNode = selection.focus.getNode();
    if (tableNode && anchorNode && focusNode) {
      const [map] = $computeTableMap(tableNode, anchorNode, focusNode);
      return anchorNode.getKey() === map[0][0].cell.getKey() && focusNode.getKey() === map[map.length - 1].at(-1).cell.getKey();
    }
  }
  return false;
}
function selectTableCellNode(tableCell, fromStart) {
  if (fromStart) {
    tableCell.selectStart();
  } else {
    tableCell.selectEnd();
  }
}
function $addHighlightToDOM(editor, cell) {
  const element = cell.elem;
  const editorThemeClasses = editor._config.theme;
  const node = $getNearestNodeFromDOMNode2(element);
  if (!$isTableCellNode(node)) {
    formatDevErrorMessage10(`Expected to find LexicalNode from Table Cell DOMNode`);
  }
  addClassNamesToElement2(element, editorThemeClasses.tableCellSelected);
}
function $removeHighlightFromDOM(editor, cell) {
  const element = cell.elem;
  const node = $getNearestNodeFromDOMNode2(element);
  if (!$isTableCellNode(node)) {
    formatDevErrorMessage10(`Expected to find LexicalNode from Table Cell DOMNode`);
  }
  const editorThemeClasses = editor._config.theme;
  removeClassNamesFromElement2(element, editorThemeClasses.tableCellSelected);
}
function $findCellNode(node) {
  const cellNode = $findMatchingParent3(node, $isTableCellNode);
  return $isTableCellNode(cellNode) ? cellNode : null;
}
function $findTableNode(node) {
  const tableNode = $findMatchingParent3(node, $isTableNode);
  return $isTableNode(tableNode) ? tableNode : null;
}
function $getBlockParentIfFirstNode(node) {
  for (let prevNode = node, currentNode = node; currentNode !== null; prevNode = currentNode, currentNode = currentNode.getParent()) {
    if ($isElementNode2(currentNode)) {
      if (currentNode !== prevNode && currentNode.getFirstChild() !== prevNode) {
        return null;
      } else if (!currentNode.isInline()) {
        return currentNode;
      }
    }
  }
  return null;
}
function $handleHorizontalArrowKeyRangeSelection(editor, event, selection, alter, isBackward, tableNode, tableObserver) {
  const initialFocus = $caretFromPoint2(selection.focus, isBackward ? "previous" : "next");
  if ($isExtendableTextPointCaret2(initialFocus)) {
    return false;
  }
  let lastCaret = initialFocus;
  for (const nextCaret of $extendCaretToRange2(initialFocus).iterNodeCarets("shadowRoot")) {
    if (!($isSiblingCaret2(nextCaret) && $isElementNode2(nextCaret.origin))) {
      return false;
    }
    lastCaret = nextCaret;
  }
  const lastCaretParent = lastCaret.getParentAtCaret();
  if (!$isTableCellNode(lastCaretParent)) {
    return false;
  }
  const anchorCell = lastCaretParent;
  const focusCaret = $findNextTableCell($getSiblingCaret2(anchorCell, lastCaret.direction));
  const anchorCellTable = $findMatchingParent3(anchorCell, $isTableNode);
  if (!(anchorCellTable && anchorCellTable.is(tableNode))) {
    return false;
  }
  const anchorCellDOM = editor.getElementByKey(anchorCell.getKey());
  const anchorDOMCell = getDOMCellFromTarget(anchorCellDOM);
  if (!anchorCellDOM || !anchorDOMCell) {
    return false;
  }
  const anchorCellTableElement = $getElementForTableNode(editor, anchorCellTable);
  tableObserver.table = anchorCellTableElement;
  if (!focusCaret) {
    if (alter === "extend") {
      tableObserver.$setAnchorCellForSelection(anchorDOMCell);
      tableObserver.$setFocusCellForSelection(anchorDOMCell, true);
    } else {
      const outerFocusCaret = $getTableExitCaret($getSiblingCaret2(anchorCellTable, initialFocus.direction));
      $setPointFromCaret2(selection.anchor, outerFocusCaret);
      $setPointFromCaret2(selection.focus, outerFocusCaret);
    }
  } else if (alter === "extend") {
    const focusDOMCell = getDOMCellFromTarget(editor.getElementByKey(focusCaret.origin.getKey()));
    if (!focusDOMCell) {
      return false;
    }
    tableObserver.$setAnchorCellForSelection(anchorDOMCell);
    tableObserver.$setFocusCellForSelection(focusDOMCell, true);
  } else {
    const innerFocusCaret = $normalizeCaret2(focusCaret);
    $setPointFromCaret2(selection.anchor, innerFocusCaret);
    $setPointFromCaret2(selection.focus, innerFocusCaret);
  }
  stopEvent(event);
  return true;
}
function $getTableExitCaret(initialCaret) {
  const adjacent = $getAdjacentChildCaret2(initialCaret);
  return $isChildCaret2(adjacent) ? $normalizeCaret2(adjacent) : initialCaret;
}
function $findNextTableCell(initialCaret) {
  for (const nextCaret of $extendCaretToRange2(initialCaret).iterNodeCarets("root")) {
    const {
      origin
    } = nextCaret;
    if ($isTableCellNode(origin)) {
      if ($isChildCaret2(nextCaret)) {
        return $getChildCaret2(origin, initialCaret.direction);
      }
    } else if (!$isTableRowNode(origin)) {
      break;
    }
  }
  return null;
}
function $handleArrowKey(editor, event, direction, tableNode, tableObserver) {
  if ((direction === "up" || direction === "down") && isTypeaheadMenuInView(editor)) {
    return false;
  }
  const selection = $getSelection2();
  if (!$isSelectionInTable(selection, tableNode)) {
    if ($isRangeSelection2(selection)) {
      if (direction === "backward") {
        if (selection.focus.offset > 0) {
          return false;
        }
        const parentNode = $getBlockParentIfFirstNode(selection.focus.getNode());
        if (!parentNode) {
          return false;
        }
        const siblingNode = parentNode.getPreviousSibling();
        if (!$isTableNode(siblingNode)) {
          return false;
        }
        stopEvent(event);
        if (event.shiftKey) {
          selection.focus.set(siblingNode.getParentOrThrow().getKey(), siblingNode.getIndexWithinParent(), "element");
        } else {
          siblingNode.selectEnd();
        }
        return true;
      } else if (event.shiftKey && (direction === "up" || direction === "down")) {
        const focusNode = selection.focus.getNode();
        const isTableUnselect = !selection.isCollapsed() && (direction === "up" && !selection.isBackward() || direction === "down" && selection.isBackward());
        if (isTableUnselect) {
          let focusParentNode = $findMatchingParent3(focusNode, (n2) => $isTableNode(n2));
          if ($isTableCellNode(focusParentNode)) {
            focusParentNode = $findMatchingParent3(focusParentNode, $isTableNode);
          }
          if (focusParentNode !== tableNode) {
            return false;
          }
          if (!focusParentNode) {
            return false;
          }
          const sibling = direction === "down" ? focusParentNode.getNextSibling() : focusParentNode.getPreviousSibling();
          if (!sibling) {
            return false;
          }
          let newOffset = 0;
          if (direction === "up") {
            if ($isElementNode2(sibling)) {
              newOffset = sibling.getChildrenSize();
            }
          }
          let newFocusNode = sibling;
          if (direction === "up") {
            if ($isElementNode2(sibling)) {
              const lastCell = sibling.getLastChild();
              newFocusNode = lastCell ? lastCell : sibling;
              newOffset = $isTextNode2(newFocusNode) ? newFocusNode.getTextContentSize() : 0;
            }
          }
          const newSelection = selection.clone();
          newSelection.focus.set(newFocusNode.getKey(), newOffset, $isTextNode2(newFocusNode) ? "text" : "element");
          $setSelection2(newSelection);
          stopEvent(event);
          return true;
        } else if ($isRootOrShadowRoot2(focusNode)) {
          const selectedNode = direction === "up" ? selection.getNodes()[selection.getNodes().length - 1] : selection.getNodes()[0];
          if (selectedNode) {
            const tableCellNode = $findParentTableCellNodeInTable(tableNode, selectedNode);
            if (tableCellNode !== null) {
              const firstDescendant = tableNode.getFirstDescendant();
              const lastDescendant = tableNode.getLastDescendant();
              if (!firstDescendant || !lastDescendant) {
                return false;
              }
              const [firstCellNode] = $getNodeTriplet(firstDescendant);
              const [lastCellNode] = $getNodeTriplet(lastDescendant);
              const firstCellCoords = tableNode.getCordsFromCellNode(firstCellNode, tableObserver.table);
              const lastCellCoords = tableNode.getCordsFromCellNode(lastCellNode, tableObserver.table);
              const firstCellDOM = tableNode.getDOMCellFromCordsOrThrow(firstCellCoords.x, firstCellCoords.y, tableObserver.table);
              const lastCellDOM = tableNode.getDOMCellFromCordsOrThrow(lastCellCoords.x, lastCellCoords.y, tableObserver.table);
              tableObserver.$setAnchorCellForSelection(firstCellDOM);
              tableObserver.$setFocusCellForSelection(lastCellDOM, true);
              return true;
            }
          }
          return false;
        } else {
          let focusParentNode = $findMatchingParent3(focusNode, (n2) => $isElementNode2(n2) && !n2.isInline());
          if ($isTableCellNode(focusParentNode)) {
            focusParentNode = $findMatchingParent3(focusParentNode, $isTableNode);
          }
          if (!focusParentNode) {
            return false;
          }
          const sibling = direction === "down" ? focusParentNode.getNextSibling() : focusParentNode.getPreviousSibling();
          if ($isTableNode(sibling) && tableObserver.tableNodeKey === sibling.getKey()) {
            const firstDescendant = sibling.getFirstDescendant();
            const lastDescendant = sibling.getLastDescendant();
            if (!firstDescendant || !lastDescendant) {
              return false;
            }
            const [firstCellNode] = $getNodeTriplet(firstDescendant);
            const [lastCellNode] = $getNodeTriplet(lastDescendant);
            const newSelection = selection.clone();
            newSelection.focus.set((direction === "up" ? firstCellNode : lastCellNode).getKey(), direction === "up" ? 0 : lastCellNode.getChildrenSize(), "element");
            stopEvent(event);
            $setSelection2(newSelection);
            return true;
          }
        }
      }
    }
    if (direction === "down" && $isScrollableTablesActive(editor)) {
      tableObserver.setShouldCheckSelection();
    }
    return false;
  }
  if ($isRangeSelection2(selection)) {
    if (direction === "backward" || direction === "forward") {
      const alter = event.shiftKey ? "extend" : "move";
      return $handleHorizontalArrowKeyRangeSelection(editor, event, selection, alter, direction === "backward", tableNode, tableObserver);
    }
    if (selection.isCollapsed()) {
      const {
        anchor,
        focus
      } = selection;
      const anchorCellNode = $findMatchingParent3(anchor.getNode(), $isTableCellNode);
      const focusCellNode = $findMatchingParent3(focus.getNode(), $isTableCellNode);
      if (!$isTableCellNode(anchorCellNode) || !anchorCellNode.is(focusCellNode)) {
        return false;
      }
      const anchorCellTable = $findTableNode(anchorCellNode);
      if (anchorCellTable !== tableNode && anchorCellTable != null) {
        const anchorCellTableElement = getTableElement(anchorCellTable, editor.getElementByKey(anchorCellTable.getKey()));
        if (anchorCellTableElement != null) {
          tableObserver.table = getTable(anchorCellTable, anchorCellTableElement);
          return $handleArrowKey(editor, event, direction, anchorCellTable, tableObserver);
        }
      }
      const anchorCellDom = editor.getElementByKey(anchorCellNode.__key);
      const anchorDOM = editor.getElementByKey(anchor.key);
      if (anchorDOM == null || anchorCellDom == null) {
        return false;
      }
      let edgeSelectionRect;
      if (anchor.type === "element") {
        edgeSelectionRect = anchorDOM.getBoundingClientRect();
      } else {
        const domSelection = getDOMSelection2(getEditorWindow(editor));
        if (domSelection === null || domSelection.rangeCount === 0) {
          return false;
        }
        const range = domSelection.getRangeAt(0);
        edgeSelectionRect = range.getBoundingClientRect();
      }
      const edgeChild = direction === "up" ? anchorCellNode.getFirstChild() : anchorCellNode.getLastChild();
      if (edgeChild == null) {
        return false;
      }
      const edgeChildDOM = editor.getElementByKey(edgeChild.__key);
      if (edgeChildDOM == null) {
        return false;
      }
      const edgeRect = edgeChildDOM.getBoundingClientRect();
      const isExiting = direction === "up" ? edgeRect.top > edgeSelectionRect.top - edgeSelectionRect.height : edgeSelectionRect.bottom + edgeSelectionRect.height > edgeRect.bottom;
      if (isExiting) {
        stopEvent(event);
        const cords = tableNode.getCordsFromCellNode(anchorCellNode, tableObserver.table);
        if (event.shiftKey) {
          const cell = tableNode.getDOMCellFromCordsOrThrow(cords.x, cords.y, tableObserver.table);
          tableObserver.$setAnchorCellForSelection(cell);
          tableObserver.$setFocusCellForSelection(cell, true);
        } else {
          return selectTableNodeInDirection(tableObserver, tableNode, cords.x, cords.y, direction);
        }
        return true;
      }
    }
  } else if ($isTableSelection(selection)) {
    const {
      anchor,
      focus
    } = selection;
    const anchorCellNode = $findMatchingParent3(anchor.getNode(), $isTableCellNode);
    const focusCellNode = $findMatchingParent3(focus.getNode(), $isTableCellNode);
    const [tableNodeFromSelection] = selection.getNodes();
    if (!$isTableNode(tableNodeFromSelection)) {
      formatDevErrorMessage10(`$handleArrowKey: TableSelection.getNodes()[0] expected to be TableNode`);
    }
    const tableElement = getTableElement(tableNodeFromSelection, editor.getElementByKey(tableNodeFromSelection.getKey()));
    if (!$isTableCellNode(anchorCellNode) || !$isTableCellNode(focusCellNode) || !$isTableNode(tableNodeFromSelection) || tableElement == null) {
      return false;
    }
    tableObserver.$updateTableTableSelection(selection);
    const grid = getTable(tableNodeFromSelection, tableElement);
    const cordsAnchor = tableNode.getCordsFromCellNode(anchorCellNode, grid);
    const anchorCell = tableNode.getDOMCellFromCordsOrThrow(cordsAnchor.x, cordsAnchor.y, grid);
    tableObserver.$setAnchorCellForSelection(anchorCell);
    stopEvent(event);
    if (event.shiftKey) {
      const [tableMap, anchorValue, focusValue] = $computeTableMap(tableNode, anchorCellNode, focusCellNode);
      return $adjustFocusInDirection(tableObserver, tableMap, anchorValue, focusValue, direction);
    } else {
      focusCellNode.selectEnd();
    }
    return true;
  }
  return false;
}
function stopEvent(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
  event.stopPropagation();
}
function isTypeaheadMenuInView(editor) {
  const root = editor.getRootElement();
  if (!root) {
    return false;
  }
  return root.hasAttribute("aria-controls") && root.getAttribute("aria-controls") === "typeahead-menu";
}
function $insertParagraphAtTableEdge(edgePosition, tableNode, children) {
  const paragraphNode = $createParagraphNode2();
  if (edgePosition === "first") {
    tableNode.insertBefore(paragraphNode);
  } else {
    tableNode.insertAfter(paragraphNode);
  }
  paragraphNode.append(...children || []);
  paragraphNode.selectEnd();
}
function $getTableEdgeCursorPosition(editor, selection, tableNode) {
  const tableNodeParent = tableNode.getParent();
  if (!tableNodeParent) {
    return void 0;
  }
  const domSelection = getDOMSelection2(getEditorWindow(editor));
  if (!domSelection) {
    return void 0;
  }
  const domAnchorNode = domSelection.anchorNode;
  const tableNodeParentDOM = editor.getElementByKey(tableNodeParent.getKey());
  const tableElement = getTableElement(tableNode, editor.getElementByKey(tableNode.getKey()));
  if (!domAnchorNode || !tableNodeParentDOM || !tableElement || !tableNodeParentDOM.contains(domAnchorNode) || tableElement.contains(domAnchorNode)) {
    return void 0;
  }
  const anchorCellNode = $findMatchingParent3(selection.anchor.getNode(), (n2) => $isTableCellNode(n2));
  if (!anchorCellNode) {
    return void 0;
  }
  const parentTable = $findMatchingParent3(anchorCellNode, (n2) => $isTableNode(n2));
  if (!$isTableNode(parentTable) || !parentTable.is(tableNode)) {
    return void 0;
  }
  const [tableMap, cellValue] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);
  const firstCell = tableMap[0][0];
  const lastCell = tableMap[tableMap.length - 1][tableMap[0].length - 1];
  const {
    startRow,
    startColumn
  } = cellValue;
  const isAtFirstCell = startRow === firstCell.startRow && startColumn === firstCell.startColumn;
  const isAtLastCell = startRow === lastCell.startRow && startColumn === lastCell.startColumn;
  if (isAtFirstCell) {
    return "first";
  } else if (isAtLastCell) {
    return "last";
  } else {
    return void 0;
  }
}
function $getObserverCellFromCellNodeOrThrow(tableObserver, tableCellNode) {
  const {
    tableNode
  } = tableObserver.$lookup();
  const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableObserver.table);
  return tableNode.getDOMCellFromCordsOrThrow(currentCords.x, currentCords.y, tableObserver.table);
}
function $getNearestTableCellInTableFromDOMNode(tableNode, startingDOM, editorState) {
  return $findParentTableCellNodeInTable(tableNode, $getNearestNodeFromDOMNode2(startingDOM, editorState));
}
function isHTMLDivElement(element) {
  return isHTMLElement3(element) && element.nodeName === "DIV";
}
function updateColgroup(dom, config, colCount, colWidths) {
  const colGroup = dom.querySelector("colgroup");
  if (!colGroup) {
    return;
  }
  const cols = [];
  for (let i2 = 0; i2 < colCount; i2++) {
    const col = document.createElement("col");
    const width = colWidths && colWidths[i2];
    if (width) {
      col.style.width = `${width}px`;
    }
    cols.push(col);
  }
  colGroup.replaceChildren(...cols);
}
function setRowStriping(dom, config, rowStriping) {
  if (rowStriping) {
    addClassNamesToElement2(dom, config.theme.tableRowStriping);
    dom.setAttribute("data-lexical-row-striping", "true");
  } else {
    removeClassNamesFromElement2(dom, config.theme.tableRowStriping);
    dom.removeAttribute("data-lexical-row-striping");
  }
}
function setFrozenColumns(dom, tableElement, config, frozenColumnCount) {
  if (frozenColumnCount > 0) {
    addClassNamesToElement2(dom, config.theme.tableFrozenColumn);
    tableElement.setAttribute("data-lexical-frozen-column", "true");
  } else {
    removeClassNamesFromElement2(dom, config.theme.tableFrozenColumn);
    tableElement.removeAttribute("data-lexical-frozen-column");
  }
}
function setFrozenRows(dom, tableElement, config, frozenRowCount) {
  if (frozenRowCount > 0) {
    addClassNamesToElement2(dom, config.theme.tableFrozenRow);
    tableElement.setAttribute("data-lexical-frozen-row", "true");
  } else {
    removeClassNamesFromElement2(dom, config.theme.tableFrozenRow);
    tableElement.removeAttribute("data-lexical-frozen-row");
  }
}
function alignTableElement(dom, config, formatType) {
  if (!config.theme.tableAlignment) {
    return;
  }
  const removeClasses = [];
  const addClasses = [];
  for (const format of ["center", "right"]) {
    const classes = config.theme.tableAlignment[format];
    if (!classes) {
      continue;
    }
    (format === formatType ? addClasses : removeClasses).push(classes);
  }
  removeClassNamesFromElement2(dom, ...removeClasses);
  addClassNamesToElement2(dom, ...addClasses);
}
var scrollableEditors = /* @__PURE__ */ new WeakSet();
function $isScrollableTablesActive(editor = $getEditor2()) {
  return scrollableEditors.has(editor);
}
function setScrollableTablesActive(editor, active) {
  if (active) {
    if (!editor._config.theme.tableScrollableWrapper) {
      console.warn("TableNode: hasHorizontalScroll is active but theme.tableScrollableWrapper is not defined.");
    }
    scrollableEditors.add(editor);
  } else {
    scrollableEditors.delete(editor);
  }
}
var TableNode = class _TableNode extends ElementNode2 {
  constructor(key) {
    super(key);
    /** @internal */
    __publicField(this, "__rowStriping");
    __publicField(this, "__frozenColumnCount");
    __publicField(this, "__frozenRowCount");
    __publicField(this, "__colWidths");
    this.__rowStriping = false;
    this.__frozenColumnCount = 0;
    this.__frozenRowCount = 0;
    this.__colWidths = void 0;
  }
  static getType() {
    return "table";
  }
  getColWidths() {
    const self2 = this.getLatest();
    return self2.__colWidths;
  }
  setColWidths(colWidths) {
    const self2 = this.getWritable();
    self2.__colWidths = colWidths !== void 0 && true ? Object.freeze(colWidths) : colWidths;
    return self2;
  }
  static clone(node) {
    return new _TableNode(node.__key);
  }
  afterCloneFrom(prevNode) {
    super.afterCloneFrom(prevNode);
    this.__colWidths = prevNode.__colWidths;
    this.__rowStriping = prevNode.__rowStriping;
    this.__frozenColumnCount = prevNode.__frozenColumnCount;
    this.__frozenRowCount = prevNode.__frozenRowCount;
  }
  static importDOM() {
    return {
      table: (_node) => ({
        conversion: $convertTableElement2,
        priority: 1
      })
    };
  }
  static importJSON(serializedNode) {
    return $createTableNode().updateFromJSON(serializedNode);
  }
  updateFromJSON(serializedNode) {
    return super.updateFromJSON(serializedNode).setRowStriping(serializedNode.rowStriping || false).setFrozenColumns(serializedNode.frozenColumnCount || 0).setFrozenRows(serializedNode.frozenRowCount || 0).setColWidths(serializedNode.colWidths);
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      colWidths: this.getColWidths(),
      frozenColumnCount: this.__frozenColumnCount ? this.__frozenColumnCount : void 0,
      frozenRowCount: this.__frozenRowCount ? this.__frozenRowCount : void 0,
      rowStriping: this.__rowStriping ? this.__rowStriping : void 0
    };
  }
  extractWithChild(child, selection, destination) {
    return destination === "html";
  }
  getDOMSlot(element) {
    const tableElement = !isHTMLTableElement(element) ? element.querySelector("table") : element;
    if (!isHTMLTableElement(tableElement)) {
      formatDevErrorMessage10(`TableNode.getDOMSlot: createDOM() did not return a table`);
    }
    return super.getDOMSlot(element).withElement(tableElement).withAfter(tableElement.querySelector("colgroup"));
  }
  createDOM(config, editor) {
    const tableElement = document.createElement("table");
    if (this.__style) {
      tableElement.style.cssText = this.__style;
    }
    const colGroup = document.createElement("colgroup");
    tableElement.appendChild(colGroup);
    setDOMUnmanaged2(colGroup);
    addClassNamesToElement2(tableElement, config.theme.table);
    this.updateTableElement(null, tableElement, config);
    if ($isScrollableTablesActive(editor)) {
      const wrapperElement = document.createElement("div");
      const classes = config.theme.tableScrollableWrapper;
      if (classes) {
        addClassNamesToElement2(wrapperElement, classes);
      } else {
        wrapperElement.style.cssText = "overflow-x: auto;";
      }
      wrapperElement.appendChild(tableElement);
      this.updateTableWrapper(null, wrapperElement, tableElement, config);
      return wrapperElement;
    }
    return tableElement;
  }
  updateTableWrapper(prevNode, tableWrapper, tableElement, config) {
    if (this.__frozenColumnCount !== (prevNode ? prevNode.__frozenColumnCount : 0)) {
      setFrozenColumns(tableWrapper, tableElement, config, this.__frozenColumnCount);
    }
    if (this.__frozenRowCount !== (prevNode ? prevNode.__frozenRowCount : 0)) {
      setFrozenRows(tableWrapper, tableElement, config, this.__frozenRowCount);
    }
  }
  updateTableElement(prevNode, tableElement, config) {
    if (this.__style !== (prevNode ? prevNode.__style : "")) {
      tableElement.style.cssText = this.__style;
    }
    if (this.__rowStriping !== (prevNode ? prevNode.__rowStriping : false)) {
      setRowStriping(tableElement, config, this.__rowStriping);
    }
    updateColgroup(tableElement, config, this.getColumnCount(), this.getColWidths());
    alignTableElement(tableElement, config, this.getFormatType());
  }
  updateDOM(prevNode, dom, config) {
    const slot = this.getDOMSlot(dom);
    const tableElement = slot.element;
    if (dom === tableElement === $isScrollableTablesActive()) {
      return true;
    }
    if (isHTMLDivElement(dom)) {
      this.updateTableWrapper(prevNode, dom, tableElement, config);
    }
    this.updateTableElement(prevNode, tableElement, config);
    return false;
  }
  exportDOM(editor) {
    const superExport = super.exportDOM(editor);
    const {
      element
    } = superExport;
    return {
      after: (tableElement) => {
        if (superExport.after) {
          tableElement = superExport.after(tableElement);
        }
        if (!isHTMLTableElement(tableElement) && isHTMLElement3(tableElement)) {
          tableElement = tableElement.querySelector("table");
        }
        if (!isHTMLTableElement(tableElement)) {
          return null;
        }
        alignTableElement(tableElement, editor._config, this.getFormatType());
        const [tableMap] = $computeTableMapSkipCellCheck(this, null, null);
        const cellValues = /* @__PURE__ */ new Map();
        for (const mapRow of tableMap) {
          for (const mapValue of mapRow) {
            const key = mapValue.cell.getKey();
            if (!cellValues.has(key)) {
              cellValues.set(key, {
                colSpan: mapValue.cell.getColSpan(),
                startColumn: mapValue.startColumn
              });
            }
          }
        }
        const knownColumns = /* @__PURE__ */ new Set();
        for (const cellDOM of tableElement.querySelectorAll(":scope > tr > [data-temporary-table-cell-lexical-key]")) {
          const key = cellDOM.getAttribute("data-temporary-table-cell-lexical-key");
          if (key) {
            const cellSpan = cellValues.get(key);
            cellDOM.removeAttribute("data-temporary-table-cell-lexical-key");
            if (cellSpan) {
              cellValues.delete(key);
              for (let i2 = 0; i2 < cellSpan.colSpan; i2++) {
                knownColumns.add(i2 + cellSpan.startColumn);
              }
            }
          }
        }
        const colGroup = tableElement.querySelector(":scope > colgroup");
        if (colGroup) {
          const cols = Array.from(tableElement.querySelectorAll(":scope > colgroup > col")).filter((dom, i2) => knownColumns.has(i2));
          colGroup.replaceChildren(...cols);
        }
        const rows = tableElement.querySelectorAll(":scope > tr");
        if (rows.length > 0) {
          const tBody = document.createElement("tbody");
          for (const row of rows) {
            tBody.appendChild(row);
          }
          tableElement.append(tBody);
        }
        return tableElement;
      },
      element: !isHTMLTableElement(element) && isHTMLElement3(element) ? element.querySelector("table") : element
    };
  }
  canBeEmpty() {
    return false;
  }
  isShadowRoot() {
    return true;
  }
  getCordsFromCellNode(tableCellNode, table) {
    const {
      rows,
      domRows
    } = table;
    for (let y2 = 0; y2 < rows; y2++) {
      const row = domRows[y2];
      if (row == null) {
        continue;
      }
      for (let x = 0; x < row.length; x++) {
        const cell = row[x];
        if (cell == null) {
          continue;
        }
        const {
          elem
        } = cell;
        const cellNode = $getNearestTableCellInTableFromDOMNode(this, elem);
        if (cellNode !== null && tableCellNode.is(cellNode)) {
          return {
            x,
            y: y2
          };
        }
      }
    }
    throw new Error("Cell not found in table.");
  }
  getDOMCellFromCords(x, y2, table) {
    const {
      domRows
    } = table;
    const row = domRows[y2];
    if (row == null) {
      return null;
    }
    const index = x < row.length ? x : row.length - 1;
    const cell = row[index];
    if (cell == null) {
      return null;
    }
    return cell;
  }
  getDOMCellFromCordsOrThrow(x, y2, table) {
    const cell = this.getDOMCellFromCords(x, y2, table);
    if (!cell) {
      throw new Error("Cell not found at cords.");
    }
    return cell;
  }
  getCellNodeFromCords(x, y2, table) {
    const cell = this.getDOMCellFromCords(x, y2, table);
    if (cell == null) {
      return null;
    }
    const node = $getNearestNodeFromDOMNode2(cell.elem);
    if ($isTableCellNode(node)) {
      return node;
    }
    return null;
  }
  getCellNodeFromCordsOrThrow(x, y2, table) {
    const node = this.getCellNodeFromCords(x, y2, table);
    if (!node) {
      throw new Error("Node at cords not TableCellNode.");
    }
    return node;
  }
  getRowStriping() {
    return Boolean(this.getLatest().__rowStriping);
  }
  setRowStriping(newRowStriping) {
    const self2 = this.getWritable();
    self2.__rowStriping = newRowStriping;
    return self2;
  }
  setFrozenColumns(columnCount) {
    const self2 = this.getWritable();
    self2.__frozenColumnCount = columnCount;
    return self2;
  }
  getFrozenColumns() {
    return this.getLatest().__frozenColumnCount;
  }
  setFrozenRows(rowCount) {
    const self2 = this.getWritable();
    self2.__frozenRowCount = rowCount;
    return self2;
  }
  getFrozenRows() {
    return this.getLatest().__frozenRowCount;
  }
  canSelectBefore() {
    return true;
  }
  canIndent() {
    return false;
  }
  getColumnCount() {
    const firstRow = this.getFirstChild();
    if (!firstRow) {
      return 0;
    }
    let columnCount = 0;
    firstRow.getChildren().forEach((cell) => {
      if ($isTableCellNode(cell)) {
        columnCount += cell.getColSpan();
      }
    });
    return columnCount;
  }
};
function $getElementForTableNode(editor, tableNode) {
  const tableElement = editor.getElementByKey(tableNode.getKey());
  if (!(tableElement !== null)) {
    formatDevErrorMessage10(`$getElementForTableNode: Table Element Not Found`);
  }
  return getTable(tableNode, tableElement);
}
function $convertTableElement2(domNode) {
  const tableNode = $createTableNode();
  if (domNode.hasAttribute("data-lexical-row-striping")) {
    tableNode.setRowStriping(true);
  }
  if (domNode.hasAttribute("data-lexical-frozen-column")) {
    tableNode.setFrozenColumns(1);
  }
  if (domNode.hasAttribute("data-lexical-frozen-row")) {
    tableNode.setFrozenRows(1);
  }
  const colGroup = domNode.querySelector(":scope > colgroup");
  if (colGroup) {
    let columns = [];
    for (const col of colGroup.querySelectorAll(":scope > col")) {
      let width = col.style.width || "";
      if (!PIXEL_VALUE_REG_EXP.test(width)) {
        width = col.getAttribute("width") || "";
        if (!/^\d+$/.test(width)) {
          columns = void 0;
          break;
        }
      }
      columns.push(parseFloat(width));
    }
    if (columns) {
      tableNode.setColWidths(columns);
    }
  }
  return {
    after: (children) => $descendantsMatching2(children, $isTableRowNode),
    node: tableNode
  };
}
function $createTableNode() {
  return $applyNodeReplacement2(new TableNode());
}
function $isTableNode(node) {
  return node instanceof TableNode;
}
function $insertTable({
  rows,
  columns,
  includeHeaders
}, hasNestedTables) {
  const selection = $getSelection2() || $getPreviousSelection2();
  if (!selection || !$isRangeSelection2(selection)) {
    return false;
  }
  if (!hasNestedTables && $findTableNode(selection.anchor.getNode())) {
    return false;
  }
  const tableNode = $createTableNodeWithDimensions(Number(rows), Number(columns), includeHeaders);
  $insertNodeToNearestRoot2(tableNode);
  const firstDescendant = tableNode.getFirstDescendant();
  if ($isTextNode2(firstDescendant)) {
    firstDescendant.select();
  }
  return true;
}
function $tableCellTransform(node) {
  if (!$isTableRowNode(node.getParent())) {
    node.remove();
  } else if (node.isEmpty()) {
    node.append($createParagraphNode2());
  }
}
function $tableRowTransform(node) {
  if (!$isTableNode(node.getParent())) {
    node.remove();
  } else {
    $unwrapAndFilterDescendants2(node, $isTableCellNode);
  }
}
function $tableTransform(node) {
  $unwrapAndFilterDescendants2(node, $isTableRowNode);
  const [gridMap] = $computeTableMapSkipCellCheck(node, null, null);
  const maxRowLength = gridMap.reduce((curLength, row) => {
    return Math.max(curLength, row.length);
  }, 0);
  const rowNodes = node.getChildren();
  for (let i2 = 0; i2 < gridMap.length; ++i2) {
    const rowNode = rowNodes[i2];
    if (!rowNode) {
      continue;
    }
    if (!$isTableRowNode(rowNode)) {
      formatDevErrorMessage10(`TablePlugin: Expecting all children of TableNode to be TableRowNode, found ${rowNode.constructor.name} (type ${rowNode.getType()})`);
    }
    const rowLength = gridMap[i2].reduce((acc, cell) => cell ? 1 + acc : acc, 0);
    if (rowLength === maxRowLength) {
      continue;
    }
    for (let j = rowLength; j < maxRowLength; ++j) {
      const newCell = $createTableCellNode();
      newCell.append($createParagraphNode2());
      rowNode.append(newCell);
    }
  }
  const colWidths = node.getColWidths();
  const columnCount = node.getColumnCount();
  if (colWidths && colWidths.length !== columnCount) {
    let newColWidths = void 0;
    if (columnCount < colWidths.length) {
      newColWidths = colWidths.slice(0, columnCount);
    } else if (colWidths.length > 0) {
      const fillWidth = colWidths[colWidths.length - 1];
      newColWidths = [...colWidths, ...Array(columnCount - colWidths.length).fill(fillWidth)];
    }
    node.setColWidths(newColWidths);
  }
}
function $tableClickCommand(event) {
  if (event.detail < 3 || !isDOMNode2(event.target)) {
    return false;
  }
  const startNode = $getNearestNodeFromDOMNode2(event.target);
  if (startNode === null) {
    return false;
  }
  const blockNode = $findMatchingParent3(startNode, (node) => $isElementNode2(node) && !node.isInline());
  if (blockNode === null) {
    return false;
  }
  const rootNode = blockNode.getParent();
  if (!$isTableCellNode(rootNode)) {
    return false;
  }
  blockNode.select(0);
  return true;
}
function registerTableCellUnmergeTransform(editor) {
  return editor.registerNodeTransform(TableCellNode, (node) => {
    if (node.getColSpan() > 1 || node.getRowSpan() > 1) {
      const [, , gridNode] = $getNodeTriplet(node);
      const [gridMap] = $computeTableMap(gridNode, node, node);
      const rowsCount = gridMap.length;
      const columnsCount = gridMap[0].length;
      let row = gridNode.getFirstChild();
      if (!$isTableRowNode(row)) {
        formatDevErrorMessage10(`Expected TableNode first child to be a RowNode`);
      }
      const unmerged = [];
      for (let i2 = 0; i2 < rowsCount; i2++) {
        if (i2 !== 0) {
          row = row.getNextSibling();
          if (!$isTableRowNode(row)) {
            formatDevErrorMessage10(`Expected TableNode first child to be a RowNode`);
          }
        }
        let lastRowCell = null;
        for (let j = 0; j < columnsCount; j++) {
          const cellMap = gridMap[i2][j];
          const cell = cellMap.cell;
          if (cellMap.startRow === i2 && cellMap.startColumn === j) {
            lastRowCell = cell;
            unmerged.push(cell);
          } else if (cell.getColSpan() > 1 || cell.getRowSpan() > 1) {
            if (!$isTableCellNode(cell)) {
              formatDevErrorMessage10(`Expected TableNode cell to be a TableCellNode`);
            }
            const newCell = $createTableCellNode(cell.__headerState);
            if (lastRowCell !== null) {
              lastRowCell.insertAfter(newCell);
            } else {
              $insertFirst2(row, newCell);
            }
          }
        }
      }
      for (const cell of unmerged) {
        cell.setColSpan(1);
        cell.setRowSpan(1);
      }
    }
  });
}
function registerTableSelectionObserver(editor, hasTabHandler = true) {
  const tableSelections = /* @__PURE__ */ new Map();
  const initializeTableNode = (tableNode, nodeKey, dom) => {
    const tableElement = getTableElement(tableNode, dom);
    const tableSelection = applyTableHandlers(tableNode, tableElement, editor, hasTabHandler);
    tableSelections.set(nodeKey, [tableSelection, tableElement]);
  };
  const unregisterMutationListener = editor.registerMutationListener(TableNode, (nodeMutations) => {
    editor.getEditorState().read(() => {
      for (const [nodeKey, mutation] of nodeMutations) {
        const tableSelection = tableSelections.get(nodeKey);
        if (mutation === "created" || mutation === "updated") {
          const {
            tableNode,
            tableElement
          } = $getTableAndElementByKey(nodeKey);
          if (tableSelection === void 0) {
            initializeTableNode(tableNode, nodeKey, tableElement);
          } else if (tableElement !== tableSelection[1]) {
            tableSelection[0].removeListeners();
            tableSelections.delete(nodeKey);
            initializeTableNode(tableNode, nodeKey, tableElement);
          }
        } else if (mutation === "destroyed") {
          if (tableSelection !== void 0) {
            tableSelection[0].removeListeners();
            tableSelections.delete(nodeKey);
          }
        }
      }
    }, {
      editor
    });
  }, {
    skipInitialization: false
  });
  return () => {
    unregisterMutationListener();
    for (const [, [tableSelection]] of tableSelections) {
      tableSelection.removeListeners();
    }
  };
}
function registerTablePlugin(editor, options) {
  if (!editor.hasNodes([TableNode])) {
    {
      formatDevErrorMessage10(`TablePlugin: TableNode is not registered on editor`);
    }
  }
  const {
    hasNestedTables = signal(false)
  } = options ?? {};
  return mergeRegister2(editor.registerCommand(INSERT_TABLE_COMMAND, (payload) => {
    return $insertTable(payload, hasNestedTables.peek());
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(SELECTION_INSERT_CLIPBOARD_NODES_COMMAND2, ({
    nodes,
    selection
  }, dispatchEditor) => {
    if (hasNestedTables.peek() || editor !== dispatchEditor || !$isRangeSelection2(selection)) {
      return false;
    }
    const isInsideTableCell = $findTableNode(selection.anchor.getNode()) !== null;
    return isInsideTableCell && nodes.some($isTableNode);
  }, COMMAND_PRIORITY_EDITOR2), editor.registerCommand(CLICK_COMMAND2, $tableClickCommand, COMMAND_PRIORITY_EDITOR2), editor.registerNodeTransform(TableNode, $tableTransform), editor.registerNodeTransform(TableRowNode, $tableRowTransform), editor.registerNodeTransform(TableCellNode, $tableCellTransform));
}
var TableExtension = defineExtension2({
  build(editor, config, state) {
    return namedSignals2(config);
  },
  config: safeCast2({
    hasCellBackgroundColor: true,
    hasCellMerge: true,
    hasHorizontalScroll: true,
    hasNestedTables: false,
    hasTabHandler: true
  }),
  name: "@lexical/table/Table",
  nodes: () => [TableNode, TableRowNode, TableCellNode],
  register(editor, config, state) {
    const stores = state.getOutput();
    const {
      hasNestedTables
    } = stores;
    return mergeRegister2(effect(() => {
      const hasHorizontalScroll = stores.hasHorizontalScroll.value;
      const hadHorizontalScroll = $isScrollableTablesActive(editor);
      if (hadHorizontalScroll !== hasHorizontalScroll) {
        setScrollableTablesActive(editor, hasHorizontalScroll);
        editor.registerNodeTransform(TableNode, () => {
        })();
      }
    }), registerTablePlugin(editor, {
      hasNestedTables
    }), effect(() => registerTableSelectionObserver(editor, stores.hasTabHandler.value)), effect(() => stores.hasCellMerge.value ? void 0 : registerTableCellUnmergeTransform(editor)), effect(() => stores.hasCellBackgroundColor.value ? void 0 : editor.registerNodeTransform(TableCellNode, (node) => {
      if (node.getBackgroundColor() !== null) {
        node.setBackgroundColor(null);
      }
    })));
  }
});

// node_modules/@lexical/table/LexicalTable.mjs
var mod15 = true ? LexicalTable_dev_exports : LexicalTable_prod_exports;
var $computeTableMap2 = mod15.$computeTableMap;
var $computeTableMapSkipCellCheck2 = mod15.$computeTableMapSkipCellCheck;
var $createTableCellNode2 = mod15.$createTableCellNode;
var $createTableNode2 = mod15.$createTableNode;
var $createTableNodeWithDimensions2 = mod15.$createTableNodeWithDimensions;
var $createTableRowNode2 = mod15.$createTableRowNode;
var $createTableSelection2 = mod15.$createTableSelection;
var $createTableSelectionFrom2 = mod15.$createTableSelectionFrom;
var $deleteTableColumn2 = mod15.$deleteTableColumn;
var $deleteTableColumnAtSelection2 = mod15.$deleteTableColumnAtSelection;
var $deleteTableColumn__EXPERIMENTAL2 = mod15.$deleteTableColumn__EXPERIMENTAL;
var $deleteTableRowAtSelection2 = mod15.$deleteTableRowAtSelection;
var $deleteTableRow__EXPERIMENTAL2 = mod15.$deleteTableRow__EXPERIMENTAL;
var $findCellNode2 = mod15.$findCellNode;
var $findTableNode2 = mod15.$findTableNode;
var $getElementForTableNode2 = mod15.$getElementForTableNode;
var $getNodeTriplet2 = mod15.$getNodeTriplet;
var $getTableAndElementByKey2 = mod15.$getTableAndElementByKey;
var $getTableCellNodeFromLexicalNode2 = mod15.$getTableCellNodeFromLexicalNode;
var $getTableCellNodeRect2 = mod15.$getTableCellNodeRect;
var $getTableColumnIndexFromTableCellNode2 = mod15.$getTableColumnIndexFromTableCellNode;
var $getTableNodeFromLexicalNodeOrThrow2 = mod15.$getTableNodeFromLexicalNodeOrThrow;
var $getTableRowIndexFromTableCellNode2 = mod15.$getTableRowIndexFromTableCellNode;
var $getTableRowNodeFromTableCellNodeOrThrow2 = mod15.$getTableRowNodeFromTableCellNodeOrThrow;
var $insertTableColumn2 = mod15.$insertTableColumn;
var $insertTableColumnAtSelection2 = mod15.$insertTableColumnAtSelection;
var $insertTableColumn__EXPERIMENTAL2 = mod15.$insertTableColumn__EXPERIMENTAL;
var $insertTableRow2 = mod15.$insertTableRow;
var $insertTableRowAtSelection2 = mod15.$insertTableRowAtSelection;
var $insertTableRow__EXPERIMENTAL2 = mod15.$insertTableRow__EXPERIMENTAL;
var $isScrollableTablesActive2 = mod15.$isScrollableTablesActive;
var $isTableCellNode2 = mod15.$isTableCellNode;
var $isTableNode2 = mod15.$isTableNode;
var $isTableRowNode2 = mod15.$isTableRowNode;
var $isTableSelection2 = mod15.$isTableSelection;
var $mergeCells2 = mod15.$mergeCells;
var $removeTableRowAtIndex2 = mod15.$removeTableRowAtIndex;
var $unmergeCell2 = mod15.$unmergeCell;
var INSERT_TABLE_COMMAND2 = mod15.INSERT_TABLE_COMMAND;
var TableCellHeaderStates2 = mod15.TableCellHeaderStates;
var TableCellNode2 = mod15.TableCellNode;
var TableExtension2 = mod15.TableExtension;
var TableNode2 = mod15.TableNode;
var TableObserver2 = mod15.TableObserver;
var TableRowNode2 = mod15.TableRowNode;
var applyTableHandlers2 = mod15.applyTableHandlers;
var getDOMCellFromTarget2 = mod15.getDOMCellFromTarget;
var getTableElement2 = mod15.getTableElement;
var getTableObserverFromTableElement2 = mod15.getTableObserverFromTableElement;
var registerTableCellUnmergeTransform2 = mod15.registerTableCellUnmergeTransform;
var registerTablePlugin2 = mod15.registerTablePlugin;
var registerTableSelectionObserver2 = mod15.registerTableSelectionObserver;
var setScrollableTablesActive2 = mod15.setScrollableTablesActive;

// resources/js/toolbar-context.ts
var MIN_ALLOWED_FONT_SIZE = 8;
var MAX_ALLOWED_FONT_SIZE = 72;
var DEFAULT_FONT_SIZE = 15;
var blockTypeToBlockName = {
  bullet: "Bulleted List",
  check: "Check List",
  code: "Code Block",
  h1: "Heading 1",
  h2: "Heading 2",
  h3: "Heading 3",
  h4: "Heading 4",
  h5: "Heading 5",
  h6: "Heading 6",
  number: "Numbered List",
  paragraph: "Normal",
  quote: "Quote"
};
var INITIAL_TOOLBAR_STATE = {
  none: false,
  bgColor: "#fff",
  blockType: "paragraph",
  canRedo: false,
  canUndo: false,
  cannotRedo: true,
  cannotUndo: true,
  codeLanguage: "",
  elementFormat: "left",
  fontColor: "#000",
  fontFamily: "Arial",
  // Current font size in px
  fontSize: `${DEFAULT_FONT_SIZE}px`,
  // Font size input value - for controlled input
  fontSizeInputValue: `${DEFAULT_FONT_SIZE}`,
  isBold: false,
  isCode: false,
  isImageCaption: false,
  isItalic: false,
  isLink: false,
  isRTL: false,
  isStrikethrough: false,
  isSubscript: false,
  isSuperscript: false,
  isUnderline: false,
  isLowercase: false,
  isUppercase: false,
  isCapitalize: false,
  rootType: "root"
};

// resources/js/utils.ts
var theme = {
  autocomplete: "lexical__autocomplete",
  blockCursor: "lexical__blockCursor",
  characterLimit: "lexical__characterLimit",
  code: "lexical__code",
  codeHighlight: {
    atrule: "lexical__tokenAttr",
    attr: "lexical__tokenAttr",
    boolean: "lexical__tokenProperty",
    builtin: "lexical__tokenSelector",
    cdata: "lexical__tokenComment",
    char: "lexical__tokenSelector",
    class: "lexical__tokenFunction",
    "class-name": "lexical__tokenFunction",
    comment: "lexical__tokenComment",
    constant: "lexical__tokenProperty",
    deleted: "lexical__tokenProperty",
    doctype: "lexical__tokenComment",
    entity: "lexical__tokenOperator",
    function: "lexical__tokenFunction",
    important: "lexical__tokenVariable",
    inserted: "lexical__tokenSelector",
    keyword: "lexical__tokenAttr",
    namespace: "lexical__tokenVariable",
    number: "lexical__tokenProperty",
    operator: "lexical__tokenOperator",
    prolog: "lexical__tokenComment",
    property: "lexical__tokenProperty",
    punctuation: "lexical__tokenPunctuation",
    regex: "lexical__tokenVariable",
    selector: "lexical__tokenSelector",
    string: "lexical__tokenSelector",
    symbol: "lexical__tokenProperty",
    tag: "lexical__tokenProperty",
    url: "lexical__tokenOperator",
    variable: "lexical__tokenVariable"
  },
  embedBlock: {
    base: "lexical__embedBlock",
    focus: "lexical__embedBlockFocus"
  },
  hashtag: "lexical__hashtag",
  heading: {
    h1: "lexical__h1",
    h2: "lexical__h2",
    h3: "lexical__h3",
    h4: "lexical__h4",
    h5: "lexical__h5",
    h6: "lexical__h6"
  },
  hr: "lexical__hr",
  image: "lexical__editor-image",
  indent: "lexical__indent",
  inlineImage: "lexical__inline-editor-image",
  layoutContainer: "lexical__layoutContainer",
  layoutItem: "lexical__layoutItem",
  link: "lexical__link",
  list: {
    checklist: "lexical__checklist",
    listitem: "lexical__listItem",
    listitemChecked: "lexical__listItemChecked",
    listitemUnchecked: "lexical__listItemUnchecked",
    nested: {
      listitem: "lexical__nestedListItem"
    },
    olDepth: ["lexical__ol1", "lexical__ol2", "lexical__ol3", "lexical__ol4", "lexical__ol5"],
    ul: "lexical__ul"
  },
  ltr: "lexical__ltr",
  mark: "lexical__mark",
  markOverlap: "lexical__markOverlap",
  paragraph: "lexical__paragraph",
  quote: "lexical__quote",
  rtl: "lexical__rtl",
  table: "lexical__table",
  tableAddColumns: "lexical__tableAddColumns",
  tableAddRows: "lexical__tableAddRows",
  tableCell: "lexical__tableCell",
  tableCellActionButton: "lexical__tableCellActionButton",
  tableCellActionButtonContainer: "lexical__tableCellActionButtonContainer",
  tableCellEditing: "lexical__tableCellEditing",
  tableCellHeader: "lexical__tableCellHeader",
  tableCellPrimarySelected: "lexical__tableCellPrimarySelected",
  tableCellResizer: "lexical__tableCellResizer",
  tableCellSelected: "lexical__tableCellSelected",
  tableCellSortedIndicator: "lexical__tableCellSortedIndicator",
  tableResizeRuler: "lexical__tableCellResizeRuler",
  tableSelected: "lexical__tableSelected",
  tableSelection: "lexical__tableSelection",
  text: {
    bold: "lexical__textBold",
    code: "lexical__textCode",
    italic: "lexical__textItalic",
    strikethrough: "lexical__textStrikethrough",
    subscript: "lexical__textSubscript",
    superscript: "lexical__textSuperscript",
    underline: "lexical__textUnderline",
    underlineStrikethrough: "lexical__textUnderlineStrikethrough",
    lowercase: "lexical__textLowercase",
    uppercase: "lexical__textUppercase",
    capitalize: "lexical__textCapitalize"
  }
};
var calculateNextFontSize = (currentFontSize, updateType) => {
  if (!updateType) {
    return currentFontSize;
  }
  let updatedFontSize = currentFontSize;
  switch (updateType) {
    case 2 /* decrement */:
      switch (true) {
        case currentFontSize > MAX_ALLOWED_FONT_SIZE:
          updatedFontSize = MAX_ALLOWED_FONT_SIZE;
          break;
        case currentFontSize >= 48:
          updatedFontSize -= 12;
          break;
        case currentFontSize >= 24:
          updatedFontSize -= 4;
          break;
        case currentFontSize >= 14:
          updatedFontSize -= 2;
          break;
        case currentFontSize >= 9:
          updatedFontSize -= 1;
          break;
        default:
          updatedFontSize = MIN_ALLOWED_FONT_SIZE;
          break;
      }
      break;
    case 1 /* increment */:
      switch (true) {
        case currentFontSize < MIN_ALLOWED_FONT_SIZE:
          updatedFontSize = MIN_ALLOWED_FONT_SIZE;
          break;
        case currentFontSize < 12:
          updatedFontSize += 1;
          break;
        case currentFontSize < 20:
          updatedFontSize += 2;
          break;
        case currentFontSize < 36:
          updatedFontSize += 4;
          break;
        case currentFontSize <= 60:
          updatedFontSize += 12;
          break;
        default:
          updatedFontSize = MAX_ALLOWED_FONT_SIZE;
          break;
      }
      break;
    default:
      break;
  }
  return updatedFontSize;
};
var updateFontSizeInSelection = (editor, newFontSize, updateType) => {
  const getNextFontSize = (prevFontSize) => {
    if (!prevFontSize) {
      prevFontSize = `${DEFAULT_FONT_SIZE}px`;
    }
    prevFontSize = prevFontSize.slice(0, -2);
    const nextFontSize = calculateNextFontSize(Number(prevFontSize), updateType);
    return `${nextFontSize}px`;
  };
  editor.update(() => {
    if (!editor.isEditable()) return;
    const selection = $getSelection2();
    if (selection === null) return;
    $patchStyleText2(selection, {
      "font-size": newFontSize || getNextFontSize
    });
  });
};
var updateFontSize = (editor, updateType, input) => {
  const inputValue = input.value;
  if (inputValue !== "") {
    const nextFontSize = calculateNextFontSize(Number(inputValue), updateType);
    updateFontSizeInSelection(editor, String(nextFontSize) + "px", null);
    input.value = nextFontSize.toString();
    return;
  }
  updateFontSizeInSelection(editor, null, updateType);
};
var updateFontSizeByInputValue = function(editor, inputValueNumber, input) {
  if (inputValueNumber == null) {
    return;
  }
  let updatedFontSize = inputValueNumber;
  if (inputValueNumber > MAX_ALLOWED_FONT_SIZE) {
    updatedFontSize = MAX_ALLOWED_FONT_SIZE;
    input.value = updatedFontSize.toString();
  } else if (inputValueNumber < MIN_ALLOWED_FONT_SIZE) {
    updatedFontSize = MIN_ALLOWED_FONT_SIZE;
    input.value = updatedFontSize.toString();
  }
  updateFontSizeInSelection(editor, String(updatedFontSize) + "px", null);
};
var formatParagraph = (editor) => {
  editor.update(() => {
    const selection = $getSelection2();
    if ($isRangeSelection2(selection)) {
      $setBlocksType2(selection, () => $createParagraphNode2());
    }
  });
};
var formatHeading = (editor, blockType, headingSize) => {
  if (blockType !== headingSize) {
    editor.update(() => {
      const selection = $getSelection2();
      $setBlocksType2(selection, () => $createHeadingNode2(headingSize));
    });
  }
};
var formatBulletList = (editor, blockType) => {
  if (blockType !== "bullet") {
    editor.dispatchCommand(INSERT_UNORDERED_LIST_COMMAND2, void 0);
    return;
  }
  formatParagraph(editor);
};
var formatCheckList = (editor, blockType) => {
  if (blockType !== "check") {
    editor.dispatchCommand(INSERT_CHECK_LIST_COMMAND2, void 0);
    return;
  }
  formatParagraph(editor);
};
var formatNumberedList = (editor, blockType) => {
  if (blockType !== "number") {
    editor.dispatchCommand(INSERT_ORDERED_LIST_COMMAND2, void 0);
    return;
  }
  formatParagraph(editor);
};
var formatQuote = (editor, blockType) => {
  if (blockType !== "quote") {
    editor.update(() => {
      const selection = $getSelection2();
      $setBlocksType2(selection, () => $createQuoteNode2());
    });
  }
};
var formatCode = (editor, blockType) => {
  if (blockType !== "code") {
    editor.update(() => {
      let selection = $getSelection2();
      if (selection !== null) {
        if (selection.isCollapsed()) {
          $setBlocksType2(selection, () => $createCodeNode2());
        } else {
          const textContent = selection.getTextContent();
          const codeNode = $createCodeNode2();
          selection.insertNodes([codeNode]);
          selection = $getSelection2();
          if ($isRangeSelection2(selection)) {
            selection.insertRawText(textContent);
          }
        }
      }
    });
  }
};
var getSelectedNode = function(selection) {
  const anchor = selection.anchor;
  const focus = selection.focus;
  const anchorNode = selection.anchor.getNode();
  const focusNode = selection.focus.getNode();
  if (anchorNode === focusNode) {
    return anchorNode;
  }
  const isBackward = selection.isBackward();
  if (isBackward) {
    return $isAtNodeEnd2(focus) ? anchorNode : focusNode;
  }
  return $isAtNodeEnd2(anchor) ? focusNode : anchorNode;
};
var clearFormatting = (editor) => {
  formatParagraph(editor);
  editor.update(() => {
    const selection = $getSelection2();
    if (!($isRangeSelection2(selection) || $isTableSelection2(selection))) {
      return;
    }
    const anchor = selection.anchor;
    const focus = selection.focus;
    const nodes = selection.getNodes();
    const extractedNodes = selection.extract();
    if (anchor.key === focus.key && anchor.offset === focus.offset) {
      return;
    }
    nodes.forEach((node, idx) => {
      if ($isTextNode2(node)) {
        let textNode = node;
        if (idx === 0 && anchor.offset !== 0) {
          textNode = textNode.splitText(anchor.offset)[1] || textNode;
        }
        if (idx === nodes.length - 1) {
          textNode = textNode.splitText(focus.offset)[0] || textNode;
        }
        const extractedTextNode = extractedNodes[0];
        if (nodes.length === 1 && $isTextNode2(extractedTextNode)) {
          textNode = extractedTextNode;
        }
        if (textNode.__style !== "") {
          textNode.setStyle("");
        }
        if (textNode.__format !== 0) {
          textNode.setFormat(0);
          $getNearestBlockElementAncestorOrThrow2(textNode).setFormat("");
        }
        node = textNode;
      } else if ($isHeadingNode2(node) || $isQuoteNode2(node)) {
        node.replace($createParagraphNode2(), true);
      } else if ($isLinkNode2(node)) {
        node.replace($createTextNode2(node.getTextContent()), false);
      }
    });
  });
};

// resources/js/lexical-link-plugin.ts
var SUPPORTED_URL_PROTOCOLS2 = /* @__PURE__ */ new Set(["http:", "https:", "mailto:", "sms:", "tel:"]);
var urlRegExp = new RegExp(
  /((([A-Za-z]{3,9}:(?:\/\/)?)(?:[-;:&=+$,\w]+@)?[A-Za-z0-9.-]+|(?:www.|[-;:&=+$,\w]+@)[A-Za-z0-9.-]+)((?:\/[+~%/.\w-_]*)?\??(?:[-+=&;%@.\w_]*)#?(?:[\w]*))?)/
);
var INTERNAL_URL_REGEX = /^\/[a-zA-Z0-9\-_\/\.]*$/;
function isInternalUrl(url) {
  return INTERNAL_URL_REGEX.test(url);
}
function sanitizeUrl(url, allowInternal = true) {
  if (allowInternal && isInternalUrl(url)) {
    return url;
  }
  try {
    const parsedUrl = new URL(url);
    if (!SUPPORTED_URL_PROTOCOLS2.has(parsedUrl.protocol)) {
      return "about:blank";
    }
    return url;
  } catch {
    return "about:blank";
  }
}
function registerLink3(editor) {
  editor.registerCommand(
    TOGGLE_LINK_COMMAND2,
    (payload) => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection)) {
        return false;
      }
      const rootDom = editor.getElementByKey($getRoot2().getKey());
      if (!rootDom) {
        return false;
      }
      const node = getSelectedNode(selection);
      const parent = node.getParent();
      let url = null;
      let target = "_blank";
      let rel = "noopener noreferrer";
      if (payload === null) {
        url = null;
      } else if (typeof payload === "string") {
        url = sanitizeUrl(payload);
        if (isInternalUrl(payload)) {
          target = "_self";
          rel = "";
        }
      } else if (typeof payload === "object") {
        url = sanitizeUrl(payload.url);
        target = payload.target ?? (isInternalUrl(payload.url) ? "_self" : "_blank");
        rel = payload.rel ?? (target === "_blank" ? "noopener noreferrer" : "");
      }
      if ($isLinkNode2(parent) || $isLinkNode2(node)) {
        $toggleLink2(url, {
          rel: rel || void 0,
          target
        });
        if (url === null) {
          rootDom.dispatchEvent(new CustomEvent("close-link-editor-dialog"));
        }
        return true;
      }
      const defaultUrl = "https://";
      $toggleLink2(defaultUrl, {
        rel: "noopener noreferrer",
        target: "_blank"
      });
      editor.read(() => {
        const sel = $getSelection2();
        if (!$isRangeSelection2(sel)) {
          return;
        }
        const selectedNode = getSelectedNode(sel);
        const linkNode = $findMatchingParent3(selectedNode, $isLinkNode2);
        const elementKey = (linkNode ?? selectedNode).getKey();
        const elementDOM = editor.getElementByKey(elementKey);
        if (elementDOM) {
          rootDom.dispatchEvent(
            new CustomEvent("link-created", {
              detail: {
                url: defaultUrl,
                target: elementDOM
              }
            })
          );
        }
      });
      return true;
    },
    COMMAND_PRIORITY_LOW2
  );
  return editor.registerRootListener((rootElement, prevRootElement) => {
    if (prevRootElement) {
      prevRootElement.removeEventListener("click", onClick2);
      prevRootElement.removeEventListener("mouseup", onMouseUp);
    }
    if (rootElement) {
      rootElement.addEventListener("click", onClick2);
      rootElement.addEventListener("mouseup", onMouseUp);
    }
  });
}
var onClick2 = (event) => {
  const target = event.target;
  if (!isDOMNode2(target)) {
    return;
  }
  const nearestEditor = getNearestEditorFromDOMNode2(target);
  if (nearestEditor === null) {
    return;
  }
  let url = null;
  let urlTarget = null;
  nearestEditor.update(() => {
    const clickedNode = $getNearestNodeFromDOMNode2(target);
    if (clickedNode === null) {
      return;
    }
    const maybeLinkNode = $findMatchingParent3(clickedNode, $isLinkNode2);
    if ($isLinkNode2(maybeLinkNode)) {
      url = maybeLinkNode.getURL();
      urlTarget = maybeLinkNode.getTarget();
      return;
    }
    const a2 = findMatchingDOM2(target, isHTMLAnchorElement2);
    if (a2) {
      url = a2.href;
      urlTarget = a2.target;
    }
  });
  if (!url) {
    return;
  }
  const selection = nearestEditor.getEditorState().read($getSelection2);
  if ($isRangeSelection2(selection) && !selection.isCollapsed()) {
    event.preventDefault();
    return;
  }
  nearestEditor.read(() => {
    const rootDom = nearestEditor.getElementByKey($getRoot2().getKey());
    if (!rootDom) return;
    rootDom.dispatchEvent(
      new CustomEvent("link-clicked", {
        detail: {
          url,
          target,
          urlTarget,
          isInternal: isInternalUrl(url || "")
        }
      })
    );
  });
};
var onMouseUp = (event) => {
  if (event.button === 1) {
    onClick2(event);
  }
};
function findMatchingDOM2(startNode, predicate) {
  let node = startNode;
  while (node) {
    if (predicate(node)) {
      return node;
    }
    node = node.parentNode;
  }
  return null;
}

// resources/js/can-use-dom.ts
var CAN_USE_DOM6 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";

// resources/js/environment.ts
var documentMode5 = CAN_USE_DOM6 && "documentMode" in document ? document.documentMode : null;
var IS_APPLE5 = CAN_USE_DOM6 && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
var IS_FIREFOX5 = CAN_USE_DOM6 && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
var CAN_USE_BEFORE_INPUT5 = CAN_USE_DOM6 && "InputEvent" in window && !documentMode5 ? "getTargetRanges" in new window.InputEvent("input") : false;
var IS_SAFARI5 = CAN_USE_DOM6 && /Version\/[\d.]+.*Safari/.test(navigator.userAgent);
var IS_IOS5 = CAN_USE_DOM6 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
var IS_ANDROID4 = CAN_USE_DOM6 && /Android/.test(navigator.userAgent);
var IS_CHROME5 = CAN_USE_DOM6 && /^(?=.*Chrome).*/i.test(navigator.userAgent);
var IS_APPLE_WEBKIT5 = CAN_USE_DOM6 && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !IS_CHROME5;

// resources/js/shortcuts.ts
var SHORTCUTS = Object.freeze({
  // (Ctrl|⌘) + (Alt|Option) + <key> shortcuts
  NORMAL: IS_APPLE5 ? "\u2318+Opt+0" : "Ctrl+Alt+0",
  HEADING1: IS_APPLE5 ? "\u2318+Opt+1" : "Ctrl+Alt+1",
  HEADING2: IS_APPLE5 ? "\u2318+Opt+2" : "Ctrl+Alt+2",
  HEADING3: IS_APPLE5 ? "\u2318+Opt+3" : "Ctrl+Alt+3",
  BULLET_LIST: IS_APPLE5 ? "\u2318+Opt+4" : "Ctrl+Alt+4",
  NUMBERED_LIST: IS_APPLE5 ? "\u2318+Opt+5" : "Ctrl+Alt+5",
  CHECK_LIST: IS_APPLE5 ? "\u2318+Opt+6" : "Ctrl+Alt+6",
  CODE_BLOCK: IS_APPLE5 ? "\u2318+Opt+C" : "Ctrl+Alt+C",
  QUOTE: IS_APPLE5 ? "\u2318+Opt+Q" : "Ctrl+Alt+Q",
  // (Ctrl|⌘) + Shift + <key> shortcuts
  INCREASE_FONT_SIZE: IS_APPLE5 ? "\u2318+Shift+." : "Ctrl+Shift+.",
  DECREASE_FONT_SIZE: IS_APPLE5 ? "\u2318+Shift+," : "Ctrl+Shift+,",
  INSERT_CODE_BLOCK: IS_APPLE5 ? "\u2318+Shift+C" : "Ctrl+Shift+C",
  STRIKETHROUGH: IS_APPLE5 ? "\u2318+Shift+S" : "Ctrl+Shift+S",
  LOWERCASE: IS_APPLE5 ? "\u2318+Shift+1" : "Ctrl+Shift+1",
  UPPERCASE: IS_APPLE5 ? "\u2318+Shift+2" : "Ctrl+Shift+2",
  CAPITALIZE: IS_APPLE5 ? "\u2318+Shift+3" : "Ctrl+Shift+3",
  CENTER_ALIGN: IS_APPLE5 ? "\u2318+Shift+E" : "Ctrl+Shift+E",
  JUSTIFY_ALIGN: IS_APPLE5 ? "\u2318+Shift+J" : "Ctrl+Shift+J",
  LEFT_ALIGN: IS_APPLE5 ? "\u2318+Shift+L" : "Ctrl+Shift+L",
  RIGHT_ALIGN: IS_APPLE5 ? "\u2318+Shift+R" : "Ctrl+Shift+R",
  // (Ctrl|⌘) + <key> shortcuts
  SUBSCRIPT: IS_APPLE5 ? "\u2318+," : "Ctrl+,",
  SUPERSCRIPT: IS_APPLE5 ? "\u2318+." : "Ctrl+.",
  INDENT: IS_APPLE5 ? "\u2318+]" : "Ctrl+]",
  OUTDENT: IS_APPLE5 ? "\u2318+[" : "Ctrl+[",
  CLEAR_FORMATTING: IS_APPLE5 ? "\u2318+\\" : "Ctrl+\\",
  REDO: IS_APPLE5 ? "\u2318+Shift+Z" : "Ctrl+Y",
  UNDO: IS_APPLE5 ? "\u2318+Z" : "Ctrl+Z",
  BOLD: IS_APPLE5 ? "\u2318+B" : "Ctrl+B",
  ITALIC: IS_APPLE5 ? "\u2318+I" : "Ctrl+I",
  UNDERLINE: IS_APPLE5 ? "\u2318+U" : "Ctrl+U",
  INSERT_LINK: IS_APPLE5 ? "\u2318+K" : "Ctrl+K"
});
function controlOrMeta(metaKey, ctrlKey) {
  return IS_APPLE5 ? metaKey : ctrlKey;
}
function isFormatParagraph(event) {
  const { code, shiftKey, altKey, metaKey, ctrlKey } = event;
  return (code === "Numpad0" || code === "Digit0") && !shiftKey && altKey && controlOrMeta(metaKey, ctrlKey);
}
function isFormatHeading(event) {
  const { code, shiftKey, altKey, metaKey, ctrlKey } = event;
  const keyNumber = code[code.length - 1];
  const includesKeyNumber = ["1", "2", "3", "4", "5", "6"].includes(keyNumber);
  return includesKeyNumber && !shiftKey && altKey && controlOrMeta(metaKey, ctrlKey);
}
function isFormatBulletList(event) {
  const { code, shiftKey, altKey, metaKey, ctrlKey } = event;
  return (code === "Numpad7" || code === "Digit7") && !shiftKey && altKey && controlOrMeta(metaKey, ctrlKey);
}
function isFormatNumberedList(event) {
  const { code, shiftKey, altKey, metaKey, ctrlKey } = event;
  return (code === "Numpad8" || code === "Digit8") && !shiftKey && altKey && controlOrMeta(metaKey, ctrlKey);
}
function isFormatCheckList(event) {
  const { code, shiftKey, altKey, metaKey, ctrlKey } = event;
  return (code === "Numpad6" || code === "Digit6") && !shiftKey && altKey && controlOrMeta(metaKey, ctrlKey);
}
function isFormatCode(event) {
  const { code, shiftKey, altKey, metaKey, ctrlKey } = event;
  return code === "KeyC" && !shiftKey && altKey && controlOrMeta(metaKey, ctrlKey);
}
function isFormatQuote(event) {
  const { code, shiftKey, altKey, metaKey, ctrlKey } = event;
  return code === "KeyQ" && !shiftKey && altKey && controlOrMeta(metaKey, ctrlKey);
}
function isLowercase(event) {
  const { code, shiftKey, altKey, metaKey, ctrlKey } = event;
  return (code === "Numpad1" || code === "Digit1") && shiftKey && !altKey && controlOrMeta(metaKey, ctrlKey);
}
function isUppercase(event) {
  const { code, shiftKey, altKey, metaKey, ctrlKey } = event;
  return (code === "Numpad2" || code === "Digit2") && shiftKey && !altKey && controlOrMeta(metaKey, ctrlKey);
}
function isCapitalize(event) {
  const { code, shiftKey, altKey, metaKey, ctrlKey } = event;
  return (code === "Numpad3" || code === "Digit3") && shiftKey && !altKey && controlOrMeta(metaKey, ctrlKey);
}
function isStrikeThrough(event) {
  const { code, shiftKey, altKey, metaKey, ctrlKey } = event;
  return code === "KeyS" && shiftKey && !altKey && controlOrMeta(metaKey, ctrlKey);
}
function isIndent(event) {
  const { code, shiftKey, altKey, metaKey, ctrlKey } = event;
  return code === "BracketRight" && !shiftKey && !altKey && controlOrMeta(metaKey, ctrlKey);
}
function isOutdent(event) {
  const { code, shiftKey, altKey, metaKey, ctrlKey } = event;
  return code === "BracketLeft" && !shiftKey && !altKey && controlOrMeta(metaKey, ctrlKey);
}
function isCenterAlign(event) {
  const { code, shiftKey, altKey, metaKey, ctrlKey } = event;
  return code === "KeyE" && shiftKey && !altKey && controlOrMeta(metaKey, ctrlKey);
}
function isLeftAlign(event) {
  const { code, shiftKey, altKey, metaKey, ctrlKey } = event;
  return code === "KeyL" && shiftKey && !altKey && controlOrMeta(metaKey, ctrlKey);
}
function isRightAlign(event) {
  const { code, shiftKey, altKey, metaKey, ctrlKey } = event;
  return code === "KeyR" && shiftKey && !altKey && controlOrMeta(metaKey, ctrlKey);
}
function isJustifyAlign(event) {
  const { code, shiftKey, altKey, metaKey, ctrlKey } = event;
  return code === "KeyJ" && shiftKey && !altKey && controlOrMeta(metaKey, ctrlKey);
}
function isStartAlign(event) {
  const { code, shiftKey, altKey, metaKey, ctrlKey } = event;
  return code === "BracketLeft" && shiftKey && !altKey && controlOrMeta(metaKey, ctrlKey);
}
function isEndAlign(event) {
  const { code, shiftKey, altKey, metaKey, ctrlKey } = event;
  return code === "BracketRight" && shiftKey && !altKey && controlOrMeta(metaKey, ctrlKey);
}
function isSubscript(event) {
  const { code, shiftKey, altKey, metaKey, ctrlKey } = event;
  return code === "Comma" && !shiftKey && !altKey && controlOrMeta(metaKey, ctrlKey);
}
function isSuperscript(event) {
  const { code, shiftKey, altKey, metaKey, ctrlKey } = event;
  return code === "Period" && !shiftKey && !altKey && controlOrMeta(metaKey, ctrlKey);
}
function isInsertCodeBlock(event) {
  const { code, shiftKey, altKey, metaKey, ctrlKey } = event;
  return code === "KeyC" && shiftKey && !altKey && controlOrMeta(metaKey, ctrlKey);
}
function isIncreaseFontSize(event) {
  const { code, shiftKey, altKey, metaKey, ctrlKey } = event;
  return code === "Period" && shiftKey && !altKey && controlOrMeta(metaKey, ctrlKey);
}
function isDecreaseFontSize(event) {
  const { code, shiftKey, altKey, metaKey, ctrlKey } = event;
  return code === "Comma" && shiftKey && !altKey && controlOrMeta(metaKey, ctrlKey);
}
function isClearFormatting(event) {
  const { code, shiftKey, altKey, metaKey, ctrlKey } = event;
  return code === "Slash" && !shiftKey && !altKey && controlOrMeta(metaKey, ctrlKey);
}
function isInsertLink(event) {
  const { code, shiftKey, altKey, metaKey, ctrlKey } = event;
  return code === "KeyK" && !shiftKey && !altKey && controlOrMeta(metaKey, ctrlKey);
}

// resources/js/lexical-shortcuts-plugin.ts
function registerShortcuts(editor) {
  const keyboardShortcutsHandler = (event) => {
    if (isFormatParagraph(event)) {
      event.preventDefault();
      formatParagraph(editor);
      return true;
    }
    if (isFormatHeading(event)) {
      event.preventDefault();
      const { code } = event;
      const headingSize = `h${code[code.length - 1]}`;
      formatHeading(editor, "", headingSize);
      return true;
    }
    if (isFormatBulletList(event)) {
      event.preventDefault();
      formatBulletList(editor, "");
      return true;
    }
    if (isFormatNumberedList(event)) {
      event.preventDefault();
      formatNumberedList(editor, "");
      return true;
    }
    if (isFormatCheckList(event)) {
      event.preventDefault();
      formatCheckList(editor, "");
      return true;
    }
    if (isFormatCode(event)) {
      event.preventDefault();
      formatCode(editor, "");
      return true;
    }
    if (isFormatQuote(event)) {
      event.preventDefault();
      formatQuote(editor, "");
      return true;
    }
    if (isStrikeThrough(event)) {
      event.preventDefault();
      editor.dispatchCommand(FORMAT_TEXT_COMMAND2, "strikethrough");
      return true;
    }
    if (isLowercase(event)) {
      event.preventDefault();
      editor.dispatchCommand(FORMAT_TEXT_COMMAND2, "lowercase");
      return true;
    }
    if (isUppercase(event)) {
      event.preventDefault();
      editor.dispatchCommand(FORMAT_TEXT_COMMAND2, "uppercase");
      return true;
    }
    if (isCapitalize(event)) {
      event.preventDefault();
      editor.dispatchCommand(FORMAT_TEXT_COMMAND2, "capitalize");
      return true;
    }
    if (isIndent(event)) {
      event.preventDefault();
      editor.dispatchCommand(INDENT_CONTENT_COMMAND2, void 0);
      return true;
    }
    if (isOutdent(event)) {
      event.preventDefault();
      editor.dispatchCommand(OUTDENT_CONTENT_COMMAND2, void 0);
      return true;
    }
    if (isCenterAlign(event)) {
      event.preventDefault();
      editor.dispatchCommand(FORMAT_ELEMENT_COMMAND2, "center");
      return true;
    }
    if (isLeftAlign(event)) {
      event.preventDefault();
      editor.dispatchCommand(FORMAT_ELEMENT_COMMAND2, "left");
      return true;
    }
    if (isRightAlign(event)) {
      event.preventDefault();
      editor.dispatchCommand(FORMAT_ELEMENT_COMMAND2, "right");
      return true;
    }
    if (isJustifyAlign(event)) {
      event.preventDefault();
      editor.dispatchCommand(FORMAT_ELEMENT_COMMAND2, "justify");
      return true;
    }
    if (isStartAlign(event)) {
      event.preventDefault();
      editor.dispatchCommand(FORMAT_ELEMENT_COMMAND2, "start");
      return true;
    }
    if (isEndAlign(event)) {
      event.preventDefault();
      editor.dispatchCommand(FORMAT_ELEMENT_COMMAND2, "end");
      return true;
    }
    if (isSubscript(event)) {
      event.preventDefault();
      editor.dispatchCommand(FORMAT_TEXT_COMMAND2, "subscript");
      return true;
    }
    if (isSuperscript(event)) {
      event.preventDefault();
      editor.dispatchCommand(FORMAT_TEXT_COMMAND2, "superscript");
      return true;
    }
    if (isInsertCodeBlock(event)) {
      event.preventDefault();
      editor.dispatchCommand(FORMAT_TEXT_COMMAND2, "code");
      return true;
    }
    if (isIncreaseFontSize(event)) {
      event.preventDefault();
      const editorShell = event.target?.closest(".editor-shell");
      const fontSizeElement = editorShell?.querySelector('[x-ref="fontSize"]');
      if (fontSizeElement) {
        updateFontSize(editor, 1 /* increment */, fontSizeElement);
      }
      return true;
    }
    if (isDecreaseFontSize(event)) {
      event.preventDefault();
      const editorShell = event.target?.closest(".editor-shell");
      const fontSizeElement = editorShell?.querySelector('[x-ref="fontSize"]');
      if (fontSizeElement) {
        updateFontSize(editor, 2 /* decrement */, fontSizeElement);
      }
      return true;
    }
    if (isClearFormatting(event)) {
      event.preventDefault();
      clearFormatting(editor);
      return true;
    }
    if (isInsertLink(event)) {
      event.preventDefault();
      editor.dispatchCommand(TOGGLE_LINK_COMMAND2, null);
      return true;
    }
    return false;
  };
  return editor.registerCommand(
    KEY_MODIFIER_COMMAND2,
    keyboardShortcutsHandler,
    COMMAND_PRIORITY_NORMAL2
  );
}

// resources/js/lexical-image-plugin.ts
function sanitizeImageSrc(src) {
  if (!src) return "";
  if (src.startsWith("/")) {
    return src;
  }
  try {
    const parsed = new URL(src);
    if (parsed.protocol === "http:" || parsed.protocol === "https:") {
      return parsed.toString();
    }
    return "";
  } catch {
    return "";
  }
}
var ImageNode = class _ImageNode extends DecoratorNode2 {
  static getType() {
    return "image";
  }
  static clone(node) {
    return new _ImageNode(
      node.__src,
      node.__altText,
      node.__maxWidth,
      node.__width,
      node.__height,
      node.__showCaption,
      node.__caption,
      node.__captionsEnabled,
      node.__key
    );
  }
  static importJSON(serializedNode) {
    const { altText, height, width, maxWidth, caption, src, showCaption } = serializedNode;
    const node = $createImageNode({
      altText,
      height,
      maxWidth,
      showCaption,
      src,
      width
    });
    const nestedEditor = node.__caption;
    const editorState = nestedEditor.parseEditorState(caption.editorState);
    if (!editorState.isEmpty()) {
      nestedEditor.setEditorState(editorState);
    }
    return node;
  }
  exportDOM() {
    const element = document.createElement("img");
    element.setAttribute("src", this.__src);
    element.setAttribute("alt", this.__altText);
    if (typeof this.__width === "number" && this.__width > 0) {
      element.setAttribute("width", String(this.__width));
    }
    if (typeof this.__height === "number" && this.__height > 0) {
      element.setAttribute("height", String(this.__height));
    }
    return { element };
  }
  static importDOM() {
    return {
      img: () => ({
        conversion: convertImageElement,
        priority: 0
      })
    };
  }
  constructor(src, altText, maxWidth, width, height, showCaption, caption, captionsEnabled, key) {
    super(key);
    this.__src = sanitizeImageSrc(src);
    this.__altText = altText;
    this.__maxWidth = maxWidth;
    this.__width = width || "inherit";
    this.__height = height || "inherit";
    this.__showCaption = showCaption || false;
    this.__caption = caption || createEditor2();
    this.__captionsEnabled = captionsEnabled || captionsEnabled === void 0;
  }
  exportJSON() {
    return {
      altText: this.getAltText(),
      caption: this.__caption.toJSON(),
      height: this.__height === "inherit" ? 0 : this.__height,
      maxWidth: this.__maxWidth,
      showCaption: this.__showCaption,
      src: this.getSrc(),
      type: "image",
      version: 1,
      width: this.__width === "inherit" ? 0 : this.__width
    };
  }
  setWidthAndHeight(width, height) {
    const writable = this.getWritable();
    writable.__width = width;
    writable.__height = height;
  }
  setAltText(altText) {
    const writable = this.getWritable();
    writable.__altText = altText;
  }
  // View
  createDOM(config) {
    const span = document.createElement("span");
    const theme2 = config.theme;
    const className = theme2.image;
    if (className) {
      span.className = className;
    }
    span.classList.add("relative", "image-span");
    const element = document.createElement("img");
    const safeSrc = sanitizeImageSrc(this.__src);
    if (safeSrc) {
      element.setAttribute("src", safeSrc);
    }
    element.setAttribute("alt", this.__altText);
    element.style.width = this.__width === "inherit" || this.__width === 0 ? "" : `${this.__width}px`;
    element.style.height = "auto";
    const isSelectedClassName = "focused";
    element.onclick = () => {
      element.classList.toggle(isSelectedClassName);
    };
    element.setAttribute(
      "x-on:click.outside",
      `$el.classList.remove("${isSelectedClassName}")`
    );
    span.appendChild(element);
    const button = document.createElement("button");
    button.type = "button";
    button.style.width = "2rem";
    button.style.height = "2rem";
    button.className = "image-editor-button bg-gray-200 rounded-full";
    button.style.top = "0";
    button.style.right = "0";
    button.style.position = "absolute";
    const icon = document.createElement("i");
    icon.className = "edit";
    icon.style.width = "1.5rem";
    icon.style.height = "1.5rem";
    icon.style.display = "block";
    icon.style.margin = "auto";
    button.appendChild(icon);
    button.setAttribute("x-on:click", `openImageEditor('${this.getKey()}')`);
    span.appendChild(button);
    return span;
  }
  updateDOM(_prevNode, dom, _config) {
    const domElement = dom.querySelector("img");
    if (!domElement) return true;
    domElement.style.width = this.__width === "inherit" || this.__width === 0 ? "" : `${this.__width}px`;
    domElement.style.height = "auto";
    domElement.setAttribute("alt", this.__altText);
    const safeSrc = sanitizeImageSrc(this.__src);
    if (safeSrc) {
      domElement.setAttribute("src", safeSrc);
    } else {
      domElement.removeAttribute("src");
    }
    return true;
  }
  getSrc() {
    return this.__src;
  }
  getAltText() {
    return this.__altText;
  }
  getWidth() {
    return this.__width === "inherit" ? 0 : this.__width;
  }
  getHeight() {
    return this.__height === "inherit" ? 0 : this.__height;
  }
  decorate() {
    return null;
  }
};
function convertImageElement(domNode) {
  const img = domNode;
  const src = img.getAttribute("src") ?? "";
  if (!(src.startsWith("/") || /^https?:\/\//i.test(src))) {
    return null;
  }
  const altText = img.getAttribute("alt") ?? "";
  const width = img.width || 0;
  const height = img.height || 0;
  const node = $createImageNode({ altText, height, src, width });
  return { node };
}
function $createImageNode({
  altText,
  height,
  maxWidth = 500,
  captionsEnabled,
  src,
  width,
  showCaption,
  caption,
  key
}) {
  return $applyNodeReplacement2(
    new ImageNode(
      src,
      altText,
      maxWidth,
      width,
      height,
      showCaption,
      caption,
      captionsEnabled,
      key
    )
  );
}
function $isImageNode(node) {
  return node instanceof ImageNode;
}
var INSERT_IMAGE_COMMAND = createCommand2("INSERT_IMAGE_COMMAND");
var registerInsertImageCommand = (editor) => {
  return editor.registerCommand(
    INSERT_IMAGE_COMMAND,
    (payload) => {
      const imageNode = $createImageNode({
        ...payload,
        src: sanitizeImageSrc(payload.src)
      });
      if (!imageNode.getSrc()) {
        return true;
      }
      $insertNodes2([imageNode]);
      return true;
    },
    COMMAND_PRIORITY_EDITOR2
  );
};

// resources/js/lexical-table-plugin.ts
var INSERT_TABLE_COMMAND3 = createCommand2("INSERT_TABLE_COMMAND");
var INSERT_TABLE_ROW_COMMAND = createCommand2("INSERT_TABLE_ROW_COMMAND");
var INSERT_TABLE_COLUMN_COMMAND = createCommand2("INSERT_TABLE_COLUMN_COMMAND");
var DELETE_TABLE_ROW_COMMAND = createCommand2("DELETE_TABLE_ROW_COMMAND");
var DELETE_TABLE_COLUMN_COMMAND = createCommand2("DELETE_TABLE_COLUMN_COMMAND");
var DELETE_TABLE_COMMAND = createCommand2("DELETE_TABLE_COMMAND");
var MERGE_TABLE_CELLS_COMMAND = createCommand2("MERGE_TABLE_CELLS_COMMAND");
var UNMERGE_TABLE_CELL_COMMAND = createCommand2("UNMERGE_TABLE_CELL_COMMAND");
var SET_TABLE_CELL_BACKGROUND_COMMAND = createCommand2("SET_TABLE_CELL_BACKGROUND_COMMAND");
var SET_TABLE_BORDER_STYLE_COMMAND = createCommand2("SET_TABLE_BORDER_STYLE_COMMAND");
var SET_TABLE_LAYOUT_COMMAND = createCommand2("SET_TABLE_LAYOUT_COMMAND");
var SET_TABLE_WIDTH_COMMAND = createCommand2("SET_TABLE_WIDTH_COMMAND");
var SET_TABLE_ALIGNMENT_COMMAND = createCommand2("SET_TABLE_ALIGNMENT_COMMAND");
function $createTableNodeWithDimensions3(rowCount, columnCount, includeHeaders = true) {
  const tableNode = $createTableNode2();
  for (let i2 = 0; i2 < rowCount; i2++) {
    const tableRowNode = $createTableRowNode2();
    for (let j = 0; j < columnCount; j++) {
      const headerState = includeHeaders && i2 === 0 ? TableCellHeaderStates2.ROW : TableCellHeaderStates2.NO_STATUS;
      const tableCellNode = $createTableCellNode2(headerState);
      const paragraphNode = $createParagraphNode2();
      tableCellNode.append(paragraphNode);
      tableRowNode.append(tableCellNode);
    }
    tableNode.append(tableRowNode);
  }
  return tableNode;
}
function registerTablePlugin3(editor) {
  const removeOfficialTablePlugin = registerTablePlugin2(editor);
  const removeTableSelectionObserver = registerTableSelectionObserver2(editor, true);
  const removeInsertTableCommand = editor.registerCommand(
    INSERT_TABLE_COMMAND3,
    (payload) => {
      const { rows, columns, includeHeaders = true, borderStyle, cellPadding, layout, width } = payload;
      editor.update(() => {
        const selection = $getSelection2();
        if (!$isRangeSelection2(selection)) {
          return;
        }
        const tableNode = $createTableNodeWithDimensions3(
          Number(rows),
          Number(columns),
          includeHeaders
        );
        const styles = [];
        if (borderStyle) {
          styles.push(`--table-border-style: ${borderStyle}`);
        }
        if (cellPadding) {
          styles.push(`--table-cell-padding: ${cellPadding}`);
        }
        if (layout) {
          styles.push(`table-layout: ${layout}`);
          styles.push(`--table-layout: ${layout}`);
        }
        if (width && width !== "100%") {
          styles.push(`width: ${width}`);
          styles.push(`max-width: ${width}`);
        }
        if (styles.length > 0) {
          tableNode.setStyle(styles.join("; "));
        }
        selection.insertNodes([tableNode]);
        const firstCell = tableNode.getFirstDescendant();
        if (firstCell) {
          firstCell.selectEnd();
        }
      });
      return true;
    },
    COMMAND_PRIORITY_EDITOR2
  );
  const removeInsertRowCommand = editor.registerCommand(
    INSERT_TABLE_ROW_COMMAND,
    (payload) => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection) && !$isTableSelection2(selection)) {
        return false;
      }
      $insertTableRow__EXPERIMENTAL2(payload.insertAfter);
      return true;
    },
    COMMAND_PRIORITY_LOW2
  );
  const removeInsertColumnCommand = editor.registerCommand(
    INSERT_TABLE_COLUMN_COMMAND,
    (payload) => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection) && !$isTableSelection2(selection)) {
        return false;
      }
      $insertTableColumn__EXPERIMENTAL2(payload.insertAfter);
      return true;
    },
    COMMAND_PRIORITY_LOW2
  );
  const removeDeleteRowCommand = editor.registerCommand(
    DELETE_TABLE_ROW_COMMAND,
    () => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection) && !$isTableSelection2(selection)) {
        return false;
      }
      $deleteTableRow__EXPERIMENTAL2();
      return true;
    },
    COMMAND_PRIORITY_LOW2
  );
  const removeDeleteColumnCommand = editor.registerCommand(
    DELETE_TABLE_COLUMN_COMMAND,
    () => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection) && !$isTableSelection2(selection)) {
        return false;
      }
      $deleteTableColumn__EXPERIMENTAL2();
      return true;
    },
    COMMAND_PRIORITY_LOW2
  );
  const removeDeleteTableCommand = editor.registerCommand(
    DELETE_TABLE_COMMAND,
    () => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection) && !$isTableSelection2(selection)) {
        return false;
      }
      const tableNode = $findMatchingParent3(
        selection.anchor.getNode(),
        (node) => $isTableNode2(node)
      );
      if ($isTableNode2(tableNode)) {
        tableNode.remove();
        return true;
      }
      return false;
    },
    COMMAND_PRIORITY_LOW2
  );
  const removeMergeCellsCommand = editor.registerCommand(
    MERGE_TABLE_CELLS_COMMAND,
    () => {
      const selection = $getSelection2();
      if (!$isTableSelection2(selection)) {
        return false;
      }
      const nodes = selection.getNodes();
      const cells = nodes.filter((node) => $isTableCellNode2(node));
      if (cells.length < 2) {
        return false;
      }
      const tableNode = $findMatchingParent3(cells[0], (node) => $isTableNode2(node));
      if (!$isTableNode2(tableNode)) {
        return false;
      }
      let minRow = Infinity;
      let maxRow = -1;
      let minCol = Infinity;
      let maxCol = -1;
      for (const cell of cells) {
        const rowIndex = $getTableRowIndexFromTableCellNode2(cell);
        const colIndex = $getTableColumnIndexFromTableCellNode2(cell);
        minRow = Math.min(minRow, rowIndex);
        maxRow = Math.max(maxRow, rowIndex + (cell.getRowSpan() || 1) - 1);
        minCol = Math.min(minCol, colIndex);
        maxCol = Math.max(maxCol, colIndex + (cell.getColSpan() || 1) - 1);
      }
      const rowSpan = maxRow - minRow + 1;
      const colSpan = maxCol - minCol + 1;
      const rows = tableNode.getChildren();
      const targetCell = rows[minRow]?.getChildren()?.[minCol];
      if (!targetCell) {
        return false;
      }
      for (const cell of cells) {
        if (cell !== targetCell) {
          const children = cell.getChildren();
          for (const child of children) {
            targetCell.append(child);
          }
          cell.remove();
        }
      }
      targetCell.setRowSpan(rowSpan);
      targetCell.setColSpan(colSpan);
      return true;
    },
    COMMAND_PRIORITY_LOW2
  );
  const removeUnmergeCellCommand = editor.registerCommand(
    UNMERGE_TABLE_CELL_COMMAND,
    () => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection)) {
        return false;
      }
      const cell = $getTableCellNodeFromLexicalNode2(selection.anchor.getNode());
      if (!cell) {
        return false;
      }
      $unmergeCell2();
      return true;
    },
    COMMAND_PRIORITY_LOW2
  );
  const removeSetBackgroundCommand = editor.registerCommand(
    SET_TABLE_CELL_BACKGROUND_COMMAND,
    (color) => {
      const selection = $getSelection2();
      if ($isTableSelection2(selection)) {
        const nodes = selection.getNodes();
        const cells = nodes.filter((node) => $isTableCellNode2(node));
        for (const cell of cells) {
          cell.setBackgroundColor(color);
        }
        return true;
      }
      if ($isRangeSelection2(selection)) {
        const cell = $getTableCellNodeFromLexicalNode2(selection.anchor.getNode());
        if (cell) {
          cell.setBackgroundColor(color);
          return true;
        }
      }
      return false;
    },
    COMMAND_PRIORITY_LOW2
  );
  const removeEscapeHandler = editor.registerCommand(
    KEY_ESCAPE_COMMAND2,
    () => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection)) {
        return false;
      }
      const cell = $getTableCellNodeFromLexicalNode2(selection.anchor.getNode());
      if (!cell) {
        return false;
      }
      const tableNode = $findMatchingParent3(cell, (node) => $isTableNode2(node));
      if (!$isTableNode2(tableNode)) {
        return false;
      }
      const paragraphNode = $createParagraphNode2();
      tableNode.insertAfter(paragraphNode);
      paragraphNode.select();
      return true;
    },
    COMMAND_PRIORITY_LOW2
  );
  const removeSetBorderStyleCommand = editor.registerCommand(
    SET_TABLE_BORDER_STYLE_COMMAND,
    (borderStyle) => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection) && !$isTableSelection2(selection)) {
        return false;
      }
      const anchorNode = $isTableSelection2(selection) ? selection.anchor.getNode() : selection.anchor.getNode();
      const tableNode = $findMatchingParent3(anchorNode, (node) => $isTableNode2(node));
      if (!$isTableNode2(tableNode)) {
        return false;
      }
      const currentStyle = tableNode.getStyle() || "";
      const newStyle = currentStyle.replace(/--table-border-style:\s*[^;]+;?/g, "").trim();
      tableNode.setStyle(`${newStyle}; --table-border-style: ${borderStyle}`.replace(/^;\s*/, ""));
      return true;
    },
    COMMAND_PRIORITY_LOW2
  );
  const removeSetLayoutCommand = editor.registerCommand(
    SET_TABLE_LAYOUT_COMMAND,
    (layout) => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection) && !$isTableSelection2(selection)) {
        return false;
      }
      const anchorNode = $isTableSelection2(selection) ? selection.anchor.getNode() : selection.anchor.getNode();
      const tableNode = $findMatchingParent3(anchorNode, (node) => $isTableNode2(node));
      if (!$isTableNode2(tableNode)) {
        return false;
      }
      const currentStyle = tableNode.getStyle() || "";
      const newStyle = currentStyle.replace(/--table-layout:\s*[^;]+;?/g, "").replace(/table-layout:\s*[^;]+;?/g, "").trim();
      tableNode.setStyle(`${newStyle}; table-layout: ${layout}; --table-layout: ${layout}`.replace(/^;\s*/, ""));
      return true;
    },
    COMMAND_PRIORITY_LOW2
  );
  const removeSetWidthCommand = editor.registerCommand(
    SET_TABLE_WIDTH_COMMAND,
    (width) => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection) && !$isTableSelection2(selection)) {
        return false;
      }
      const anchorNode = $isTableSelection2(selection) ? selection.anchor.getNode() : selection.anchor.getNode();
      const tableNode = $findMatchingParent3(anchorNode, (node) => $isTableNode2(node));
      if (!$isTableNode2(tableNode)) {
        return false;
      }
      const currentStyle = tableNode.getStyle() || "";
      const newStyle = currentStyle.replace(/width:\s*[^;]+;?/g, "").replace(/max-width:\s*[^;]+;?/g, "").trim();
      if (width === "auto" || width === "100%") {
        tableNode.setStyle(`${newStyle}; width: 100%; max-width: 100%`.replace(/^;\s*/, ""));
      } else {
        tableNode.setStyle(`${newStyle}; width: ${width}; max-width: ${width}`.replace(/^;\s*/, ""));
      }
      return true;
    },
    COMMAND_PRIORITY_LOW2
  );
  const removeSetAlignmentCommand = editor.registerCommand(
    SET_TABLE_ALIGNMENT_COMMAND,
    (alignment) => {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection) && !$isTableSelection2(selection)) {
        return false;
      }
      const anchorNode = $isTableSelection2(selection) ? selection.anchor.getNode() : selection.anchor.getNode();
      const tableNode = $findMatchingParent3(anchorNode, (node) => $isTableNode2(node));
      if (!$isTableNode2(tableNode)) {
        return false;
      }
      const currentStyle = tableNode.getStyle() || "";
      const newStyle = currentStyle.replace(/margin-left:\s*[^;]+;?/g, "").replace(/margin-right:\s*[^;]+;?/g, "").trim();
      let alignmentStyle = "";
      switch (alignment) {
        case "left":
          alignmentStyle = "margin-left: 0; margin-right: auto";
          break;
        case "center":
          alignmentStyle = "margin-left: auto; margin-right: auto";
          break;
        case "right":
          alignmentStyle = "margin-left: auto; margin-right: 0";
          break;
      }
      tableNode.setStyle(`${newStyle}; ${alignmentStyle}`.replace(/^;\s*/, ""));
      return true;
    },
    COMMAND_PRIORITY_LOW2
  );
  return mergeRegister2(
    removeOfficialTablePlugin,
    removeTableSelectionObserver,
    removeInsertTableCommand,
    removeInsertRowCommand,
    removeInsertColumnCommand,
    removeDeleteRowCommand,
    removeDeleteColumnCommand,
    removeDeleteTableCommand,
    removeMergeCellsCommand,
    removeUnmergeCellCommand,
    removeSetBackgroundCommand,
    removeEscapeHandler,
    removeSetBorderStyleCommand,
    removeSetLayoutCommand,
    removeSetWidthCommand,
    removeSetAlignmentCommand
  );
}

// resources/js/table-context-menu.ts
var DEFAULT_CONFIG = {
  insertRowAbove: "Insert row above",
  insertRowBelow: "Insert row below",
  insertColumnLeft: "Insert column left",
  insertColumnRight: "Insert column right",
  deleteRow: "Delete row",
  deleteColumn: "Delete column",
  mergeCells: "Merge cells",
  unmergeCells: "Unmerge cell",
  cellBackground: "Cell background color",
  deleteTable: "Delete table",
  borderStyle: "Border style",
  tableLayout: "Table layout",
  tableWidth: "Table width",
  tableAlignment: "Table alignment"
};
function createTableContextMenu(editor, config = {}) {
  const labels = { ...DEFAULT_CONFIG, ...config };
  let menuElement = null;
  let colorPickerElement = null;
  function createMenuElement() {
    const menu = document.createElement("div");
    menu.className = "lexical-table-context-menu";
    menu.style.cssText = `
            position: fixed;
            z-index: 10000;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.1);
            padding: 4px 0;
            min-width: 180px;
            display: none;
        `;
    if (document.documentElement.classList.contains("dark")) {
      menu.style.background = "#1f2937";
      menu.style.borderColor = "#374151";
      menu.style.color = "#f3f4f6";
    }
    document.body.appendChild(menu);
    return menu;
  }
  function createMenuItem(label, onClick3, disabled = false) {
    const item = document.createElement("button");
    item.type = "button";
    item.className = "lexical-table-context-menu-item";
    item.textContent = label;
    item.disabled = disabled;
    item.style.cssText = `
            display: block;
            width: 100%;
            padding: 8px 12px;
            text-align: left;
            background: none;
            border: none;
            cursor: ${disabled ? "not-allowed" : "pointer"};
            font-size: 14px;
            color: ${disabled ? "#9ca3af" : "inherit"};
            opacity: ${disabled ? "0.5" : "1"};
        `;
    if (!disabled) {
      item.addEventListener("mouseenter", () => {
        item.style.background = document.documentElement.classList.contains("dark") ? "#374151" : "#f3f4f6";
      });
      item.addEventListener("mouseleave", () => {
        item.style.background = "none";
      });
      item.addEventListener("click", () => {
        onClick3();
        hide();
      });
    }
    return item;
  }
  function createDivider() {
    const divider = document.createElement("div");
    divider.style.cssText = `
            height: 1px;
            background: ${document.documentElement.classList.contains("dark") ? "#374151" : "#e5e7eb"};
            margin: 4px 0;
        `;
    return divider;
  }
  function createColorPicker() {
    const picker = document.createElement("div");
    picker.className = "lexical-table-color-picker";
    picker.style.cssText = `
            position: fixed;
            z-index: 10001;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            padding: 8px;
            display: none;
        `;
    if (document.documentElement.classList.contains("dark")) {
      picker.style.background = "#1f2937";
      picker.style.borderColor = "#374151";
    }
    const colors = [
      "#ffffff",
      "#f3f4f6",
      "#e5e7eb",
      "#d1d5db",
      "#fef2f2",
      "#fef3c7",
      "#d1fae5",
      "#dbeafe",
      "#ede9fe",
      "#fce7f3",
      "#fee2e2",
      "#fde68a",
      "#6ee7b7",
      "#93c5fd",
      "#c4b5fd",
      "#f9a8d4"
    ];
    const grid = document.createElement("div");
    grid.style.cssText = `
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 4px;
        `;
    colors.forEach((color) => {
      const swatch = document.createElement("button");
      swatch.type = "button";
      swatch.style.cssText = `
                width: 24px;
                height: 24px;
                border: 1px solid #d1d5db;
                border-radius: 4px;
                background: ${color};
                cursor: pointer;
            `;
      swatch.addEventListener("click", () => {
        editor.dispatchCommand(SET_TABLE_CELL_BACKGROUND_COMMAND, color);
        hideColorPicker();
        hide();
      });
      grid.appendChild(swatch);
    });
    const clearBtn = document.createElement("button");
    clearBtn.type = "button";
    clearBtn.textContent = "Clear";
    clearBtn.style.cssText = `
            width: 100%;
            margin-top: 8px;
            padding: 4px 8px;
            font-size: 12px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            background: none;
            cursor: pointer;
        `;
    clearBtn.addEventListener("click", () => {
      editor.dispatchCommand(SET_TABLE_CELL_BACKGROUND_COMMAND, "");
      hideColorPicker();
      hide();
    });
    picker.appendChild(grid);
    picker.appendChild(clearBtn);
    document.body.appendChild(picker);
    return picker;
  }
  function showColorPicker(x, y2) {
    if (!colorPickerElement) {
      colorPickerElement = createColorPicker();
    }
    colorPickerElement.style.left = `${x}px`;
    colorPickerElement.style.top = `${y2}px`;
    colorPickerElement.style.display = "block";
  }
  function hideColorPicker() {
    if (colorPickerElement) {
      colorPickerElement.style.display = "none";
    }
  }
  let submenuElement = null;
  function createSubmenu(items, onSelect) {
    const submenu = document.createElement("div");
    submenu.className = "lexical-table-submenu";
    submenu.style.cssText = `
            position: fixed;
            z-index: 10001;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            padding: 4px 0;
            min-width: 140px;
            display: none;
        `;
    if (document.documentElement.classList.contains("dark")) {
      submenu.style.background = "#1f2937";
      submenu.style.borderColor = "#374151";
      submenu.style.color = "#f3f4f6";
    }
    items.forEach(({ label, value }) => {
      const item = document.createElement("button");
      item.type = "button";
      item.textContent = label;
      item.style.cssText = `
                display: block;
                width: 100%;
                padding: 8px 12px;
                text-align: left;
                background: none;
                border: none;
                cursor: pointer;
                font-size: 14px;
                color: inherit;
            `;
      item.addEventListener("mouseenter", () => {
        item.style.background = document.documentElement.classList.contains("dark") ? "#374151" : "#f3f4f6";
      });
      item.addEventListener("mouseleave", () => {
        item.style.background = "none";
      });
      item.addEventListener("click", () => {
        onSelect(value);
        hideSubmenu();
        hide();
      });
      submenu.appendChild(item);
    });
    document.body.appendChild(submenu);
    return submenu;
  }
  function showSubmenu(parentItem, items, onSelect) {
    hideSubmenu();
    submenuElement = createSubmenu(items, onSelect);
    const rect = parentItem.getBoundingClientRect();
    submenuElement.style.left = `${rect.right + 4}px`;
    submenuElement.style.top = `${rect.top}px`;
    submenuElement.style.display = "block";
    requestAnimationFrame(() => {
      if (!submenuElement) return;
      const subRect = submenuElement.getBoundingClientRect();
      if (subRect.right > window.innerWidth) {
        submenuElement.style.left = `${rect.left - subRect.width - 4}px`;
      }
      if (subRect.bottom > window.innerHeight) {
        submenuElement.style.top = `${window.innerHeight - subRect.height - 10}px`;
      }
    });
  }
  function hideSubmenu() {
    if (submenuElement) {
      submenuElement.remove();
      submenuElement = null;
    }
  }
  function show(x, y2, canMerge, canUnmerge) {
    if (!menuElement) {
      menuElement = createMenuElement();
    }
    menuElement.innerHTML = "";
    menuElement.appendChild(
      createMenuItem(labels.insertRowAbove, () => {
        editor.dispatchCommand(INSERT_TABLE_ROW_COMMAND, { insertAfter: false });
      })
    );
    menuElement.appendChild(
      createMenuItem(labels.insertRowBelow, () => {
        editor.dispatchCommand(INSERT_TABLE_ROW_COMMAND, { insertAfter: true });
      })
    );
    menuElement.appendChild(createDivider());
    menuElement.appendChild(
      createMenuItem(labels.insertColumnLeft, () => {
        editor.dispatchCommand(INSERT_TABLE_COLUMN_COMMAND, { insertAfter: false });
      })
    );
    menuElement.appendChild(
      createMenuItem(labels.insertColumnRight, () => {
        editor.dispatchCommand(INSERT_TABLE_COLUMN_COMMAND, { insertAfter: true });
      })
    );
    menuElement.appendChild(createDivider());
    menuElement.appendChild(
      createMenuItem(labels.deleteRow, () => {
        editor.dispatchCommand(DELETE_TABLE_ROW_COMMAND, void 0);
      })
    );
    menuElement.appendChild(
      createMenuItem(labels.deleteColumn, () => {
        editor.dispatchCommand(DELETE_TABLE_COLUMN_COMMAND, void 0);
      })
    );
    menuElement.appendChild(createDivider());
    menuElement.appendChild(
      createMenuItem(
        labels.mergeCells,
        () => {
          editor.dispatchCommand(MERGE_TABLE_CELLS_COMMAND, void 0);
        },
        !canMerge
      )
    );
    menuElement.appendChild(
      createMenuItem(
        labels.unmergeCells,
        () => {
          editor.dispatchCommand(UNMERGE_TABLE_CELL_COMMAND, void 0);
        },
        !canUnmerge
      )
    );
    menuElement.appendChild(createDivider());
    const bgItem = createMenuItem(labels.cellBackground, () => {
      const rect = bgItem.getBoundingClientRect();
      showColorPicker(rect.right + 4, rect.top);
    });
    menuElement.appendChild(bgItem);
    menuElement.appendChild(createDivider());
    const borderItem = createMenuItem(`${labels.borderStyle} \u2192`, () => {
    });
    borderItem.addEventListener("mouseenter", () => {
      showSubmenu(
        borderItem,
        [
          { label: "None", value: "none" },
          { label: "Light", value: "light" },
          { label: "Medium", value: "medium" },
          { label: "Heavy", value: "heavy" }
        ],
        (value) => {
          editor.dispatchCommand(SET_TABLE_BORDER_STYLE_COMMAND, value);
        }
      );
    });
    menuElement.appendChild(borderItem);
    const layoutItem = createMenuItem(`${labels.tableLayout} \u2192`, () => {
    });
    layoutItem.addEventListener("mouseenter", () => {
      showSubmenu(
        layoutItem,
        [
          { label: "Auto (responsive)", value: "auto" },
          { label: "Fixed", value: "fixed" }
        ],
        (value) => {
          editor.dispatchCommand(SET_TABLE_LAYOUT_COMMAND, value);
        }
      );
    });
    menuElement.appendChild(layoutItem);
    const widthItem = createMenuItem(`${labels.tableWidth} \u2192`, () => {
    });
    widthItem.addEventListener("mouseenter", () => {
      showSubmenu(
        widthItem,
        [
          { label: "Full width (100%)", value: "100%" },
          { label: "75%", value: "75%" },
          { label: "50%", value: "50%" },
          { label: "600px", value: "600px" },
          { label: "400px", value: "400px" },
          { label: "Auto", value: "auto" }
        ],
        (value) => {
          editor.dispatchCommand(SET_TABLE_WIDTH_COMMAND, value);
        }
      );
    });
    menuElement.appendChild(widthItem);
    const alignItem = createMenuItem(`${labels.tableAlignment} \u2192`, () => {
    });
    alignItem.addEventListener("mouseenter", () => {
      showSubmenu(
        alignItem,
        [
          { label: "Left", value: "left" },
          { label: "Center", value: "center" },
          { label: "Right", value: "right" }
        ],
        (value) => {
          editor.dispatchCommand(SET_TABLE_ALIGNMENT_COMMAND, value);
        }
      );
    });
    menuElement.appendChild(alignItem);
    menuElement.appendChild(createDivider());
    const deleteTableItem = createMenuItem(labels.deleteTable, () => {
      editor.dispatchCommand(DELETE_TABLE_COMMAND, void 0);
    });
    deleteTableItem.style.color = "#ef4444";
    menuElement.appendChild(deleteTableItem);
    menuElement.style.left = `${x}px`;
    menuElement.style.top = `${y2}px`;
    menuElement.style.display = "block";
    const menuRect = menuElement.getBoundingClientRect();
    if (menuRect.right > window.innerWidth) {
      menuElement.style.left = `${Math.max(10, window.innerWidth - menuRect.width - 10)}px`;
    }
    if (menuRect.bottom > window.innerHeight) {
      menuElement.style.top = `${Math.max(10, window.innerHeight - menuRect.height - 10)}px`;
    }
    if (menuRect.top < 0) {
      menuElement.style.top = "10px";
    }
    if (menuRect.left < 0) {
      menuElement.style.left = "10px";
    }
    requestAnimationFrame(() => {
      if (!menuElement) return;
      const rect = menuElement.getBoundingClientRect();
      if (rect.right > window.innerWidth) {
        menuElement.style.left = `${Math.max(10, window.innerWidth - rect.width - 10)}px`;
      }
      if (rect.bottom > window.innerHeight) {
        menuElement.style.top = `${Math.max(10, window.innerHeight - rect.height - 10)}px`;
      }
    });
    setTimeout(() => {
      document.addEventListener("click", handleOutsideClick);
      document.addEventListener("contextmenu", handleOutsideClick);
    }, 0);
  }
  function hide() {
    if (menuElement) {
      menuElement.style.display = "none";
    }
    hideColorPicker();
    hideSubmenu();
    document.removeEventListener("click", handleOutsideClick);
    document.removeEventListener("contextmenu", handleOutsideClick);
  }
  function handleOutsideClick(event) {
    const target = event.target;
    if (menuElement && !menuElement.contains(target) && (!colorPickerElement || !colorPickerElement.contains(target)) && (!submenuElement || !submenuElement.contains(target))) {
      hide();
    }
  }
  function destroy() {
    hide();
    if (menuElement) {
      menuElement.remove();
      menuElement = null;
    }
    if (colorPickerElement) {
      colorPickerElement.remove();
      colorPickerElement = null;
    }
  }
  return { show, hide, destroy };
}

// resources/js/lexical-draggable-block-plugin.ts
var SPACE = 4;
var TARGET_LINE_HALF_HEIGHT = 2;
var DRAGGABLE_BLOCK_MENU_CLASSNAME = "lexical-draggable-block-menu";
var DRAG_DATA_FORMAT = "application/x-lexical-drag-block";
var TEXT_BOX_HORIZONTAL_PADDING = 28;
var Downward = 1;
var Upward = -1;
var Indeterminate = 0;
var prevIndex = Infinity;
function getCurrentIndex(keysLength) {
  if (keysLength === 0) {
    return Infinity;
  }
  if (prevIndex >= 0 && prevIndex < keysLength) {
    return prevIndex;
  }
  return Math.floor(keysLength / 2);
}
function getTopLevelNodeKeys(editor) {
  return editor.getEditorState().read(() => $getRoot2().getChildrenKeys());
}
function getCollapsedMargins(elem) {
  const getMargin = (element, margin) => element ? parseFloat(window.getComputedStyle(element)[margin]) : 0;
  const { marginTop, marginBottom } = window.getComputedStyle(elem);
  const prevElemSiblingMarginBottom = getMargin(
    elem.previousElementSibling,
    "marginBottom"
  );
  const nextElemSiblingMarginTop = getMargin(
    elem.nextElementSibling,
    "marginTop"
  );
  const collapsedTopMargin = Math.max(
    parseFloat(marginTop),
    prevElemSiblingMarginBottom
  );
  const collapsedBottomMargin = Math.max(
    parseFloat(marginBottom),
    nextElemSiblingMarginTop
  );
  return { marginBottom: collapsedBottomMargin, marginTop: collapsedTopMargin };
}
function getBlockElement(anchorElem, editor, event, useEdgeAsDefault = false) {
  const anchorElementRect = anchorElem.getBoundingClientRect();
  const topLevelNodeKeys = getTopLevelNodeKeys(editor);
  let blockElem = null;
  editor.getEditorState().read(() => {
    if (useEdgeAsDefault) {
      const [firstNodeKey, lastNodeKey] = [
        topLevelNodeKeys[0],
        topLevelNodeKeys[topLevelNodeKeys.length - 1]
      ];
      const [firstNode, lastNode] = [
        editor.getElementByKey(firstNodeKey),
        editor.getElementByKey(lastNodeKey)
      ];
      if (firstNode && lastNode) {
        const [firstNodeRect, lastNodeRect] = [
          firstNode.getBoundingClientRect(),
          lastNode.getBoundingClientRect()
        ];
        if (event.clientY < firstNodeRect.top) {
          blockElem = firstNode;
        } else if (event.clientY > lastNodeRect.bottom) {
          blockElem = lastNode;
        }
        if (blockElem) {
          return;
        }
      }
    }
    let index = getCurrentIndex(topLevelNodeKeys.length);
    let direction = Indeterminate;
    while (index >= 0 && index < topLevelNodeKeys.length) {
      const key = topLevelNodeKeys[index];
      const elem = editor.getElementByKey(key);
      if (elem === null) {
        break;
      }
      const point = new DOMPoint(event.clientX, event.clientY);
      const domRect = elem.getBoundingClientRect();
      const { marginTop, marginBottom } = getCollapsedMargins(elem);
      const rect = new DOMRect(
        anchorElementRect.x,
        domRect.top - marginTop,
        anchorElementRect.width,
        domRect.height + marginTop + marginBottom
      );
      const {
        top: lineTop,
        bottom: lineBottom,
        left: lineLeft,
        right: lineRight
      } = rect;
      const isOnTopSide = point.y < lineTop;
      const isOnBottomSide = point.y > lineBottom;
      const isOnLeftSide = point.x < lineLeft;
      const isOnRightSide = point.x > lineRight;
      if (isOnTopSide) {
        direction = Upward;
      } else if (isOnBottomSide) {
        direction = Downward;
      } else if (!isOnLeftSide && !isOnRightSide) {
        blockElem = elem;
        prevIndex = index;
        break;
      }
      index += direction;
    }
  });
  return blockElem;
}
function isOnMenu(element) {
  return !!element.closest(`.${DRAGGABLE_BLOCK_MENU_CLASSNAME}`);
}
function setMenuPosition(targetElem, floatingElem, anchorElem) {
  if (!targetElem) {
    floatingElem.style.opacity = "0";
    floatingElem.style.transform = "translate(-10000px, -10000px)";
    return;
  }
  const targetRect = targetElem.getBoundingClientRect();
  const targetStyle = window.getComputedStyle(targetElem);
  const floatingElemRect = floatingElem.getBoundingClientRect();
  const anchorElementRect = anchorElem.getBoundingClientRect();
  const top = targetRect.top + (parseInt(targetStyle.lineHeight, 10) - floatingElemRect.height) / 2 - anchorElementRect.top;
  const left = SPACE;
  floatingElem.style.opacity = "1";
  floatingElem.style.transform = `translate(${left}px, ${top}px)`;
}
function setDragImage(dataTransfer, draggableBlockElem) {
  const { transform } = draggableBlockElem.style;
  draggableBlockElem.style.transform = "translateZ(0)";
  dataTransfer.setDragImage(draggableBlockElem, 0, 0);
  setTimeout(() => {
    draggableBlockElem.style.transform = transform;
  });
}
function setTargetLine(targetLineElem, targetBlockElem, mouseY, anchorElem) {
  const { top: targetBlockTop, height: targetBlockHeight } = targetBlockElem.getBoundingClientRect();
  const { top: anchorTop, width: anchorWidth } = anchorElem.getBoundingClientRect();
  const { marginTop, marginBottom } = getCollapsedMargins(targetBlockElem);
  let lineTop = targetBlockTop;
  if (mouseY >= targetBlockTop + targetBlockHeight / 2) {
    lineTop += targetBlockHeight + marginBottom / 2;
  } else {
    lineTop -= marginTop / 2;
  }
  const top = lineTop - anchorTop - TARGET_LINE_HALF_HEIGHT;
  const left = TEXT_BOX_HORIZONTAL_PADDING - SPACE;
  targetLineElem.style.transform = `translate(${left}px, ${top}px)`;
  targetLineElem.style.width = `${anchorWidth - (TEXT_BOX_HORIZONTAL_PADDING - SPACE) * 2}px`;
  targetLineElem.style.opacity = "1";
}
function hideTargetLine(targetLineElem) {
  targetLineElem.style.opacity = "0";
  targetLineElem.style.transform = "translate(-10000px, -10000px)";
}
function getNodeKeyFromDOMNode2(domNode, editor) {
  const prop = "__lexicalKey_" + editor._key;
  return domNode[prop] || null;
}
function registerDraggableBlockPlugin(editor, config = {}) {
  const anchorElem = config.anchorElem || editor.getRootElement()?.parentElement;
  if (!anchorElem) {
    return () => {
    };
  }
  const menuRef = document.createElement("div");
  menuRef.className = DRAGGABLE_BLOCK_MENU_CLASSNAME;
  menuRef.innerHTML = `
        <button type="button" class="lexical-draggable-block-add" title="Click to add below">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <line x1="12" y1="5" x2="12" y2="19"></line>
                <line x1="5" y1="12" x2="19" y2="12"></line>
            </svg>
        </button>
        <div class="lexical-draggable-block-handle" draggable="true" title="Drag to move">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                <circle cx="9" cy="6" r="1.5"></circle>
                <circle cx="9" cy="12" r="1.5"></circle>
                <circle cx="9" cy="18" r="1.5"></circle>
                <circle cx="15" cy="6" r="1.5"></circle>
                <circle cx="15" cy="12" r="1.5"></circle>
                <circle cx="15" cy="18" r="1.5"></circle>
            </svg>
        </div>
    `;
  menuRef.style.cssText = `
        position: absolute;
        left: 0;
        top: 0;
        will-change: transform;
        opacity: 0;
        display: flex;
        align-items: center;
        gap: 0;
        z-index: 10;
    `;
  const isDarkMode = () => document.documentElement.classList.contains("dark");
  const addButton = menuRef.querySelector(".lexical-draggable-block-add");
  if (addButton) {
    addButton.style.cssText = `
            display: flex;
            align-items: center;
            justify-content: center;
            width: 18px;
            height: 18px;
            padding: 0;
            border: none;
            background: transparent;
            border-radius: 4px;
            cursor: pointer;
            color: ${isDarkMode() ? "#9ca3af" : "#6b7280"};
            transition: all 0.15s ease;
        `;
    addButton.addEventListener("mouseenter", () => {
      addButton.style.background = isDarkMode() ? "#374151" : "#e5e7eb";
      addButton.style.color = isDarkMode() ? "#f3f4f6" : "#111827";
    });
    addButton.addEventListener("mouseleave", () => {
      addButton.style.background = "transparent";
      addButton.style.color = isDarkMode() ? "#9ca3af" : "#6b7280";
    });
  }
  const dragHandle = menuRef.querySelector(".lexical-draggable-block-handle");
  if (dragHandle) {
    dragHandle.style.cssText = `
            display: flex;
            align-items: center;
            justify-content: center;
            width: 18px;
            height: 18px;
            padding: 0;
            border-radius: 4px;
            cursor: grab;
            color: ${isDarkMode() ? "#9ca3af" : "#6b7280"};
            transition: all 0.15s ease;
        `;
    dragHandle.addEventListener("mouseenter", () => {
      dragHandle.style.background = isDarkMode() ? "#374151" : "#e5e7eb";
      dragHandle.style.color = isDarkMode() ? "#f3f4f6" : "#111827";
    });
    dragHandle.addEventListener("mouseleave", () => {
      dragHandle.style.background = "transparent";
      dragHandle.style.color = isDarkMode() ? "#9ca3af" : "#6b7280";
    });
  }
  const targetLineRef = document.createElement("div");
  targetLineRef.className = "lexical-draggable-block-target-line";
  targetLineRef.style.cssText = `
        position: absolute;
        left: 0;
        top: 0;
        will-change: transform;
        pointer-events: none;
        height: 4px;
        background: #3b82f6;
        border-radius: 2px;
        opacity: 0;
        z-index: 10;
    `;
  anchorElem.appendChild(menuRef);
  anchorElem.appendChild(targetLineRef);
  let draggableBlockElem = null;
  let isDragging = false;
  let lastTargetBlock = null;
  function onMouseMove(event) {
    const target = event.target;
    if (!target || isDragging) {
      return;
    }
    if (isOnMenu(target)) {
      return;
    }
    const editorRoot2 = editor.getRootElement();
    if (!editorRoot2) {
      return;
    }
    const _draggableBlockElem = getBlockElement(anchorElem, editor, event);
    setMenuPosition(_draggableBlockElem, menuRef, anchorElem);
    draggableBlockElem = _draggableBlockElem;
  }
  function onMouseLeave(event) {
    if (isDragging) {
      return;
    }
    const relatedTarget = event.relatedTarget;
    if (relatedTarget && isOnMenu(relatedTarget)) {
      return;
    }
    setMenuPosition(null, menuRef, anchorElem);
    draggableBlockElem = null;
  }
  function onDragStart(event) {
    const dataTransfer = event.dataTransfer;
    if (!dataTransfer || !draggableBlockElem) {
      return;
    }
    isDragging = true;
    setDragImage(dataTransfer, draggableBlockElem);
    let nodeKey = null;
    editor.update(() => {
      const node = getNearestBlockNode(draggableBlockElem, editor);
      if (node) {
        nodeKey = node.getKey();
      }
    });
    dataTransfer.setData(DRAG_DATA_FORMAT, nodeKey || "");
  }
  function onDragEnd() {
    isDragging = false;
    hideTargetLine(targetLineRef);
    lastTargetBlock = null;
  }
  function getNearestBlockNode(element, editor2) {
    let node = null;
    editor2.getEditorState().read(() => {
      const key = getNodeKeyFromDOMNode2(element, editor2);
      if (key) {
        node = $getNodeByKey2(key);
      }
    });
    return node;
  }
  const removeDragoverCommand = editor.registerCommand(
    DRAGOVER_COMMAND2,
    (event) => {
      if (!isDragging) {
        return false;
      }
      const [isFileTransfer] = eventFiles3(event);
      if (isFileTransfer) {
        return false;
      }
      const { clientY } = event;
      const targetBlockElem = getBlockElement(anchorElem, editor, event, true);
      if (!targetBlockElem) {
        return false;
      }
      lastTargetBlock = targetBlockElem;
      setTargetLine(targetLineRef, targetBlockElem, clientY, anchorElem);
      event.preventDefault();
      return true;
    },
    COMMAND_PRIORITY_HIGH2
  );
  const removeDropCommand = editor.registerCommand(
    DROP_COMMAND2,
    (event) => {
      if (!isDragging) {
        return false;
      }
      const [isFileTransfer] = eventFiles3(event);
      if (isFileTransfer) {
        return false;
      }
      const dataTransfer = event.dataTransfer;
      const dragData = dataTransfer?.getData(DRAG_DATA_FORMAT) || "";
      if (!dragData) {
        return false;
      }
      const draggedNodeKey = dragData;
      const targetBlockElem = lastTargetBlock || getBlockElement(anchorElem, editor, event, true);
      if (!targetBlockElem) {
        return false;
      }
      const { clientY } = event;
      const { top, height } = targetBlockElem.getBoundingClientRect();
      const shouldInsertAfter = clientY >= top + height / 2;
      editor.update(() => {
        const draggedNode = $getNodeByKey2(draggedNodeKey);
        if (!draggedNode) {
          return;
        }
        const targetKey = getNodeKeyFromDOMNode2(targetBlockElem, editor);
        if (!targetKey) {
          return;
        }
        const targetNode = $getNodeByKey2(targetKey);
        if (!targetNode) {
          return;
        }
        if (draggedNodeKey === targetKey) {
          return;
        }
        if ($isListItemNode2(draggedNode)) {
          const parent = draggedNode.getParent();
          if ($isListNode2(parent) && parent.getChildrenSize() === 1) {
            if (shouldInsertAfter) {
              targetNode.insertAfter(parent);
            } else {
              targetNode.insertBefore(parent);
            }
            return;
          }
        }
        if (shouldInsertAfter) {
          targetNode.insertAfter(draggedNode);
        } else {
          targetNode.insertBefore(draggedNode);
        }
      });
      hideTargetLine(targetLineRef);
      lastTargetBlock = null;
      event.preventDefault();
      return true;
    },
    COMMAND_PRIORITY_HIGH2
  );
  const editorRoot = editor.getRootElement();
  if (editorRoot) {
    editorRoot.addEventListener("mousemove", onMouseMove);
    editorRoot.addEventListener("mouseleave", onMouseLeave);
  }
  if (dragHandle) {
    dragHandle.addEventListener("dragstart", onDragStart);
    dragHandle.addEventListener("dragend", onDragEnd);
  }
  if (addButton) {
    addButton.addEventListener("click", () => {
      if (!draggableBlockElem) return;
      editor.update(() => {
        const key = getNodeKeyFromDOMNode2(draggableBlockElem, editor);
        if (!key) return;
        const node = $getNodeByKey2(key);
        if (!node) return;
        const newParagraph = $createParagraphNode2();
        node.insertAfter(newParagraph);
        newParagraph.select();
      });
    });
  }
  return mergeRegister2(
    removeDragoverCommand,
    removeDropCommand,
    () => {
      if (editorRoot) {
        editorRoot.removeEventListener("mousemove", onMouseMove);
        editorRoot.removeEventListener("mouseleave", onMouseLeave);
      }
      if (dragHandle) {
        dragHandle.removeEventListener("dragstart", onDragStart);
        dragHandle.removeEventListener("dragend", onDragEnd);
      }
      menuRef.remove();
      targetLineRef.remove();
    }
  );
}
function eventFiles3(event) {
  const dataTransfer = event.dataTransfer;
  if (!dataTransfer) {
    return [false, []];
  }
  const types = dataTransfer.types;
  const hasFiles = types.includes("Files");
  if (!hasFiles) {
    return [false, []];
  }
  const files = Array.from(dataTransfer.files);
  return [true, files];
}

// resources/js/lexical-layout-plugin.ts
var INSERT_LAYOUT_COMMAND = createCommand2("INSERT_LAYOUT_COMMAND");
var LayoutContainerNode = class _LayoutContainerNode extends ElementNode2 {
  static getType() {
    return "layout-container";
  }
  static clone(node) {
    return new _LayoutContainerNode(node.__columns, node.__key);
  }
  constructor(columns = 2, key) {
    super(key);
    this.__columns = columns;
  }
  createDOM(config) {
    const dom = document.createElement("div");
    dom.className = `lexical-layout-container lexical-layout-${this.__columns}-col`;
    dom.setAttribute("data-columns", String(this.__columns));
    return dom;
  }
  updateDOM(prevNode, dom) {
    if (prevNode.__columns !== this.__columns) {
      dom.className = `lexical-layout-container lexical-layout-${this.__columns}-col`;
      dom.setAttribute("data-columns", String(this.__columns));
    }
    return false;
  }
  static importJSON(serializedNode) {
    return $createLayoutContainerNode(serializedNode.columns);
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      columns: this.__columns,
      type: "layout-container",
      version: 1
    };
  }
  exportDOM() {
    const element = document.createElement("div");
    element.className = `lexical-layout-container lexical-layout-${this.__columns}-col`;
    element.setAttribute("data-columns", String(this.__columns));
    return { element };
  }
  static importDOM() {
    return {
      div: (domNode) => {
        if (domNode.classList.contains("lexical-layout-container")) {
          const columns = parseInt(domNode.getAttribute("data-columns") || "2", 10);
          return {
            conversion: () => ({
              node: $createLayoutContainerNode(columns)
            }),
            priority: 1
          };
        }
        return null;
      }
    };
  }
  getColumns() {
    return this.__columns;
  }
  setColumns(columns) {
    const self2 = this.getWritable();
    self2.__columns = columns;
  }
  isShadowRoot() {
    return false;
  }
};
var LayoutItemNode = class _LayoutItemNode extends ElementNode2 {
  static getType() {
    return "layout-item";
  }
  static clone(node) {
    return new _LayoutItemNode(node.__key);
  }
  createDOM() {
    const dom = document.createElement("div");
    dom.className = "lexical-layout-item";
    return dom;
  }
  updateDOM() {
    return false;
  }
  static importJSON() {
    return $createLayoutItemNode();
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      type: "layout-item",
      version: 1
    };
  }
  exportDOM() {
    const element = document.createElement("div");
    element.className = "lexical-layout-item";
    return { element };
  }
  static importDOM() {
    return {
      div: (domNode) => {
        if (domNode.classList.contains("lexical-layout-item")) {
          return {
            conversion: () => ({
              node: $createLayoutItemNode()
            }),
            priority: 1
          };
        }
        return null;
      }
    };
  }
  isShadowRoot() {
    return false;
  }
};
function $createLayoutContainerNode(columns = 2) {
  return $applyNodeReplacement2(new LayoutContainerNode(columns));
}
function $createLayoutItemNode() {
  return $applyNodeReplacement2(new LayoutItemNode());
}
function registerLayoutPlugin(editor) {
  const removeInsertLayoutCommand = editor.registerCommand(
    INSERT_LAYOUT_COMMAND,
    (payload) => {
      const { columns } = payload;
      editor.update(() => {
        const selection = $getSelection2();
        if (!$isRangeSelection2(selection)) {
          return;
        }
        const layoutContainer = $createLayoutContainerNode(columns);
        for (let i2 = 0; i2 < columns; i2++) {
          const layoutItem = $createLayoutItemNode();
          const paragraph = $createParagraphNode2();
          layoutItem.append(paragraph);
          layoutContainer.append(layoutItem);
        }
        selection.insertNodes([layoutContainer]);
      });
      return true;
    },
    COMMAND_PRIORITY_EDITOR2
  );
  return mergeRegister2(removeInsertLayoutCommand);
}

// resources/js/lexical-youtube-plugin.ts
var INSERT_YOUTUBE_COMMAND = createCommand2("INSERT_YOUTUBE_COMMAND");
var UPDATE_YOUTUBE_COMMAND = createCommand2("UPDATE_YOUTUBE_COMMAND");
function extractYouTubeVideoID(url) {
  const patterns = [
    /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/,
    /^([a-zA-Z0-9_-]{11})$/
    // Direct video ID
  ];
  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match) {
      return match[1];
    }
  }
  return null;
}
var YouTubeNode = class _YouTubeNode extends DecoratorNode2 {
  static getType() {
    return "youtube";
  }
  static clone(node) {
    return new _YouTubeNode(node.__videoID, node.__width, node.__alignment, node.__key);
  }
  constructor(videoID, width = "100%", alignment = "center", key) {
    super(key);
    this.__videoID = videoID;
    this.__width = width;
    this.__alignment = alignment;
  }
  getAlignmentStyle() {
    switch (this.__alignment) {
      case "left":
        return "margin-left: 0; margin-right: auto;";
      case "right":
        return "margin-left: auto; margin-right: 0;";
      case "center":
      default:
        return "margin-left: auto; margin-right: auto;";
    }
  }
  createDOM(config) {
    const wrapper = document.createElement("div");
    wrapper.className = "lexical-youtube-wrapper";
    wrapper.style.cssText = `
            width: ${this.__width};
            ${this.getAlignmentStyle()}
            margin-top: 16px;
            margin-bottom: 16px;
        `;
    wrapper.setAttribute("data-youtube-width", this.__width);
    wrapper.setAttribute("data-youtube-alignment", this.__alignment);
    const container = document.createElement("div");
    container.className = "lexical-youtube-container";
    container.style.cssText = `
            position: relative;
            padding-bottom: 56.25%;
            height: 0;
            overflow: hidden;
            border-radius: 8px;
            background: #000;
        `;
    const iframe = document.createElement("iframe");
    iframe.src = `https://www.youtube-nocookie.com/embed/${this.__videoID}`;
    iframe.allow = "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture";
    iframe.allowFullscreen = true;
    iframe.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: 0;
            border-radius: 8px;
        `;
    container.appendChild(iframe);
    wrapper.appendChild(container);
    return wrapper;
  }
  updateDOM(prevNode, dom) {
    let needsUpdate = false;
    if (prevNode.__videoID !== this.__videoID) {
      const iframe = dom.querySelector("iframe");
      if (iframe) {
        iframe.src = `https://www.youtube-nocookie.com/embed/${this.__videoID}`;
      }
    }
    if (prevNode.__width !== this.__width) {
      dom.style.width = this.__width;
      dom.setAttribute("data-youtube-width", this.__width);
    }
    if (prevNode.__alignment !== this.__alignment) {
      const alignmentStyle = this.getAlignmentStyle();
      dom.style.marginLeft = this.__alignment === "left" ? "0" : "auto";
      dom.style.marginRight = this.__alignment === "right" ? "0" : "auto";
      dom.setAttribute("data-youtube-alignment", this.__alignment);
    }
    return false;
  }
  static importJSON(serializedNode) {
    return $createYouTubeNode(
      serializedNode.videoID,
      serializedNode.width || "100%",
      serializedNode.alignment || "center"
    );
  }
  exportJSON() {
    return {
      videoID: this.__videoID,
      width: this.__width,
      alignment: this.__alignment,
      type: "youtube",
      version: 1
    };
  }
  exportDOM() {
    const wrapper = document.createElement("div");
    wrapper.className = "lexical-youtube-wrapper";
    wrapper.style.cssText = `
            width: ${this.__width};
            ${this.getAlignmentStyle()}
            margin-top: 16px;
            margin-bottom: 16px;
        `;
    wrapper.setAttribute("data-youtube-video-id", this.__videoID);
    wrapper.setAttribute("data-youtube-width", this.__width);
    wrapper.setAttribute("data-youtube-alignment", this.__alignment);
    const container = document.createElement("div");
    container.className = "lexical-youtube-container";
    container.style.cssText = `
            position: relative;
            padding-bottom: 56.25%;
            height: 0;
            overflow: hidden;
        `;
    const iframe = document.createElement("iframe");
    iframe.src = `https://www.youtube-nocookie.com/embed/${this.__videoID}`;
    iframe.allow = "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture";
    iframe.allowFullscreen = true;
    iframe.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: 0;
        `;
    container.appendChild(iframe);
    wrapper.appendChild(container);
    return { element: wrapper };
  }
  static importDOM() {
    return {
      div: (domNode) => {
        if (domNode.classList.contains("lexical-youtube-wrapper")) {
          const videoID = domNode.getAttribute("data-youtube-video-id");
          const width = domNode.getAttribute("data-youtube-width") || "100%";
          const alignment = domNode.getAttribute("data-youtube-alignment") || "center";
          if (videoID) {
            return {
              conversion: () => ({
                node: $createYouTubeNode(videoID, width, alignment)
              }),
              priority: 2
            };
          }
        }
        if (domNode.classList.contains("lexical-youtube-container")) {
          const videoID = domNode.getAttribute("data-youtube-video-id");
          if (videoID) {
            return {
              conversion: () => ({
                node: $createYouTubeNode(videoID)
              }),
              priority: 1
            };
          }
        }
        return null;
      },
      iframe: (domNode) => {
        const src = domNode.getAttribute("src") || "";
        const videoID = extractYouTubeVideoID(src);
        if (videoID) {
          return {
            conversion: () => ({
              node: $createYouTubeNode(videoID)
            }),
            priority: 1
          };
        }
        return null;
      }
    };
  }
  getVideoID() {
    return this.__videoID;
  }
  getWidth() {
    return this.__width;
  }
  getAlignment() {
    return this.__alignment;
  }
  setWidth(width) {
    const self2 = this.getWritable();
    self2.__width = width;
  }
  setAlignment(alignment) {
    const self2 = this.getWritable();
    self2.__alignment = alignment;
  }
  decorate() {
    return null;
  }
  isInline() {
    return false;
  }
  canInsertTextBefore() {
    return false;
  }
  canInsertTextAfter() {
    return false;
  }
};
function $createYouTubeNode(videoID, width = "100%", alignment = "center") {
  return $applyNodeReplacement2(new YouTubeNode(videoID, width, alignment));
}
function $isYouTubeNode(node) {
  return node instanceof YouTubeNode;
}
function registerYouTubePlugin(editor) {
  const removeInsertYouTubeCommand = editor.registerCommand(
    INSERT_YOUTUBE_COMMAND,
    (payload) => {
      const { videoID, width = "100%", alignment = "center" } = payload;
      const extractedID = extractYouTubeVideoID(videoID) || videoID;
      editor.update(() => {
        const selection = $getSelection2();
        if (!$isRangeSelection2(selection)) {
          return;
        }
        const youtubeNode = $createYouTubeNode(extractedID, width, alignment);
        selection.insertNodes([youtubeNode]);
      });
      return true;
    },
    COMMAND_PRIORITY_EDITOR2
  );
  const removeUpdateYouTubeCommand = editor.registerCommand(
    UPDATE_YOUTUBE_COMMAND,
    (payload) => {
      const { nodeKey, width, alignment } = payload;
      editor.update(() => {
        const node = $getNodeByKey2(nodeKey);
        if ($isYouTubeNode(node)) {
          if (width !== void 0) {
            node.setWidth(width);
          }
          if (alignment !== void 0) {
            node.setAlignment(alignment);
          }
        }
      });
      return true;
    },
    COMMAND_PRIORITY_LOW2
  );
  return mergeRegister2(
    removeInsertYouTubeCommand,
    removeUpdateYouTubeCommand
  );
}

// resources/js/lexical-tweet-plugin.ts
var INSERT_TWEET_COMMAND = createCommand2("INSERT_TWEET_COMMAND");
var UPDATE_TWEET_COMMAND = createCommand2("UPDATE_TWEET_COMMAND");
function extractTweetID(url) {
  const patterns = [
    /(?:twitter\.com|x\.com)\/\w+\/status\/(\d+)/,
    /^(\d{10,})$/
    // Direct tweet ID (at least 10 digits)
  ];
  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match) {
      return match[1];
    }
  }
  return null;
}
function loadTwitterScript() {
  return new Promise((resolve) => {
    if (window.twttr) {
      resolve();
      return;
    }
    const existingScript = document.getElementById("twitter-wjs");
    if (existingScript) {
      existingScript.addEventListener("load", () => resolve());
      return;
    }
    const script = document.createElement("script");
    script.id = "twitter-wjs";
    script.src = "https://platform.twitter.com/widgets.js";
    script.async = true;
    script.onload = () => resolve();
    document.head.appendChild(script);
  });
}
var TweetNode = class _TweetNode extends DecoratorNode2 {
  static getType() {
    return "tweet";
  }
  static clone(node) {
    return new _TweetNode(node.__tweetID, node.__width, node.__alignment, node.__key);
  }
  constructor(tweetID, width = "550px", alignment = "center", key) {
    super(key);
    this.__tweetID = tweetID;
    this.__width = width;
    this.__alignment = alignment;
  }
  getAlignmentStyle() {
    switch (this.__alignment) {
      case "left":
        return "justify-content: flex-start;";
      case "right":
        return "justify-content: flex-end;";
      case "center":
      default:
        return "justify-content: center;";
    }
  }
  getTwitterAlign() {
    return this.__alignment;
  }
  createDOM(config) {
    const wrapper = document.createElement("div");
    wrapper.className = "lexical-tweet-wrapper";
    wrapper.style.cssText = `
            display: flex;
            ${this.getAlignmentStyle()}
            margin: 16px 0;
            min-height: 200px;
        `;
    wrapper.setAttribute("data-tweet-id", this.__tweetID);
    wrapper.setAttribute("data-tweet-width", this.__width);
    wrapper.setAttribute("data-tweet-alignment", this.__alignment);
    const container = document.createElement("div");
    container.className = "lexical-tweet-container";
    container.style.cssText = `
            width: ${this.__width};
            max-width: 100%;
        `;
    const placeholder = document.createElement("div");
    placeholder.className = "lexical-tweet-placeholder";
    placeholder.style.cssText = `
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            min-height: 200px;
            background: #f7f9fa;
            border: 1px solid #e1e8ed;
            border-radius: 12px;
            color: #657786;
            font-size: 14px;
        `;
    placeholder.innerHTML = `
            <div style="text-align: center;">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" style="margin: 0 auto 8px;">
                    <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
                </svg>
                <div>Loading tweet...</div>
            </div>
        `;
    container.appendChild(placeholder);
    const alignment = this.getTwitterAlign();
    const tweetID = this.__tweetID;
    loadTwitterScript().then(() => {
      if (window.twttr && window.twttr.widgets) {
        placeholder.remove();
        window.twttr.widgets.createTweet(tweetID, container, {
          theme: document.documentElement.classList.contains("dark") ? "dark" : "light",
          align: alignment
        });
      }
    });
    wrapper.appendChild(container);
    return wrapper;
  }
  updateDOM(prevNode, dom) {
    if (prevNode.__tweetID !== this.__tweetID) {
      return true;
    }
    if (prevNode.__width !== this.__width) {
      const container = dom.querySelector(".lexical-tweet-container");
      if (container) {
        container.style.width = this.__width;
      }
      dom.setAttribute("data-tweet-width", this.__width);
    }
    if (prevNode.__alignment !== this.__alignment) {
      dom.style.justifyContent = this.__alignment === "left" ? "flex-start" : this.__alignment === "right" ? "flex-end" : "center";
      dom.setAttribute("data-tweet-alignment", this.__alignment);
    }
    return false;
  }
  static importJSON(serializedNode) {
    return $createTweetNode(
      serializedNode.tweetID,
      serializedNode.width || "550px",
      serializedNode.alignment || "center"
    );
  }
  exportJSON() {
    return {
      tweetID: this.__tweetID,
      width: this.__width,
      alignment: this.__alignment,
      type: "tweet",
      version: 1
    };
  }
  exportDOM() {
    const wrapper = document.createElement("div");
    wrapper.className = "lexical-tweet-wrapper";
    wrapper.style.cssText = `
            display: flex;
            ${this.getAlignmentStyle()}
            margin: 16px 0;
        `;
    wrapper.setAttribute("data-tweet-id", this.__tweetID);
    wrapper.setAttribute("data-tweet-width", this.__width);
    wrapper.setAttribute("data-tweet-alignment", this.__alignment);
    const container = document.createElement("div");
    container.className = "lexical-tweet-container";
    container.style.cssText = `width: ${this.__width}; max-width: 100%;`;
    const blockquote = document.createElement("blockquote");
    blockquote.className = "twitter-tweet";
    blockquote.setAttribute("data-conversation", "none");
    blockquote.setAttribute("data-align", this.__alignment);
    const link = document.createElement("a");
    link.href = `https://twitter.com/x/status/${this.__tweetID}`;
    link.textContent = "View Tweet";
    blockquote.appendChild(link);
    container.appendChild(blockquote);
    wrapper.appendChild(container);
    return { element: wrapper };
  }
  static importDOM() {
    return {
      div: (domNode) => {
        if (domNode.classList.contains("lexical-tweet-wrapper")) {
          const tweetID = domNode.getAttribute("data-tweet-id");
          const width = domNode.getAttribute("data-tweet-width") || "550px";
          const alignment = domNode.getAttribute("data-tweet-alignment") || "center";
          if (tweetID) {
            return {
              conversion: () => ({
                node: $createTweetNode(tweetID, width, alignment)
              }),
              priority: 2
            };
          }
        }
        if (domNode.classList.contains("lexical-tweet-container")) {
          const tweetID = domNode.getAttribute("data-tweet-id");
          if (tweetID) {
            return {
              conversion: () => ({
                node: $createTweetNode(tweetID)
              }),
              priority: 1
            };
          }
        }
        return null;
      },
      blockquote: (domNode) => {
        if (domNode.classList.contains("twitter-tweet")) {
          const link = domNode.querySelector('a[href*="twitter.com"], a[href*="x.com"]');
          if (link) {
            const href = link.getAttribute("href") || "";
            const tweetID = extractTweetID(href);
            if (tweetID) {
              return {
                conversion: () => ({
                  node: $createTweetNode(tweetID)
                }),
                priority: 1
              };
            }
          }
        }
        return null;
      }
    };
  }
  getTweetID() {
    return this.__tweetID;
  }
  getWidth() {
    return this.__width;
  }
  getAlignment() {
    return this.__alignment;
  }
  setWidth(width) {
    const self2 = this.getWritable();
    self2.__width = width;
  }
  setAlignment(alignment) {
    const self2 = this.getWritable();
    self2.__alignment = alignment;
  }
  decorate() {
    return null;
  }
  isInline() {
    return false;
  }
  canInsertTextBefore() {
    return false;
  }
  canInsertTextAfter() {
    return false;
  }
};
function $createTweetNode(tweetID, width = "550px", alignment = "center") {
  return $applyNodeReplacement2(new TweetNode(tweetID, width, alignment));
}
function $isTweetNode(node) {
  return node instanceof TweetNode;
}
function registerTweetPlugin(editor) {
  const removeInsertTweetCommand = editor.registerCommand(
    INSERT_TWEET_COMMAND,
    (payload) => {
      const { tweetID, width = "550px", alignment = "center" } = payload;
      const extractedID = extractTweetID(tweetID) || tweetID;
      editor.update(() => {
        const selection = $getSelection2();
        if (!$isRangeSelection2(selection)) {
          return;
        }
        const tweetNode = $createTweetNode(extractedID, width, alignment);
        selection.insertNodes([tweetNode]);
      });
      return true;
    },
    COMMAND_PRIORITY_EDITOR2
  );
  const removeUpdateTweetCommand = editor.registerCommand(
    UPDATE_TWEET_COMMAND,
    (payload) => {
      const { nodeKey, width, alignment } = payload;
      editor.update(() => {
        const node = $getNodeByKey2(nodeKey);
        if ($isTweetNode(node)) {
          if (width !== void 0) {
            node.setWidth(width);
          }
          if (alignment !== void 0) {
            node.setAlignment(alignment);
          }
        }
      });
      return true;
    },
    COMMAND_PRIORITY_LOW2
  );
  return mergeRegister2(
    removeInsertTweetCommand,
    removeUpdateTweetCommand
  );
}

// resources/js/lexical-collapsible-plugin.ts
var INSERT_COLLAPSIBLE_COMMAND = createCommand2("INSERT_COLLAPSIBLE_COMMAND");
var TOGGLE_COLLAPSIBLE_COMMAND = createCommand2("TOGGLE_COLLAPSIBLE_COMMAND");
var CollapsibleContainerNode = class _CollapsibleContainerNode extends ElementNode2 {
  static getType() {
    return "collapsible-container";
  }
  static clone(node) {
    return new _CollapsibleContainerNode(node.__isOpen, node.__key);
  }
  constructor(isOpen = true, key) {
    super(key);
    this.__isOpen = isOpen;
  }
  createDOM(config) {
    const dom = document.createElement("details");
    dom.className = "lexical-collapsible-container";
    dom.open = this.__isOpen;
    dom.style.cssText = `
            margin: 16px 0;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            overflow: hidden;
        `;
    dom.addEventListener("toggle", () => {
    });
    return dom;
  }
  updateDOM(prevNode, dom) {
    if (prevNode.__isOpen !== this.__isOpen) {
      dom.open = this.__isOpen;
    }
    return false;
  }
  static importJSON(serializedNode) {
    return $createCollapsibleContainerNode(serializedNode.isOpen);
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      isOpen: this.__isOpen,
      type: "collapsible-container",
      version: 1
    };
  }
  exportDOM() {
    const element = document.createElement("details");
    element.className = "lexical-collapsible-container";
    element.open = this.__isOpen;
    element.style.cssText = `
            margin: 16px 0;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            overflow: hidden;
        `;
    return { element };
  }
  static importDOM() {
    return {
      details: (domNode) => {
        if (domNode.classList.contains("lexical-collapsible-container")) {
          return {
            conversion: () => ({
              node: $createCollapsibleContainerNode(domNode.open)
            }),
            priority: 1
          };
        }
        return null;
      }
    };
  }
  getIsOpen() {
    return this.__isOpen;
  }
  setIsOpen(isOpen) {
    const self2 = this.getWritable();
    self2.__isOpen = isOpen;
  }
  toggleOpen() {
    this.setIsOpen(!this.__isOpen);
  }
  isShadowRoot() {
    return false;
  }
};
var CollapsibleTitleNode = class _CollapsibleTitleNode extends DecoratorNode2 {
  static getType() {
    return "collapsible-title";
  }
  static clone(node) {
    return new _CollapsibleTitleNode(node.__title, node.__key);
  }
  constructor(title = "Click to expand", key) {
    super(key);
    this.__title = title;
  }
  createDOM(config) {
    const dom = document.createElement("summary");
    dom.className = "lexical-collapsible-title";
    dom.textContent = this.__title;
    dom.style.cssText = `
            padding: 12px 16px;
            background: #f9fafb;
            cursor: pointer;
            font-weight: 600;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 8px;
            list-style: none;
        `;
    const arrow = document.createElement("span");
    arrow.className = "lexical-collapsible-arrow";
    arrow.innerHTML = `
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="9 18 15 12 9 6"></polyline>
            </svg>
        `;
    arrow.style.cssText = `
            transition: transform 0.2s ease;
            display: flex;
        `;
    dom.insertBefore(arrow, dom.firstChild);
    const parent = dom.closest("details");
    if (parent) {
      const updateArrow = () => {
        arrow.style.transform = parent.open ? "rotate(90deg)" : "rotate(0deg)";
      };
      parent.addEventListener("toggle", updateArrow);
      updateArrow();
    }
    return dom;
  }
  updateDOM(prevNode, dom) {
    if (prevNode.__title !== this.__title) {
      const arrow = dom.querySelector(".lexical-collapsible-arrow");
      dom.textContent = this.__title;
      if (arrow) {
        dom.insertBefore(arrow, dom.firstChild);
      }
    }
    return false;
  }
  static importJSON(serializedNode) {
    return $createCollapsibleTitleNode(serializedNode.title);
  }
  exportJSON() {
    return {
      title: this.__title,
      type: "collapsible-title",
      version: 1
    };
  }
  exportDOM() {
    const element = document.createElement("summary");
    element.className = "lexical-collapsible-title";
    element.textContent = this.__title;
    element.style.cssText = `
            padding: 12px 16px;
            background: #f9fafb;
            cursor: pointer;
            font-weight: 600;
        `;
    return { element };
  }
  static importDOM() {
    return {
      summary: (domNode) => {
        if (domNode.classList.contains("lexical-collapsible-title")) {
          return {
            conversion: () => ({
              node: $createCollapsibleTitleNode(domNode.textContent || "Click to expand")
            }),
            priority: 1
          };
        }
        return null;
      }
    };
  }
  getTitle() {
    return this.__title;
  }
  setTitle(title) {
    const self2 = this.getWritable();
    self2.__title = title;
  }
  decorate() {
    return null;
  }
  isInline() {
    return false;
  }
};
var CollapsibleContentNode = class _CollapsibleContentNode extends ElementNode2 {
  static getType() {
    return "collapsible-content";
  }
  static clone(node) {
    return new _CollapsibleContentNode(node.__key);
  }
  createDOM() {
    const dom = document.createElement("div");
    dom.className = "lexical-collapsible-content";
    dom.style.cssText = `
            padding: 16px;
            border-top: 1px solid #e5e7eb;
        `;
    return dom;
  }
  updateDOM() {
    return false;
  }
  static importJSON(serializedNode) {
    return $createCollapsibleContentNode();
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      type: "collapsible-content",
      version: 1
    };
  }
  exportDOM() {
    const element = document.createElement("div");
    element.className = "lexical-collapsible-content";
    element.style.cssText = `padding: 16px;`;
    return { element };
  }
  static importDOM() {
    return {
      div: (domNode) => {
        if (domNode.classList.contains("lexical-collapsible-content")) {
          return {
            conversion: () => ({
              node: $createCollapsibleContentNode()
            }),
            priority: 1
          };
        }
        return null;
      }
    };
  }
  isShadowRoot() {
    return false;
  }
};
function $createCollapsibleContainerNode(isOpen = true) {
  return $applyNodeReplacement2(new CollapsibleContainerNode(isOpen));
}
function $createCollapsibleTitleNode(title = "Click to expand") {
  return $applyNodeReplacement2(new CollapsibleTitleNode(title));
}
function $createCollapsibleContentNode() {
  return $applyNodeReplacement2(new CollapsibleContentNode());
}
function $isCollapsibleContainerNode(node) {
  return node instanceof CollapsibleContainerNode;
}
function registerCollapsiblePlugin(editor) {
  const removeInsertCollapsibleCommand = editor.registerCommand(
    INSERT_COLLAPSIBLE_COMMAND,
    (payload) => {
      const { title = "Click to expand", isOpen = true } = payload;
      editor.update(() => {
        const selection = $getSelection2();
        if (!$isRangeSelection2(selection)) {
          return;
        }
        const container = $createCollapsibleContainerNode(isOpen);
        const titleNode = $createCollapsibleTitleNode(title);
        const contentNode = $createCollapsibleContentNode();
        const paragraph = $createParagraphNode2();
        contentNode.append(paragraph);
        container.append(titleNode);
        container.append(contentNode);
        selection.insertNodes([container]);
        paragraph.select();
      });
      return true;
    },
    COMMAND_PRIORITY_EDITOR2
  );
  const removeToggleCollapsibleCommand = editor.registerCommand(
    TOGGLE_COLLAPSIBLE_COMMAND,
    (nodeKey) => {
      editor.update(() => {
        const node = editor.getEditorState()._nodeMap.get(nodeKey);
        if ($isCollapsibleContainerNode(node)) {
          node.toggleOpen();
        }
      });
      return true;
    },
    COMMAND_PRIORITY_EDITOR2
  );
  return mergeRegister2(
    removeInsertCollapsibleCommand,
    removeToggleCollapsibleCommand
  );
}

// resources/js/lexical-date-plugin.ts
var INSERT_DATE_COMMAND = createCommand2("INSERT_DATE_COMMAND");
var UPDATE_DATE_COMMAND = createCommand2("UPDATE_DATE_COMMAND");
function formatDate(dateString, format, locale = "en-US") {
  const date = new Date(dateString);
  if (isNaN(date.getTime())) {
    return dateString;
  }
  switch (format) {
    case "short":
      return date.toLocaleDateString(locale, {
        year: "numeric",
        month: "numeric",
        day: "numeric"
      });
    case "medium":
      return date.toLocaleDateString(locale, {
        year: "numeric",
        month: "short",
        day: "numeric"
      });
    case "long":
      return date.toLocaleDateString(locale, {
        year: "numeric",
        month: "long",
        day: "numeric"
      });
    case "full":
      return date.toLocaleDateString(locale, {
        weekday: "long",
        year: "numeric",
        month: "long",
        day: "numeric"
      });
    case "relative":
      return getRelativeTime(date, locale);
    case "iso":
      return date.toISOString().split("T")[0];
    default:
      return date.toLocaleDateString(locale);
  }
}
function getRelativeTime(date, locale = "en-US") {
  const now = /* @__PURE__ */ new Date();
  const diffInMs = date.getTime() - now.getTime();
  const diffInDays = Math.round(diffInMs / (1e3 * 60 * 60 * 24));
  const rtf = new Intl.RelativeTimeFormat(locale, { numeric: "auto" });
  if (Math.abs(diffInDays) < 1) {
    return rtf.format(0, "day");
  } else if (Math.abs(diffInDays) < 7) {
    return rtf.format(diffInDays, "day");
  } else if (Math.abs(diffInDays) < 30) {
    return rtf.format(Math.round(diffInDays / 7), "week");
  } else if (Math.abs(diffInDays) < 365) {
    return rtf.format(Math.round(diffInDays / 30), "month");
  } else {
    return rtf.format(Math.round(diffInDays / 365), "year");
  }
}
var DateNode = class _DateNode extends DecoratorNode2 {
  static getType() {
    return "date";
  }
  static clone(node) {
    return new _DateNode(node.__date, node.__format, node.__locale, node.__key);
  }
  constructor(date = (/* @__PURE__ */ new Date()).toISOString(), format = "medium", locale = "en-US", key) {
    super(key);
    this.__date = date;
    this.__format = format;
    this.__locale = locale;
  }
  createDOM(config) {
    const span = document.createElement("span");
    span.className = "lexical-date";
    span.textContent = formatDate(this.__date, this.__format, this.__locale);
    span.setAttribute("data-date", this.__date);
    span.setAttribute("data-format", this.__format);
    span.setAttribute("data-locale", this.__locale);
    span.style.cssText = `
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            background: #f3f4f6;
            border-radius: 4px;
            font-size: 0.9em;
            color: #374151;
            cursor: default;
        `;
    const icon = document.createElement("span");
    icon.className = "lexical-date-icon";
    icon.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
            <line x1="16" y1="2" x2="16" y2="6"></line>
            <line x1="8" y1="2" x2="8" y2="6"></line>
            <line x1="3" y1="10" x2="21" y2="10"></line>
        </svg>`;
    icon.style.cssText = "display: flex; opacity: 0.6;";
    span.insertBefore(icon, span.firstChild);
    return span;
  }
  updateDOM(prevNode, dom) {
    if (prevNode.__date !== this.__date || prevNode.__format !== this.__format || prevNode.__locale !== this.__locale) {
      const icon = dom.querySelector(".lexical-date-icon");
      const textContent = formatDate(this.__date, this.__format, this.__locale);
      dom.textContent = "";
      if (icon) {
        dom.appendChild(icon);
      }
      dom.appendChild(document.createTextNode(textContent));
      dom.setAttribute("data-date", this.__date);
      dom.setAttribute("data-format", this.__format);
      dom.setAttribute("data-locale", this.__locale);
    }
    return false;
  }
  static importJSON(serializedNode) {
    return $createDateNode(
      serializedNode.date,
      serializedNode.format,
      serializedNode.locale
    );
  }
  exportJSON() {
    return {
      date: this.__date,
      format: this.__format,
      locale: this.__locale,
      type: "date",
      version: 1
    };
  }
  exportDOM() {
    const element = document.createElement("time");
    element.className = "lexical-date";
    element.setAttribute("datetime", this.__date);
    element.setAttribute("data-format", this.__format);
    element.setAttribute("data-locale", this.__locale);
    element.textContent = formatDate(this.__date, this.__format, this.__locale);
    return { element };
  }
  static importDOM() {
    return {
      time: (domNode) => {
        if (domNode.classList.contains("lexical-date")) {
          const datetime = domNode.getAttribute("datetime") || (/* @__PURE__ */ new Date()).toISOString();
          const format = domNode.getAttribute("data-format") || "medium";
          const locale = domNode.getAttribute("data-locale") || "en-US";
          return {
            conversion: () => ({
              node: $createDateNode(datetime, format, locale)
            }),
            priority: 1
          };
        }
        return null;
      },
      span: (domNode) => {
        if (domNode.classList.contains("lexical-date")) {
          const datetime = domNode.getAttribute("data-date") || (/* @__PURE__ */ new Date()).toISOString();
          const format = domNode.getAttribute("data-format") || "medium";
          const locale = domNode.getAttribute("data-locale") || "en-US";
          return {
            conversion: () => ({
              node: $createDateNode(datetime, format, locale)
            }),
            priority: 1
          };
        }
        return null;
      }
    };
  }
  getDate() {
    return this.__date;
  }
  getFormat() {
    return this.__format;
  }
  getLocale() {
    return this.__locale;
  }
  setDate(date) {
    const self2 = this.getWritable();
    self2.__date = date;
  }
  setFormat(format) {
    const self2 = this.getWritable();
    self2.__format = format;
  }
  setLocale(locale) {
    const self2 = this.getWritable();
    self2.__locale = locale;
  }
  getFormattedDate() {
    return formatDate(this.__date, this.__format, this.__locale);
  }
  decorate() {
    return null;
  }
  isInline() {
    return true;
  }
};
function $createDateNode(date = (/* @__PURE__ */ new Date()).toISOString(), format = "medium", locale = "en-US") {
  return $applyNodeReplacement2(new DateNode(date, format, locale));
}
function $isDateNode(node) {
  return node instanceof DateNode;
}
function registerDatePlugin(editor) {
  const removeInsertDateCommand = editor.registerCommand(
    INSERT_DATE_COMMAND,
    (payload) => {
      const { date, format = "medium", locale = "en-US" } = payload;
      editor.update(() => {
        const selection = $getSelection2();
        if (!$isRangeSelection2(selection)) {
          return;
        }
        const dateNode = $createDateNode(date, format, locale);
        selection.insertNodes([dateNode]);
      });
      return true;
    },
    COMMAND_PRIORITY_EDITOR2
  );
  const removeUpdateDateCommand = editor.registerCommand(
    UPDATE_DATE_COMMAND,
    (payload) => {
      const { nodeKey, date, format } = payload;
      editor.update(() => {
        const node = editor.getEditorState()._nodeMap.get(nodeKey);
        if ($isDateNode(node)) {
          if (date !== void 0) {
            node.setDate(date);
          }
          if (format !== void 0) {
            node.setFormat(format);
          }
        }
      });
      return true;
    },
    COMMAND_PRIORITY_EDITOR2
  );
  return mergeRegister2(
    removeInsertDateCommand,
    removeUpdateDateCommand
  );
}

// resources/js/extended-text-note.ts
var ExtendedTextNode = class _ExtendedTextNode extends TextNode2 {
  constructor(text, key) {
    super(text, key);
  }
  static getType() {
    return "extended-text";
  }
  static clone(node) {
    const clone = new _ExtendedTextNode(node.__text, node.__key);
    clone.__format = node.__format;
    clone.__style = node.__style;
    clone.__mode = node.__mode;
    clone.__detail = node.__detail;
    return clone;
  }
  static importDOM() {
    const importers = TextNode2.importDOM();
    return {
      ...importers,
      code: () => ({
        conversion: patchStyleConversion(importers?.code),
        priority: 1
      }),
      em: () => ({
        conversion: patchStyleConversion(importers?.em),
        priority: 1
      }),
      span: () => ({
        conversion: patchStyleConversion(importers?.span),
        priority: 1
      }),
      strong: () => ({
        conversion: patchStyleConversion(importers?.strong),
        priority: 1
      }),
      sub: () => ({
        conversion: patchStyleConversion(importers?.sub),
        priority: 1
      }),
      sup: () => ({
        conversion: patchStyleConversion(importers?.sup),
        priority: 1
      })
    };
  }
  static importJSON(serializedNode) {
    const node = $createExtendedTextNode(serializedNode.text);
    node.setFormat(serializedNode.format);
    node.setDetail(serializedNode.detail);
    node.setMode(serializedNode.mode);
    node.setStyle(serializedNode.style);
    return node;
  }
  isSimpleText() {
    return this.__type === "extended-text" && this.__mode === 0;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      type: "extended-text"
    };
  }
  exportDOM(editor) {
    const { element } = super.exportDOM(editor);
    if (element !== null && element instanceof HTMLElement) {
      const style = this.getStyle();
      if (style) {
        element.setAttribute("style", style);
      }
      const format = this.getFormat();
      if (format !== 0) {
        if (style && !element.getAttribute("style")) {
          element.setAttribute("style", style);
        }
      }
    }
    return { element };
  }
};
function $createExtendedTextNode(text = "") {
  return $applyNodeReplacement2(new ExtendedTextNode(text));
}
var IS_BOLD3 = 1;
var IS_ITALIC3 = 1 << 1;
var IS_STRIKETHROUGH3 = 1 << 2;
var IS_UNDERLINE3 = 1 << 3;
var IS_CODE3 = 1 << 4;
var IS_SUBSCRIPT3 = 1 << 5;
var IS_SUPERSCRIPT3 = 1 << 6;
var FORMAT_CLASS_MAP = {
  "lexical__textBold": IS_BOLD3,
  "lexical__textItalic": IS_ITALIC3,
  "lexical__textStrikethrough": IS_STRIKETHROUGH3,
  "lexical__textUnderline": IS_UNDERLINE3,
  "lexical__textCode": IS_CODE3,
  "lexical__textSubscript": IS_SUBSCRIPT3,
  "lexical__textSuperscript": IS_SUPERSCRIPT3
};
function patchStyleConversion(originalDOMConverter) {
  return (node) => {
    const original = originalDOMConverter?.(node);
    if (!original) {
      return null;
    }
    const originalOutput = original.conversion(node);
    if (!originalOutput) {
      return originalOutput;
    }
    const backgroundColor = node.style.backgroundColor;
    const color = node.style.color;
    const fontFamily = node.style.fontFamily;
    const fontWeight = node.style.fontWeight;
    const fontSize = node.style.fontSize;
    const textDecoration = node.style.textDecoration;
    let formatFromClass = 0;
    if (node.classList) {
      for (const className of Array.from(node.classList)) {
        if (FORMAT_CLASS_MAP[className]) {
          formatFromClass |= FORMAT_CLASS_MAP[className];
        }
      }
    }
    return {
      ...originalOutput,
      forChild: (lexicalNode, parent) => {
        const originalForChild = originalOutput?.forChild ?? ((x) => x);
        const result = originalForChild(lexicalNode, parent);
        if ($isTextNode2(result)) {
          const style = [
            backgroundColor ? `background-color: ${backgroundColor}` : null,
            color ? `color: ${color}` : null,
            fontFamily ? `font-family: ${fontFamily}` : null,
            fontWeight ? `font-weight: ${fontWeight}` : null,
            fontSize ? `font-size: ${fontSize}` : null,
            textDecoration ? `text-decoration: ${textDecoration}` : null
          ].filter((value) => value != null).join("; ");
          if (style.length) {
            result.setStyle(style);
          }
          if (formatFromClass !== 0) {
            const currentFormat = result.getFormat();
            result.setFormat(currentFormat | formatFromClass);
          }
        }
        return result;
      }
    };
  };
}

// resources/js/index.ts
var COMMAND_PRIORITY_LOW5 = 1;
function refEl(refs, key) {
  const el = refs?.[key];
  return el instanceof HTMLElement ? el : null;
}
function sanitizeHtmlForImages(html) {
  const doc = new DOMParser().parseFromString(html, "text/html");
  doc.querySelectorAll("img").forEach((img) => {
    const src = img.getAttribute("src") ?? "";
    if (!/^https?:\/\//i.test(src)) {
      img.remove();
    }
  });
  return doc.body.innerHTML;
}
function isAllowedImgSrc(src) {
  if (!src) return false;
  if (src.startsWith("/")) return true;
  return /^https?:\/\//i.test(src);
}
function sanitizeIncomingHtmlDocument(doc) {
  const imgs = Array.from(doc.querySelectorAll("img"));
  for (const img of imgs) {
    const src = img.getAttribute("src") ?? "";
    if (!isAllowedImgSrc(src)) {
      img.remove();
      continue;
    }
    const w2 = img.getAttribute("width");
    const h2 = img.getAttribute("height");
    if (w2 && !/^\d+$/.test(w2)) img.removeAttribute("width");
    if (h2 && !/^\d+$/.test(h2)) img.removeAttribute("height");
  }
}
function sanitizeOutgoingHtml(html) {
  if (!html) return html;
  const doc = new DOMParser().parseFromString(html, "text/html");
  sanitizeIncomingHtmlDocument(doc);
  return doc.body.innerHTML;
}
function extractImageUrls(html) {
  const urls = /* @__PURE__ */ new Set();
  if (!html) return urls;
  const doc = new DOMParser().parseFromString(html, "text/html");
  doc.querySelectorAll("img").forEach((img) => {
    const src = img.getAttribute("src");
    if (src && isAllowedImgSrc(src)) {
      urls.add(src);
    }
  });
  return urls;
}
function lexicalComponent({
  basicColors = [
    "#d0021b",
    "#f5a623",
    "#f8e71c",
    "#8b572a",
    "#7ed321",
    "#417505",
    "#bd10e0",
    "#9013fe",
    "#4a90e2",
    "#50e3c2",
    "#b8e986",
    "#000000",
    "#4a4a4a",
    "#9b9b9b",
    "#ffffff"
  ],
  state,
  enabledToolbars = [
    "undo",
    "redo",
    "normal",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "bullet",
    "numbered",
    "quote",
    "code",
    "fontSize",
    "bold",
    "italic",
    "underline",
    "icode",
    "link",
    "textColor",
    "backgroundColor",
    "lowercase",
    "uppercase",
    "capitalize",
    "strikethrough",
    "subscript",
    "superscript",
    "clear",
    "left",
    "center",
    "right",
    "justify",
    "start",
    "end",
    "indent",
    "outdent",
    "hr",
    "image"
  ],
  internalLinks = [],
  hasInternalLinks = false,
  siteUrl = ""
}) {
  const ColorisAny = coloris_default;
  const component = {
    // Alpine magic (provided at runtime)
    $refs: {},
    $nextTick: () => void 0,
    $dispatch: () => void 0,
    state: state ?? null,
    basicColors,
    toolbarState: JSON.parse(JSON.stringify(INITIAL_TOOLBAR_STATE)),
    showLinkEditor: false,
    linkEditMode: false,
    linkEditorAnchor: null,
    linkEditorUrl: null,
    // Link editor enhanced state
    linkType: "external",
    linkOpenInNewTab: true,
    selectedInternalLink: "",
    internalLinks,
    hasInternalLinks,
    siteUrl,
    editor: null,
    uploadUrl: null,
    enabledToolbars,
    // image state
    activeImageKey: null,
    imageLockAspect: true,
    imageAspectRatio: null,
    imageLastChanged: null,
    // Track images for cleanup
    originalImages: /* @__PURE__ */ new Set(),
    deletedImages: [],
    // table state
    showTableEditor: false,
    tableEditorAnchor: null,
    tableRows: 3,
    tableCols: 3,
    tableHasHeaders: true,
    tableBorderStyle: "light",
    tableCellPadding: "normal",
    tableLayout: "auto",
    tableWidth: "100%",
    tableContextMenu: null,
    // Layout state
    showLayoutEditor: false,
    layoutEditorAnchor: null,
    layoutColumns: 2,
    // YouTube state
    showYouTubeEditor: false,
    youTubeEditorAnchor: null,
    youTubeUrl: "",
    youTubeWidth: "100%",
    youTubeAlignment: "center",
    // Tweet state
    showTweetEditor: false,
    tweetEditorAnchor: null,
    tweetUrl: "",
    tweetWidth: "550px",
    tweetAlignment: "center",
    // Collapsible state
    showCollapsibleEditor: false,
    collapsibleEditorAnchor: null,
    collapsibleTitle: "Click to expand",
    collapsibleOpen: true,
    // Date state
    showDateEditor: false,
    dateEditorAnchor: null,
    dateValue: (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
    dateFormat: "medium",
    init: function() {
      this.uploadUrl = window?.filamentData?.metaLexicalEditor?.uploadUrl ?? "/filament-meta-lexical-editor/upload-image";
      const editorElement = refEl(this.$refs, "editor");
      if (!editorElement) return;
      const initialConfig = {
        namespace: "lexical-editor",
        nodes: [
          ExtendedTextNode,
          {
            replace: TextNode2,
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            with: (node) => {
              const extNode = new ExtendedTextNode(node.__text);
              extNode.__format = node.__format;
              extNode.__style = node.__style;
              extNode.__mode = node.__mode;
              extNode.__detail = node.__detail;
              return extNode;
            },
            withKlass: ExtendedTextNode
          },
          AutoLinkNode2,
          ListItemNode2,
          CodeNode2,
          HeadingNode2,
          LinkNode2,
          ListNode2,
          QuoteNode2,
          HashtagNode2,
          HorizontalRuleNode3,
          ImageNode,
          TableNode2,
          TableCellNode2,
          TableRowNode2,
          LayoutContainerNode,
          LayoutItemNode,
          YouTubeNode,
          TweetNode,
          CollapsibleContainerNode,
          CollapsibleTitleNode,
          CollapsibleContentNode,
          DateNode
        ],
        onError: console.error,
        theme
      };
      this.editor = createEditor2(initialConfig);
      this.editor.setRootElement(editorElement);
      const editor = this.editor;
      mergeRegister2(
        registerRichText2(editor),
        registerList2(editor),
        registerHistory2(editor, createEmptyHistoryState2(), 300),
        registerLink3(editor),
        registerShortcuts(editor),
        registerHorizontalRule(editor),
        registerInsertImageCommand(editor),
        registerTablePlugin3(editor),
        registerLayoutPlugin(editor),
        registerYouTubePlugin(editor),
        registerTweetPlugin(editor),
        registerCollapsiblePlugin(editor),
        registerDatePlugin(editor),
        ...registerLexicalTextEntity2(
          editor,
          getHashtagMatch2,
          HashtagNode2,
          $createHashtagNode_
        )
      );
      this.tableContextMenu = createTableContextMenu(editor);
      const editorWrapper = editorElement.parentElement;
      if (editorWrapper) {
        registerDraggableBlockPlugin(editor, {
          anchorElem: editorWrapper
        });
      }
      editorElement.addEventListener("contextmenu", (event) => {
        const target = event.target;
        const tableCell = target.closest("td, th");
        if (tableCell && this.tableContextMenu) {
          event.preventDefault();
          const contextMenu = this.tableContextMenu;
          const clientX = event.clientX;
          const clientY = event.clientY;
          editor.getEditorState().read(() => {
            const selection = $getSelection2();
            const canMerge = $isTableSelection2(selection) && selection.getNodes().filter($isTableCellNode2).length > 1;
            const canUnmerge = $isRangeSelection2(selection) && (() => {
              const node = selection.anchor.getNode();
              const cell = node.getParent();
              if ($isTableCellNode2(cell)) {
                return (cell.getRowSpan() || 1) > 1 || (cell.getColSpan() || 1) > 1;
              }
              return false;
            })();
            contextMenu.show(clientX, clientY, canMerge, canUnmerge);
          });
        }
      });
      editor.registerCommand(
        CAN_UNDO_COMMAND2,
        (payload) => {
          this.updateToolbarState("canUndo", payload);
          this.updateToolbarState("cannotUndo", !payload);
          return false;
        },
        COMMAND_PRIORITY_LOW5
      );
      editor.registerCommand(
        CAN_REDO_COMMAND2,
        (payload) => {
          this.updateToolbarState("canRedo", payload);
          this.updateToolbarState("cannotRedo", !payload);
          return false;
        },
        COMMAND_PRIORITY_LOW5
      );
      editor.registerUpdateListener(() => {
        editor.read(() => {
          const rawHtml = $generateHtmlFromNodes2(editor);
          this.state = sanitizeOutgoingHtml(rawHtml);
          this.updateToolbar();
        });
      });
      if (this.state) {
        const safeHtml = sanitizeHtmlForImages(this.state);
        this.originalImages = extractImageUrls(this.state);
        editor.update(() => {
          const dom = new DOMParser().parseFromString(safeHtml, "text/html");
          sanitizeIncomingHtmlDocument(dom);
          const nodes = $generateNodesFromDOM2(editor, dom);
          $getRoot2().select();
          $insertNodes2(nodes);
        });
      }
      this.registerToolbarActions();
      this.initColorPickers();
    },
    initColorPickers: function() {
      if (!window.__metaLexicalColorisInit) {
        window.__metaLexicalColorisInit = true;
        ColorisAny.init?.();
      }
    },
    // ---------- LINK ----------
    updateLink: function() {
      if (!this.editor) return;
      let url = null;
      if (this.linkType === "internal" && this.selectedInternalLink) {
        url = "/" + this.selectedInternalLink;
      } else {
        url = this.linkEditorUrl;
      }
      if (!url) return;
      const linkPayload = {
        url,
        target: this.linkOpenInNewTab ? "_blank" : "_self",
        rel: this.linkOpenInNewTab ? "noopener noreferrer" : ""
      };
      this.editor.dispatchCommand(TOGGLE_LINK_COMMAND2, linkPayload);
      this.linkEditMode = false;
      this.closeLinkEditorDialog();
    },
    removeLink: function() {
      if (!this.editor) return;
      this.editor.dispatchCommand(TOGGLE_LINK_COMMAND2, null);
      this.closeLinkEditorDialog();
    },
    showLinkEditorDialog: function(element, url = null, editable = true) {
      this.$nextTick(() => {
        this.linkEditorAnchor = element;
        this.linkEditMode = editable;
        this.linkEditorUrl = url;
        this.showLinkEditor = true;
        this.linkType = "external";
        this.selectedInternalLink = "";
        this.linkOpenInNewTab = true;
        if (url) {
          this.detectLinkType();
        }
      });
    },
    closeLinkEditorDialog: function() {
      this.$nextTick(() => {
        this.linkEditorAnchor = null;
        this.linkEditorUrl = null;
        this.showLinkEditor = false;
        this.linkType = "external";
        this.selectedInternalLink = "";
        this.linkOpenInNewTab = true;
      });
    },
    onInternalLinkSelected: function() {
      if (this.selectedInternalLink) {
        this.linkOpenInNewTab = false;
      }
    },
    getInternalLinkUrl: function() {
      if (!this.selectedInternalLink) return "";
      const baseUrl = this.siteUrl.replace(/\/$/, "");
      return `${baseUrl}/${this.selectedInternalLink}`;
    },
    detectLinkType: function() {
      const url = this.linkEditorUrl;
      if (!url) return;
      if (isInternalUrl(url)) {
        this.linkType = "internal";
        const slug = url.replace(/^\//, "");
        const matchingLink = this.internalLinks.find((link) => link.slug === slug);
        if (matchingLink) {
          this.selectedInternalLink = matchingLink.slug;
        }
        this.linkOpenInNewTab = false;
      } else {
        this.linkType = "external";
        this.linkOpenInNewTab = true;
      }
    },
    // ---------- IMAGE UPLOAD ----------
    handleImage: async function() {
      const input = refEl(this.$refs, "image_input");
      const altInput = refEl(this.$refs, "image_alt");
      const files = input?.files;
      const alt = altInput?.value ?? "";
      if (!files || !files[0]) return false;
      const form = new FormData();
      form.append("image", files[0]);
      form.append("alt", alt);
      const token = document.querySelector('meta[name="csrf-token"]')?.getAttribute("content") ?? "";
      const res = await fetch(this.uploadUrl ?? "/filament-meta-lexical-editor/upload-image", {
        method: "POST",
        headers: token ? { "X-CSRF-TOKEN": token } : {},
        body: form,
        credentials: "same-origin"
      });
      if (!res.ok) {
        console.error("Image upload failed:", await res.text());
        return false;
      }
      const data = await res.json();
      const payload = {
        altText: data.alt ?? alt ?? "",
        src: data.url,
        ...data.width ? { width: Number(data.width) } : {},
        ...data.height ? { height: Number(data.height) } : {}
      };
      this.insertImage(payload);
      if (input) input.value = "";
      if (altInput) altInput.value = "";
      return true;
    },
    insertImage: function(payload) {
      if (!this.editor) return;
      this.editor.dispatchCommand(INSERT_IMAGE_COMMAND, payload);
    },
    // ---------- IMAGE EDITOR ----------
    openImageEditor: function(nodeKey) {
      if (!this.editor) return;
      this.editor.read(() => {
        const node = $getNodeByKey2(nodeKey);
        if (!$isImageNode(node)) return;
        const modal = refEl(this.$refs, "imageEditorModal");
        const modalId = modal?.getAttribute("modal-id") ?? null;
        if (!modal || !modalId) return;
        const altEl = modal.querySelector("[x-ref='image_editor_alt']");
        const widthEl = modal.querySelector("[x-ref='image_editor_width']");
        const heightEl = modal.querySelector("[x-ref='image_editor_height']");
        if (!altEl || !widthEl || !heightEl) return;
        const w2 = node.getWidth();
        const h2 = node.getHeight();
        altEl.value = node.getAltText();
        widthEl.value = w2 > 0 ? String(w2) : "";
        heightEl.value = h2 > 0 ? String(h2) : "";
        this.activeImageKey = nodeKey;
        this.imageAspectRatio = w2 > 0 && h2 > 0 ? w2 / h2 : null;
        this.imageLockAspect = true;
        this.imageLastChanged = null;
        this.$dispatch("open-modal", { id: modalId });
      });
    },
    deleteImage: function(nodeKey) {
      if (!this.editor) return;
      const key = nodeKey ?? this.activeImageKey ?? "";
      if (!key) return;
      this.editor.update(() => {
        const node = $getNodeByKey2(key);
        if ($isImageNode(node)) {
          const src = node.getSrc();
          if (src && !this.deletedImages.includes(src)) {
            this.deletedImages.push(src);
          }
          node.remove();
        }
      });
      this.resetImageEditorForm();
      this.activeImageKey = null;
      this.closeImageEditorModal();
    },
    updateImage: function() {
      if (!this.editor) return;
      const key = this.activeImageKey ?? "";
      if (!key) return;
      const modal = refEl(this.$refs, "imageEditorModal");
      if (!modal) return;
      const altEl = modal.querySelector("[x-ref='image_editor_alt']");
      const widthEl = modal.querySelector("[x-ref='image_editor_width']");
      const heightEl = modal.querySelector("[x-ref='image_editor_height']");
      if (!altEl || !widthEl || !heightEl) return;
      const alt = altEl.value ?? "";
      let width = Number(widthEl.value);
      let height = Number(heightEl.value);
      width = Number.isFinite(width) ? width : 0;
      height = Number.isFinite(height) ? height : 0;
      if (this.imageLockAspect && this.imageAspectRatio) {
        if (this.imageLastChanged === "height" && height > 0) {
          width = Math.round(height * this.imageAspectRatio);
          widthEl.value = String(width);
        } else if (width > 0) {
          height = Math.round(width / this.imageAspectRatio);
          heightEl.value = String(height);
        }
      }
      this.editor.update(() => {
        const node = $getNodeByKey2(key);
        if (!$isImageNode(node)) return;
        node.setAltText(alt);
        node.setWidthAndHeight(width, height);
      });
      this.resetImageEditorForm();
      this.activeImageKey = null;
      this.closeImageEditorModal();
    },
    resetImageEditorForm: function() {
      const modal = refEl(this.$refs, "imageEditorModal");
      if (!modal) return;
      const altEl = modal.querySelector("[x-ref='image_editor_alt']");
      const widthEl = modal.querySelector("[x-ref='image_editor_width']");
      const heightEl = modal.querySelector("[x-ref='image_editor_height']");
      if (altEl) altEl.value = "";
      if (widthEl) widthEl.value = "";
      if (heightEl) heightEl.value = "";
      this.imageAspectRatio = null;
      this.imageLastChanged = null;
      this.imageLockAspect = true;
    },
    closeImageEditorModal: function() {
      const modal = refEl(this.$refs, "imageEditorModal");
      const modalId = modal?.getAttribute("modal-id") ?? null;
      if (!modalId) return;
      this.$dispatch("close-modal", { id: modalId });
    },
    toggleImageLockAspect: function() {
      if (this.imageLockAspect && !this.imageAspectRatio) {
        const modal = refEl(this.$refs, "imageEditorModal");
        if (!modal) return;
        const widthEl = modal.querySelector("[x-ref='image_editor_width']");
        const heightEl = modal.querySelector("[x-ref='image_editor_height']");
        if (!widthEl || !heightEl) return;
        const w2 = Number(widthEl.value);
        const h2 = Number(heightEl.value);
        if (Number.isFinite(w2) && Number.isFinite(h2) && w2 > 0 && h2 > 0) {
          this.imageAspectRatio = w2 / h2;
        }
      }
    },
    imageWidthInput: function() {
      this.imageLastChanged = "width";
      if (!this.imageLockAspect) return;
      const modal = refEl(this.$refs, "imageEditorModal");
      if (!modal) return;
      const widthEl = modal.querySelector("[x-ref='image_editor_width']");
      const heightEl = modal.querySelector("[x-ref='image_editor_height']");
      if (!widthEl || !heightEl) return;
      const w2 = Number(widthEl.value);
      if (!Number.isFinite(w2) || w2 <= 0) return;
      const hNow = Number(heightEl.value);
      if (!this.imageAspectRatio && Number.isFinite(hNow) && hNow > 0) {
        this.imageAspectRatio = w2 / hNow;
      }
      if (!this.imageAspectRatio) return;
      const newH = Math.round(w2 / this.imageAspectRatio);
      heightEl.value = String(newH);
    },
    imageHeightInput: function() {
      this.imageLastChanged = "height";
      if (!this.imageLockAspect) return;
      const modal = refEl(this.$refs, "imageEditorModal");
      if (!modal) return;
      const widthEl = modal.querySelector("[x-ref='image_editor_width']");
      const heightEl = modal.querySelector("[x-ref='image_editor_height']");
      if (!widthEl || !heightEl) return;
      const h2 = Number(heightEl.value);
      if (!Number.isFinite(h2) || h2 <= 0) return;
      const wNow = Number(widthEl.value);
      if (!this.imageAspectRatio && Number.isFinite(wNow) && wNow > 0) {
        this.imageAspectRatio = wNow / h2;
      }
      if (!this.imageAspectRatio) return;
      const newW = Math.round(h2 * this.imageAspectRatio);
      widthEl.value = String(newW);
    },
    // ---------- TABLE ----------
    showTableEditorDialog: function(element) {
      this.$nextTick(() => {
        this.tableEditorAnchor = element;
        this.showTableEditor = true;
        this.tableRows = 3;
        this.tableCols = 3;
        this.tableHasHeaders = true;
        this.tableBorderStyle = "light";
        this.tableCellPadding = "normal";
      });
    },
    closeTableEditorDialog: function() {
      this.$nextTick(() => {
        this.tableEditorAnchor = null;
        this.showTableEditor = false;
      });
    },
    insertTable: function() {
      if (!this.editor) {
        return;
      }
      const payload = {
        rows: this.tableRows,
        columns: this.tableCols,
        includeHeaders: this.tableHasHeaders,
        borderStyle: this.tableBorderStyle,
        cellPadding: this.tableCellPadding,
        layout: this.tableLayout,
        width: this.tableWidth
      };
      this.editor.dispatchCommand(INSERT_TABLE_COMMAND3, payload);
      this.closeTableEditorDialog();
    },
    // ---------- LAYOUT ----------
    showLayoutEditorDialog: function(element) {
      this.$nextTick(() => {
        this.layoutEditorAnchor = element;
        this.showLayoutEditor = true;
        this.layoutColumns = 2;
      });
    },
    closeLayoutEditorDialog: function() {
      this.$nextTick(() => {
        this.layoutEditorAnchor = null;
        this.showLayoutEditor = false;
      });
    },
    insertLayout: function() {
      if (!this.editor) {
        return;
      }
      const payload = {
        columns: this.layoutColumns
      };
      this.editor.dispatchCommand(INSERT_LAYOUT_COMMAND, payload);
      this.closeLayoutEditorDialog();
    },
    // ---------- YOUTUBE ----------
    showYouTubeEditorDialog: function(element) {
      this.$nextTick(() => {
        this.youTubeEditorAnchor = element;
        this.showYouTubeEditor = true;
        this.youTubeUrl = "";
        this.youTubeWidth = "100%";
        this.youTubeAlignment = "center";
      });
    },
    closeYouTubeEditorDialog: function() {
      this.$nextTick(() => {
        this.youTubeEditorAnchor = null;
        this.showYouTubeEditor = false;
      });
    },
    insertYouTube: function() {
      if (!this.editor || !this.youTubeUrl.trim()) {
        return;
      }
      const payload = {
        videoID: this.youTubeUrl.trim(),
        width: this.youTubeWidth,
        alignment: this.youTubeAlignment
      };
      this.editor.dispatchCommand(INSERT_YOUTUBE_COMMAND, payload);
      this.closeYouTubeEditorDialog();
    },
    // ---------- TWEET ----------
    showTweetEditorDialog: function(element) {
      this.$nextTick(() => {
        this.tweetEditorAnchor = element;
        this.showTweetEditor = true;
        this.tweetUrl = "";
        this.tweetWidth = "550px";
        this.tweetAlignment = "center";
      });
    },
    closeTweetEditorDialog: function() {
      this.$nextTick(() => {
        this.tweetEditorAnchor = null;
        this.showTweetEditor = false;
      });
    },
    insertTweet: function() {
      if (!this.editor || !this.tweetUrl.trim()) {
        return;
      }
      const payload = {
        tweetID: this.tweetUrl.trim(),
        width: this.tweetWidth,
        alignment: this.tweetAlignment
      };
      this.editor.dispatchCommand(INSERT_TWEET_COMMAND, payload);
      this.closeTweetEditorDialog();
    },
    // ---------- COLLAPSIBLE ----------
    showCollapsibleEditorDialog: function(element) {
      this.$nextTick(() => {
        this.collapsibleEditorAnchor = element;
        this.showCollapsibleEditor = true;
        this.collapsibleTitle = "Click to expand";
        this.collapsibleOpen = true;
      });
    },
    closeCollapsibleEditorDialog: function() {
      this.$nextTick(() => {
        this.collapsibleEditorAnchor = null;
        this.showCollapsibleEditor = false;
      });
    },
    insertCollapsible: function() {
      if (!this.editor) {
        return;
      }
      const payload = {
        title: this.collapsibleTitle,
        isOpen: this.collapsibleOpen
      };
      this.editor.dispatchCommand(INSERT_COLLAPSIBLE_COMMAND, payload);
      this.closeCollapsibleEditorDialog();
    },
    // ---------- DATE ----------
    showDateEditorDialog: function(element) {
      this.$nextTick(() => {
        this.dateEditorAnchor = element;
        this.showDateEditor = true;
        this.dateValue = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
        this.dateFormat = "medium";
      });
    },
    closeDateEditorDialog: function() {
      this.$nextTick(() => {
        this.dateEditorAnchor = null;
        this.showDateEditor = false;
      });
    },
    insertDate: function() {
      if (!this.editor || !this.dateValue) {
        return;
      }
      const payload = {
        date: new Date(this.dateValue).toISOString(),
        format: this.dateFormat
      };
      this.editor.dispatchCommand(INSERT_DATE_COMMAND, payload);
      this.closeDateEditorDialog();
    },
    setDateToday: function() {
      this.dateValue = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
    },
    setDateTomorrow: function() {
      const tomorrow = /* @__PURE__ */ new Date();
      tomorrow.setDate(tomorrow.getDate() + 1);
      this.dateValue = tomorrow.toISOString().split("T")[0];
    },
    setDateNextWeek: function() {
      const nextWeek = /* @__PURE__ */ new Date();
      nextWeek.setDate(nextWeek.getDate() + 7);
      this.dateValue = nextWeek.toISOString().split("T")[0];
    },
    getDatePreview: function() {
      if (!this.dateValue) return "";
      return formatDate(new Date(this.dateValue).toISOString(), this.dateFormat);
    },
    // ---------- FORMATTING ----------
    formatHeading: function(headingSize) {
      if (!this.editor) return;
      this.editor.update(() => {
        const selection = $getSelection2();
        if (!$isRangeSelection2(selection)) return;
        $setBlocksType2(selection, () => $createHeadingNode2(headingSize));
      });
    },
    formatAlignment: function(elementFormatType) {
      if (!this.editor) return;
      this.editor.dispatchCommand(FORMAT_ELEMENT_COMMAND2, elementFormatType);
    },
    formatFontFamily: function(fontFamily) {
      if (!this.editor) return;
      this.editor.update(() => {
        const selection = $getSelection2();
        if (!$isRangeSelection2(selection)) return;
        $patchStyleText2(selection, {
          "font-family": fontFamily
        });
      });
    },
    formatText: function(formatTextType) {
      if (!this.editor) return;
      this.editor.dispatchCommand(FORMAT_TEXT_COMMAND2, formatTextType);
    },
    formatParagraph: function() {
      if (!this.editor) return;
      this.editor.update(() => {
        const selection = $getSelection2();
        if ($isRangeSelection2(selection)) {
          $setBlocksType2(selection, () => $createParagraphNode2());
        }
      });
    },
    formatBulletList: function() {
      if (!this.editor) return;
      this.editor.dispatchCommand(INSERT_UNORDERED_LIST_COMMAND2, void 0);
    },
    formatNumberedList: function() {
      if (!this.editor) return;
      this.editor.dispatchCommand(INSERT_ORDERED_LIST_COMMAND2, void 0);
    },
    formatLineCode: function() {
      if (!this.editor) return;
      this.editor.dispatchCommand(FORMAT_TEXT_COMMAND2, "code");
    },
    insetLink: function() {
      if (!this.editor) return;
      this.editor.dispatchCommand(TOGGLE_LINK_COMMAND2, null);
    },
    insetHR: function() {
      if (!this.editor) return;
      this.editor.dispatchCommand(INSERT_HORIZONTAL_RULE_COMMAND3, void 0);
    },
    // ---------- TOOLBAR ----------
    getToolbarActions: function() {
      return {
        bold: () => this.formatText("bold"),
        strikethrough: () => this.formatText("strikethrough"),
        subscript: () => this.formatText("subscript"),
        lowercase: () => this.formatText("lowercase"),
        uppercase: () => this.formatText("uppercase"),
        capitalize: () => this.formatText("capitalize"),
        superscript: () => this.formatText("superscript"),
        italic: () => this.formatText("italic"),
        underline: () => this.formatText("underline"),
        link: (event) => {
          event.stopPropagation();
          this.insetLink();
        },
        h1: () => this.formatHeading("h1"),
        h2: () => this.formatHeading("h2"),
        h3: () => this.formatHeading("h3"),
        h4: () => this.formatHeading("h4"),
        h5: () => this.formatHeading("h5"),
        h6: () => this.formatHeading("h6"),
        normal: () => this.formatParagraph(),
        bullet: () => this.formatBulletList(),
        numbered: () => this.formatNumberedList(),
        quote: () => {
          if (!this.editor) return;
          formatQuote(this.editor);
        },
        code: () => {
          if (!this.editor) return;
          formatCode(this.editor);
        },
        decrement: () => {
          if (!this.editor) return;
          const el = refEl(this.$refs, "fontSize");
          if (!el) return;
          updateFontSize(this.editor, 2 /* decrement */, el);
        },
        increment: () => {
          if (!this.editor) return;
          const el = refEl(this.$refs, "fontSize");
          if (!el) return;
          updateFontSize(this.editor, 1 /* increment */, el);
        },
        icode: () => this.formatLineCode(),
        fontSizeChange: () => {
          if (!this.editor) return;
          const el = refEl(this.$refs, "fontSize");
          if (!el) return;
          updateFontSizeByInputValue(this.editor, Number(el.value), el);
        },
        fontSizeKeydown: (event) => {
          if (!this.editor) return;
          if (event.key !== "Enter") return;
          event.stopPropagation();
          event.preventDefault();
          const el = refEl(this.$refs, "fontSize");
          if (!el) return;
          updateFontSizeByInputValue(this.editor, Number(el.value), el);
        },
        undo: () => this.editor?.dispatchCommand(UNDO_COMMAND2, void 0),
        redo: () => this.editor?.dispatchCommand(REDO_COMMAND2, void 0),
        left: () => this.formatAlignment("left"),
        right: () => this.formatAlignment("right"),
        center: () => this.formatAlignment("center"),
        justify: () => this.formatAlignment("justify"),
        start: () => this.formatAlignment("start"),
        end: () => this.formatAlignment("end"),
        indent: () => this.editor?.dispatchCommand(INDENT_CONTENT_COMMAND2, void 0),
        outdent: () => this.editor?.dispatchCommand(OUTDENT_CONTENT_COMMAND2, void 0),
        clear: () => {
          if (!this.editor) return;
          clearFormatting(this.editor);
        },
        textColor: () => {
          const input = refEl(this.$refs, "text_color_input");
          input?.click();
          ColorisAny({
            swatches: this.basicColors,
            alpha: false,
            formatToggle: true
          });
        },
        textColorChange: (event) => {
          if (!this.editor) return;
          const target = event.target;
          const color = target.value;
          this.editor.update(() => {
            const selection = $getSelection2();
            if ($isRangeSelection2(selection)) {
              $patchStyleText2(selection, { color });
            }
          });
        },
        backgroundColor: () => {
          const input = refEl(this.$refs, "background_color_input");
          input?.click();
          ColorisAny({
            swatches: this.basicColors,
            alpha: false,
            formatToggle: true
          });
        },
        backgroundColorChange: (event) => {
          if (!this.editor) return;
          const target = event.target;
          const color = target.value;
          this.editor.update(() => {
            const selection = $getSelection2();
            if ($isRangeSelection2(selection)) {
              $patchStyleText2(selection, { "background-color": color });
            }
          });
        },
        fontFamily: (fontFamily) => this.formatFontFamily(fontFamily),
        hr: () => this.insetHR(),
        image: () => {
          const modal = refEl(this.$refs, "imageModal");
          const modalId = modal?.getAttribute("modal-id") ?? null;
          if (modalId) this.$dispatch("open-modal", { id: modalId });
        },
        table: (event) => {
          event.stopPropagation();
          const btn = refEl(this.$refs, "table");
          if (btn) this.showTableEditorDialog(btn);
        },
        columns: (event) => {
          event.stopPropagation();
          const btn = refEl(this.$refs, "columns");
          if (btn) this.showLayoutEditorDialog(btn);
        },
        youtube: (event) => {
          event.stopPropagation();
          const btn = refEl(this.$refs, "youtube");
          if (btn) this.showYouTubeEditorDialog(btn);
        },
        tweet: (event) => {
          event.stopPropagation();
          const btn = refEl(this.$refs, "tweet");
          if (btn) this.showTweetEditorDialog(btn);
        },
        collapsible: (event) => {
          event.stopPropagation();
          const btn = refEl(this.$refs, "collapsible");
          if (btn) this.showCollapsibleEditorDialog(btn);
        },
        date: (event) => {
          event.stopPropagation();
          const btn = refEl(this.$refs, "date");
          if (btn) this.showDateEditorDialog(btn);
        }
      };
    },
    registerToolbarActions: function() {
      const actions = this.getToolbarActions();
      this.enabledToolbars.forEach((toolbar) => {
        if (toolbar === "backgroundColor") {
          const btn = refEl(this.$refs, "background_color");
          const input = refEl(this.$refs, "background_color_input");
          btn?.addEventListener("click", () => actions.backgroundColor());
          input?.addEventListener("change", (event) => actions.backgroundColorChange(event));
        } else if (toolbar === "textColor") {
          const btn = refEl(this.$refs, "text_color");
          const input = refEl(this.$refs, "text_color_input");
          btn?.addEventListener("click", () => actions.textColor());
          input?.addEventListener("change", (event) => actions.textColorChange(event));
        } else if (toolbar === "link") {
          const btn = refEl(this.$refs, "link");
          btn?.addEventListener("click", (event) => actions.link(event));
        } else if (toolbar === "fontSize") {
          refEl(this.$refs, "decrement")?.addEventListener(
            "click",
            () => actions.decrement()
          );
          refEl(this.$refs, "increment")?.addEventListener(
            "click",
            () => actions.increment()
          );
          const input = refEl(this.$refs, "fontSize");
          input?.addEventListener("change", () => actions.fontSizeChange());
          input?.addEventListener("keydown", (event) => actions.fontSizeKeydown(event));
        } else if (toolbar === "fontFamily") {
          const select = refEl(this.$refs, "fontFamily");
          select?.addEventListener("change", (event) => {
            const target = event.target;
            actions.fontFamily(target.value);
          });
        } else if (toolbar === "image") {
          const el = refEl(this.$refs, "image");
          el?.addEventListener("click", () => actions.image());
        } else if (toolbar === "table") {
          const el = refEl(this.$refs, "table");
          el?.addEventListener("click", (event) => actions.table(event));
        } else if (toolbar === "columns") {
          const el = refEl(this.$refs, "columns");
          el?.addEventListener("click", (event) => actions.columns(event));
        } else if (toolbar === "youtube") {
          const el = refEl(this.$refs, "youtube");
          el?.addEventListener("click", (event) => actions.youtube(event));
        } else if (toolbar === "tweet") {
          const el = refEl(this.$refs, "tweet");
          el?.addEventListener("click", (event) => actions.tweet(event));
        } else if (toolbar === "collapsible") {
          const el = refEl(this.$refs, "collapsible");
          el?.addEventListener("click", (event) => actions.collapsible(event));
        } else if (toolbar === "divider") {
        } else {
          const el = refEl(this.$refs, toolbar);
          const action = actions[toolbar];
          if (!el || typeof action !== "function") return;
          el.addEventListener("click", () => action());
        }
      });
    },
    updateToolbar: function() {
      if (!this.editor) return;
      const selection = $getSelection2();
      if ($isRangeSelection2(selection)) {
        const anchorNode = selection.anchor.getNode();
        let element = anchorNode.getKey() === "root" ? anchorNode : $findMatchingParent3(anchorNode, (e2) => {
          const parent2 = e2.getParent();
          return parent2 !== null && $isRootOrShadowRoot2(parent2);
        });
        if (element === null) {
          element = anchorNode.getTopLevelElementOrThrow();
        }
        const elementKey = element.getKey();
        const elementDOM = this.editor.getElementByKey(elementKey);
        this.updateToolbarState("isRTL", $isParentElementRTL2(selection));
        const node = getSelectedNode(selection);
        const parent = node.getParent();
        const isLink = $isLinkNode2(parent) || $isLinkNode2(node);
        this.updateToolbarState("isLink", isLink);
        if (elementDOM !== null) {
          if ($isListNode2(element)) {
            const parentList = $getNearestNodeOfType2(anchorNode, ListNode2);
            const type = parentList ? parentList.getListType() : element.getListType();
            this.updateToolbarState("blockType", type);
          } else {
            const type = $isHeadingNode2(element) ? element.getTag() : element.getType();
            if (type in blockTypeToBlockName) {
              this.updateToolbarState(
                "blockType",
                type
              );
            }
            if ($isCodeNode2(element)) {
              const language = element.getLanguage();
              this.updateToolbarState(
                "codeLanguage",
                language ? CODE_LANGUAGE_MAP2[language] || language : ""
              );
              return;
            }
          }
        }
        this.updateToolbarState(
          "fontColor",
          $getSelectionStyleValueForProperty2(selection, "color", "#000")
        );
        this.updateToolbarState(
          "bgColor",
          $getSelectionStyleValueForProperty2(selection, "background-color", "#fff")
        );
        this.updateToolbarState(
          "fontFamily",
          $getSelectionStyleValueForProperty2(selection, "font-family", "Arial")
        );
        let matchingParent;
        if ($isLinkNode2(parent)) {
          matchingParent = $findMatchingParent3(
            node,
            (parentNode) => $isElementNode2(parentNode) && !parentNode.isInline()
          );
        }
        this.updateToolbarState(
          "elementFormat",
          $isElementNode2(matchingParent) ? matchingParent.getFormatType() : $isElementNode2(node) ? node.getFormatType() : parent?.getFormatType() || "left"
        );
      }
      if ($isRangeSelection2(selection) || $isTableSelection2(selection)) {
        this.updateToolbarState("isBold", selection.hasFormat("bold"));
        this.updateToolbarState("isItalic", selection.hasFormat("italic"));
        this.updateToolbarState("isUnderline", selection.hasFormat("underline"));
        this.updateToolbarState("isStrikethrough", selection.hasFormat("strikethrough"));
        this.updateToolbarState("isSubscript", selection.hasFormat("subscript"));
        this.updateToolbarState("isSuperscript", selection.hasFormat("superscript"));
        this.updateToolbarState("isCode", selection.hasFormat("code"));
        this.updateToolbarState(
          "fontSize",
          $getSelectionStyleValueForProperty2(selection, "font-size", "15px")
        );
        this.updateToolbarState("isLowercase", selection.hasFormat("lowercase"));
        this.updateToolbarState("isUppercase", selection.hasFormat("uppercase"));
        this.updateToolbarState("isCapitalize", selection.hasFormat("capitalize"));
      }
    },
    updateToolbarState: function(toolbar, value) {
      this.toolbarState[toolbar] = value;
      if (toolbar === "fontColor") {
        const input = refEl(this.$refs, "text_color_input");
        if (input) {
          this.$nextTick(() => {
            input.value = value ?? "#000000";
            input.dispatchEvent(new Event("input", { bubbles: true }));
          });
        }
      } else if (toolbar === "bgColor") {
        const input = refEl(this.$refs, "background_color_input");
        if (input) {
          this.$nextTick(() => {
            input.value = value ?? "#ffffff";
            input.dispatchEvent(new Event("input", { bubbles: true }));
          });
        }
      } else if (toolbar === "fontSize") {
        const input = refEl(this.$refs, "fontSize");
        if (input) input.value = String(value ?? DEFAULT_FONT_SIZE).replace("px", "");
      } else if (toolbar === "fontFamily") {
        const select = refEl(this.$refs, "fontFamily");
        if (select) select.value = String(value ?? "Arial");
      }
    }
  };
  return component;
}
export {
  lexicalComponent as default
};
/*! Bundled license information:

prismjs/prism.js:
  (**
   * Prism: Lightweight, robust, elegant syntax highlighting
   *
   * @license MIT <https://opensource.org/licenses/MIT>
   * @author Lea Verou <https://lea.verou.me>
   * @namespace
   * @public
   *)

@melloware/coloris/dist/esm/coloris.js:
  (*!
  * Copyright (c) 2021-2024 Momo Bassit.
  * Licensed under the MIT License (MIT)
  * https://github.com/mdbassit/Coloris
  * Version: 0.24.0
  * NPM: https://github.com/melloware/coloris-npm
  *)
*/
//# sourceMappingURL=filament-meta-lexical-editor.js.map
